From Coq Require Import Bool.
-----
From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.MultiPoly.
-----
Inductive BC : Set :=\n| zero : BC\n| proj : nat -> nat -> nat -> BC\n| succ : bool -> BC\n| pred : BC\n| cond : BC\n| rec : BC -> BC -> BC -> BC\n| comp : nat -> nat -> BC -> list BC -> list BC -> BC.
-----
Lemma BC_ind2' :\n  forall P : BC -> Prop,\n  forall Q : list BC -> Prop,\n  Q nil ->\n  (forall e l, P e -> Q l -> Q (e :: l)) ->\n  P zero ->\n  (forall n s i, P (proj n s i)) ->\n  (forall b, P (succ b)) ->\n  P pred ->\n  P cond ->\n  (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) ->\n  (forall n s h rl tl, P h -> Q rl -> Q tl ->\n    P (comp n s h rl tl)) ->\n  forall e, P e.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.

*****

*****
forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop) (_ : Q nil) (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)) (_ : P zero) (_ : forall n s i : nat, P (proj n s i)) (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond) (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)) (e : BC), P e
+++++
Proof.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.

*****

*****
forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop) (_ : Q nil) (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)) (_ : P zero) (_ : forall n s i : nat, P (proj n s i)) (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond) (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)) (e : BC), P e
+++++
fix BC_ind2' 12.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.

*****
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop) (_ : Q nil) (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)) (_ : P zero) (_ : forall n s i : nat, P (proj n s i)) (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond) (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)) (e : BC), P e
+++++
intros.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.

*****
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P e
+++++
destruct e.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.

*****
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P zero
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.

*****
n,n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P (proj n n0 n1)
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.

*****
b : bool
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P (succ b)
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.

*****
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P pred
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.

*****
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P cond
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P (rec e1 e2 e3)
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P (rec e1 e2 e3)
+++++
apply H6.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P e1
+++++
eapply BC_ind2'.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
?Q nil
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P zero
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall n s i : nat, P (proj n s i)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall b : bool, P (succ b)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P pred
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P cond
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P e2
+++++
eapply BC_ind2'.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
?Q nil
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P zero
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall n s i : nat, P (proj n s i)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall b : bool, P (succ b)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P pred
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P cond
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P e3
+++++
eapply BC_ind2'.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
?Q nil
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P zero
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall n s i : nat, P (proj n s i)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall b : bool, P (succ b)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P pred
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P cond
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H6.
eapply BC_ind2'.

*****
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P (comp n n0 e l l0)
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P (comp n n0 e l l0)
+++++
apply H7.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P e
+++++
eapply BC_ind2'.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
?Q nil
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P zero
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall n s i : nat, P (proj n s i)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall b : bool, P (succ b)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P pred
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P cond
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
eapply BC_ind2'.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q l
+++++
revert l.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.

*****
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall l : list BC, Q l
+++++
fix BC_ind2'0 1.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.

*****
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall l : list BC, Q l
+++++
intro.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.

*****
l : list BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q l
+++++
destruct l.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.

*****
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q nil
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q (cons b l)
+++++
apply H0.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P b
+++++
eapply BC_ind2'.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
?Q nil
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P zero
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall n s i : nat, P (proj n s i)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall b : bool, P (succ b)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P pred
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P cond
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.
eapply BC_ind2'.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l.
fix BC_ind2'0 1.
intro.
destruct l.
apply H0.

*****
l : list BC
b : BC
BC_ind2'0 : forall l : list BC, Q l
l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q l
+++++
apply BC_ind2'0.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.

*****
l,l0 : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q l0
+++++
revert l0.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.

*****
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall l0 : list BC, Q l0
+++++
fix BC_ind2'0 1.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.

*****
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall l0 : list BC, Q l0
+++++
intro.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.

*****
l0 : list BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q l0
+++++
destruct l0.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.

*****
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q nil
+++++
auto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q (cons b l0)
+++++
apply H0.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P b
+++++
eapply BC_ind2'.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
?Q nil
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P zero
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall n s i : nat, P (proj n s i)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall b : bool, P (succ b)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P pred
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
P cond
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.
eapply BC_ind2'.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.
auto.
apply H7.
revert l0.
fix BC_ind2'0 1.
intro.
destruct l0.
apply H0.

*****
l0 : list BC
b : BC
BC_ind2'0 : forall l0 : list BC, Q l0
l : list BC
e : BC
n,n0 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) \n (_ : Q rl) (_ : Q tl), P (comp n s h rl tl)
H6 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H5 : P cond
H4 : P pred
H3 : forall b : bool, P (succ b)
H2 : forall n s i : nat, P (proj n s i)
H1 : P zero
H0 : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l)
H : Q nil
Q : forall _ : list BC, Prop
P : forall _ : BC, Prop
BC_ind2' : forall (P : forall _ : BC, Prop) (Q : forall _ : list BC, Prop)\n (_ : Q nil)\n (_ : forall (e : BC) (l : list BC) (_ : P e) (_ : Q l), Q (cons e l))\n (_ : P zero) (_ : forall n s i : nat, P (proj n s i))\n (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond)\n (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1),\n P (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC) \n (_ : P h) (_ : Q rl) (_ : Q tl), P (comp n s h rl tl))\n (e : BC), P e
*****
Q l0
+++++
apply BC_ind2'0.
-----
Lemma BC_ind2' : forall P : BC -> Prop, forall Q : list BC -> Prop, Q nil -> (forall e l, P e -> Q l -> Q (e :: l)) -> P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> Q rl -> Q tl -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
fix BC_ind2' 12.
intros.
destruct e.

*****

*****

+++++
Qed.
-----
Lemma BC_ind2 :\n  forall P : BC -> Prop,\n  P zero ->\n  (forall n s i, P (proj n s i)) ->\n  (forall b, P (succ b)) ->\n  P pred ->\n  P cond ->\n  (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) ->\n  (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> \n    (forall s, In s tl -> P s) ->\n    P (comp n s h rl tl)) ->\n  forall e, P e.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.

*****

*****
forall (P : forall _ : BC, Prop) (_ : P zero) (_ : forall n s i : nat, P (proj n s i)) (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond) (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : forall (r : BC) (_ : In r rl), P r) (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)) (e : BC), P e
+++++
Proof.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.

*****

*****
forall (P : forall _ : BC, Prop) (_ : P zero) (_ : forall n s i : nat, P (proj n s i)) (_ : forall b : bool, P (succ b)) (_ : P pred) (_ : P cond) (_ : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : forall (r : BC) (_ : In r rl), P r) (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)) (e : BC), P e
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e
+++++
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
forall (e : BC) (_ : In e nil), P e
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
H6 : In e0 nil
e,e0 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e0
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.
auto.

*****
H6 : In e0 nil
e,e0 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e0
+++++
simpl in *.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.
auto.
simpl in *.

*****
H6 : False
e,e0 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e0
+++++
tauto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
forall (e : BC) (l : list BC) (_ : P e) (_ : forall (e0 : BC) (_ : In e0 l), P e0) (e0 : BC) (_ : In e0 (cons e l)), P e0
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
H8 : In e1 (cons e0 l)
e1 : BC
H7 : forall (e : BC) (_ : In e l), P e
H6 : P e0
l : list BC
e,e0 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e1
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.
auto.

*****
H8 : In e1 (cons e0 l)
e1 : BC
H7 : forall (e : BC) (_ : In e l), P e
H6 : P e0
l : list BC
e,e0 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e1
+++++
simpl in *.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.
auto.
simpl in *.

*****
H8 : or (eq e0 e1) (In e1 l)
e1 : BC
H7 : forall (e : BC) (_ : In e l), P e
H6 : P e0
l : list BC
e,e0 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e1
+++++
destruct H8.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.
auto.
simpl in *.
destruct H8.

*****
H8 : eq e0 e1
e1 : BC
H7 : forall (e : BC) (_ : In e l), P e
H6 : P e0
l : list BC
e,e0 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e1
+++++
subst.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.
auto.
simpl in *.
destruct H8.
subst.

*****
H7 : forall (e : BC) (_ : In e l), P e
H6 : P e1
e1 : BC
l : list BC
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e1
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.
auto.
simpl in *.
destruct H8.

*****
H8 : In e1 l
e1 : BC
H7 : forall (e : BC) (_ : In e l), P e
H6 : P e0
l : list BC
e,e0 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P e1
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P zero
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P zero
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
forall n s i : nat, P (proj n s i)
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
n,s,i : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P (proj n s i)
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
forall b : bool, P (succ b)
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
b : bool
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P (succ b)
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P pred
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P pred
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P cond
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P cond
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
H8 : P h1
H7 : P h0
H6 : P g
e,g,h0,h1 : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P (rec g h0 h1)
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h) (_ : forall (e : BC) (_ : In e rl), P e) (_ : forall (e : BC) (_ : In e tl), P e), P (comp n s h rl tl)
+++++
intros.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).
intros.

*****
H8 : forall (e : BC) (_ : In e tl), P e
H7 : forall (e : BC) (_ : In e rl), P e
H6 : P h
rl,tl : list BC
h : BC
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : P h)\n (_ : forall (r : BC) (_ : In r rl), P r)\n (_ : forall (s0 : BC) (_ : In s0 tl), P s0), P (comp n s h rl tl)
H4 : forall (g h0 h1 : BC) (_ : P g) (_ : P h0) (_ : P h1), P (rec g h0 h1)
H3 : P cond
H2 : P pred
H1 : forall b : bool, P (succ b)
H0 : forall n s i : nat, P (proj n s i)
H : P zero
P : forall _ : BC, Prop
*****
P (comp n s h rl tl)
+++++
auto.
-----
Lemma BC_ind2 : forall P : BC -> Prop, P zero -> (forall n s i, P (proj n s i)) -> (forall b, P (succ b)) -> P pred -> P cond -> (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) -> (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> (forall s, In s tl -> P s) -> P (comp n s h rl tl)) -> forall e, P e.
Proof.
intros.
apply BC_ind2' with (Q := fun l => forall e, In e l -> P e).

*****

*****

+++++
Qed.
-----
Inductive Arities : Set :=\n| error_rec : Arities -> Arities -> Arities -> Arities\n| error_comp : Arities -> list Arities -> list Arities -> Arities\n| error_proj : nat -> nat -> nat -> Arities\n| ok_arities : nat -> nat -> Arities.
-----
Definition aeq (x y:Arities) : bool :=\n  match x, y with\n  | ok_arities xn xs, ok_arities yn ys => beq_nat xn yn && beq_nat xs ys\n  | _, _ => false\n  end.
-----
Lemma aeq_eq (x y : Arities) :\n  aeq x y = true -> x = y.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.

*****
x,y : Arities
*****
forall _ : eq (aeq x y) true, eq x y
+++++
Proof.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.

*****
x,y : Arities
*****
forall _ : eq (aeq x y) true, eq x y
+++++
destruct x.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.

*****
x1,x2,x3,y : Arities
*****
forall _ : eq (aeq (error_rec x1 x2 x3) y) true, eq (error_rec x1 x2 x3) y
+++++
destruct y.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
x1,x2,x3,y1,y2,y3 : Arities
*****
forall _ : eq (aeq (error_rec x1 x2 x3) (error_rec y1 y2 y3)) true, eq (error_rec x1 x2 x3) (error_rec y1 y2 y3)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
x1,x2,x3,y1,y2,y3 : Arities
*****
forall _ : eq false true, eq (error_rec x1 x2 x3) (error_rec y1 y2 y3)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
x1,x2,x3,y1,y2,y3 : Arities
*****
eq (error_rec x1 x2 x3) (error_rec y1 y2 y3)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
l,l0 : list Arities
x1,x2,x3,y : Arities
*****
forall _ : eq (aeq (error_rec x1 x2 x3) (error_comp y l l0)) true, eq (error_rec x1 x2 x3) (error_comp y l l0)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
l,l0 : list Arities
x1,x2,x3,y : Arities
*****
forall _ : eq false true, eq (error_rec x1 x2 x3) (error_comp y l l0)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
l,l0 : list Arities
x1,x2,x3,y : Arities
*****
eq (error_rec x1 x2 x3) (error_comp y l l0)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
n,n0,n1 : nat
x1,x2,x3 : Arities
*****
forall _ : eq (aeq (error_rec x1 x2 x3) (error_proj n n0 n1)) true, eq (error_rec x1 x2 x3) (error_proj n n0 n1)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
n,n0,n1 : nat
x1,x2,x3 : Arities
*****
forall _ : eq false true, eq (error_rec x1 x2 x3) (error_proj n n0 n1)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
n,n0,n1 : nat
x1,x2,x3 : Arities
*****
eq (error_rec x1 x2 x3) (error_proj n n0 n1)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
n,n0 : nat
x1,x2,x3 : Arities
*****
forall _ : eq (aeq (error_rec x1 x2 x3) (ok_arities n n0)) true, eq (error_rec x1 x2 x3) (ok_arities n n0)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
n,n0 : nat
x1,x2,x3 : Arities
*****
forall _ : eq false true, eq (error_rec x1 x2 x3) (ok_arities n n0)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
n,n0 : nat
x1,x2,x3 : Arities
*****
eq (error_rec x1 x2 x3) (ok_arities n n0)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.

*****
y : Arities
l,l0 : list Arities
x : Arities
*****
forall _ : eq (aeq (error_comp x l l0) y) true, eq (error_comp x l l0) y
+++++
destruct y.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
y1,y2,y3 : Arities
l,l0 : list Arities
x : Arities
*****
forall _ : eq (aeq (error_comp x l l0) (error_rec y1 y2 y3)) true, eq (error_comp x l l0) (error_rec y1 y2 y3)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
y1,y2,y3 : Arities
l,l0 : list Arities
x : Arities
*****
forall _ : eq false true, eq (error_comp x l l0) (error_rec y1 y2 y3)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
y1,y2,y3 : Arities
l,l0 : list Arities
x : Arities
*****
eq (error_comp x l l0) (error_rec y1 y2 y3)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
l1,l2 : list Arities
y : Arities
l,l0 : list Arities
x : Arities
*****
forall _ : eq (aeq (error_comp x l l0) (error_comp y l1 l2)) true, eq (error_comp x l l0) (error_comp y l1 l2)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
l1,l2 : list Arities
y : Arities
l,l0 : list Arities
x : Arities
*****
forall _ : eq false true, eq (error_comp x l l0) (error_comp y l1 l2)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
l1,l2 : list Arities
y : Arities
l,l0 : list Arities
x : Arities
*****
eq (error_comp x l l0) (error_comp y l1 l2)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
n,n0,n1 : nat
l,l0 : list Arities
x : Arities
*****
forall _ : eq (aeq (error_comp x l l0) (error_proj n n0 n1)) true, eq (error_comp x l l0) (error_proj n n0 n1)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
n,n0,n1 : nat
l,l0 : list Arities
x : Arities
*****
forall _ : eq false true, eq (error_comp x l l0) (error_proj n n0 n1)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
n,n0,n1 : nat
l,l0 : list Arities
x : Arities
*****
eq (error_comp x l l0) (error_proj n n0 n1)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
n,n0 : nat
l,l0 : list Arities
x : Arities
*****
forall _ : eq (aeq (error_comp x l l0) (ok_arities n n0)) true, eq (error_comp x l l0) (ok_arities n n0)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
n,n0 : nat
l,l0 : list Arities
x : Arities
*****
forall _ : eq false true, eq (error_comp x l l0) (ok_arities n n0)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
n,n0 : nat
l,l0 : list Arities
x : Arities
*****
eq (error_comp x l l0) (ok_arities n n0)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.

*****
y : Arities
n,n0,n1 : nat
*****
forall _ : eq (aeq (error_proj n n0 n1) y) true, eq (error_proj n n0 n1) y
+++++
destruct y.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
y1,y2,y3 : Arities
n,n0,n1 : nat
*****
forall _ : eq (aeq (error_proj n n0 n1) (error_rec y1 y2 y3)) true, eq (error_proj n n0 n1) (error_rec y1 y2 y3)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
y1,y2,y3 : Arities
n,n0,n1 : nat
*****
forall _ : eq false true, eq (error_proj n n0 n1) (error_rec y1 y2 y3)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
y1,y2,y3 : Arities
n,n0,n1 : nat
*****
eq (error_proj n n0 n1) (error_rec y1 y2 y3)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
l,l0 : list Arities
y : Arities
n,n0,n1 : nat
*****
forall _ : eq (aeq (error_proj n n0 n1) (error_comp y l l0)) true, eq (error_proj n n0 n1) (error_comp y l l0)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
l,l0 : list Arities
y : Arities
n,n0,n1 : nat
*****
forall _ : eq false true, eq (error_proj n n0 n1) (error_comp y l l0)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
l,l0 : list Arities
y : Arities
n,n0,n1 : nat
*****
eq (error_proj n n0 n1) (error_comp y l l0)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
n,n0,n1,n2,n3,n4 : nat
*****
forall _ : eq (aeq (error_proj n n0 n1) (error_proj n2 n3 n4)) true, eq (error_proj n n0 n1) (error_proj n2 n3 n4)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
n,n0,n1,n2,n3,n4 : nat
*****
forall _ : eq false true, eq (error_proj n n0 n1) (error_proj n2 n3 n4)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
n,n0,n1,n2,n3,n4 : nat
*****
eq (error_proj n n0 n1) (error_proj n2 n3 n4)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
n,n0,n1,n2,n3 : nat
*****
forall _ : eq (aeq (error_proj n n0 n1) (ok_arities n2 n3)) true, eq (error_proj n n0 n1) (ok_arities n2 n3)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
n,n0,n1,n2,n3 : nat
*****
forall _ : eq false true, eq (error_proj n n0 n1) (ok_arities n2 n3)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
n,n0,n1,n2,n3 : nat
*****
eq (error_proj n n0 n1) (ok_arities n2 n3)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.

*****
y : Arities
n,n0 : nat
*****
forall _ : eq (aeq (ok_arities n n0) y) true, eq (ok_arities n n0) y
+++++
destruct y.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
y1,y2,y3 : Arities
n,n0 : nat
*****
forall _ : eq (aeq (ok_arities n n0) (error_rec y1 y2 y3)) true, eq (ok_arities n n0) (error_rec y1 y2 y3)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
y1,y2,y3 : Arities
n,n0 : nat
*****
forall _ : eq false true, eq (ok_arities n n0) (error_rec y1 y2 y3)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
y1,y2,y3 : Arities
n,n0 : nat
*****
eq (ok_arities n n0) (error_rec y1 y2 y3)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
l,l0 : list Arities
y : Arities
n,n0 : nat
*****
forall _ : eq (aeq (ok_arities n n0) (error_comp y l l0)) true, eq (ok_arities n n0) (error_comp y l l0)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
l,l0 : list Arities
y : Arities
n,n0 : nat
*****
forall _ : eq false true, eq (ok_arities n n0) (error_comp y l l0)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
l,l0 : list Arities
y : Arities
n,n0 : nat
*****
eq (ok_arities n n0) (error_comp y l l0)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
n,n0,n1,n2,n3 : nat
*****
forall _ : eq (aeq (ok_arities n n0) (error_proj n1 n2 n3)) true, eq (ok_arities n n0) (error_proj n1 n2 n3)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
n,n0,n1,n2,n3 : nat
*****
forall _ : eq false true, eq (ok_arities n n0) (error_proj n1 n2 n3)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq false true
n,n0,n1,n2,n3 : nat
*****
eq (ok_arities n n0) (error_proj n1 n2 n3)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.

*****
n,n0,n1,n2 : nat
*****
forall _ : eq (aeq (ok_arities n n0) (ok_arities n1 n2)) true, eq (ok_arities n n0) (ok_arities n1 n2)
+++++
simpl.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.

*****
n,n0,n1,n2 : nat
*****
forall _ : eq (andb (Nat.eqb n n1) (Nat.eqb n0 n2)) true, eq (ok_arities n n0) (ok_arities n1 n2)
+++++
intros.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.

*****
H : eq (andb (Nat.eqb n n1) (Nat.eqb n0 n2)) true
n,n0,n1,n2 : nat
*****
eq (ok_arities n n0) (ok_arities n1 n2)
+++++
try discriminate.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.
try discriminate.

*****
H : eq (andb (Nat.eqb n n1) (Nat.eqb n0 n2)) true
n,n0,n1,n2 : nat
*****
eq (ok_arities n n0) (ok_arities n1 n2)
+++++
apply andb_true_iff in H.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.
try discriminate.
apply andb_true_iff in H.

*****
H : and (eq (Nat.eqb n n1) true) (eq (Nat.eqb n0 n2) true)
n,n0,n1,n2 : nat
*****
eq (ok_arities n n0) (ok_arities n1 n2)
+++++
destruct H.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.
try discriminate.
apply andb_true_iff in H.
destruct H.

*****
H0 : eq (Nat.eqb n0 n2) true
H : eq (Nat.eqb n n1) true
n,n0,n1,n2 : nat
*****
eq (ok_arities n n0) (ok_arities n1 n2)
+++++
apply beq_nat_true in H.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.
try discriminate.
apply andb_true_iff in H.
destruct H.
apply beq_nat_true in H.

*****
H0 : eq (Nat.eqb n0 n2) true
H : eq n n1
n,n0,n1,n2 : nat
*****
eq (ok_arities n n0) (ok_arities n1 n2)
+++++
apply beq_nat_true in H0.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.
try discriminate.
apply andb_true_iff in H.
destruct H.
apply beq_nat_true in H.
apply beq_nat_true in H0.

*****
H0 : eq n0 n2
H : eq n n1
n,n0,n1,n2 : nat
*****
eq (ok_arities n n0) (ok_arities n1 n2)
+++++
subst.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.
destruct y.
simpl.
intros.
try discriminate.
apply andb_true_iff in H.
destruct H.
apply beq_nat_true in H.
apply beq_nat_true in H0.
subst.

*****
n1,n2 : nat
*****
eq (ok_arities n1 n2) (ok_arities n1 n2)
+++++
trivial.
-----
Lemma aeq_eq (x y : Arities) : aeq x y = true -> x = y.
Proof.
destruct x.

*****

*****

+++++
Qed.
-----
Lemma aeq_eq_conv xn yn xs ys :\n  aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \/ xs <> ys.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.

*****
xn,yn,xs,ys : nat
*****
forall _ : eq (aeq (ok_arities xn xs) (ok_arities yn ys)) false, or (not (eq xn yn)) (not (eq xs ys))
+++++
Proof.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.

*****
xn,yn,xs,ys : nat
*****
forall _ : eq (aeq (ok_arities xn xs) (ok_arities yn ys)) false, or (not (eq xn yn)) (not (eq xs ys))
+++++
simpl.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.
simpl.

*****
xn,yn,xs,ys : nat
*****
forall _ : eq (andb (Nat.eqb xn yn) (Nat.eqb xs ys)) false, or (not (eq xn yn)) (not (eq xs ys))
+++++
intros.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.
simpl.
intros.

*****
H : eq (andb (Nat.eqb xn yn) (Nat.eqb xs ys)) false
xn,yn,xs,ys : nat
*****
or (not (eq xn yn)) (not (eq xs ys))
+++++
apply andb_false_elim in H.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.
simpl.
intros.
apply andb_false_elim in H.

*****
H : sumbool (eq (Nat.eqb xn yn) false) (eq (Nat.eqb xs ys) false)
xn,yn,xs,ys : nat
*****
or (not (eq xn yn)) (not (eq xs ys))
+++++
destruct H as [H | H].
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.
simpl.
intros.
apply andb_false_elim in H.
destruct H as [H | H].

*****
H : eq (Nat.eqb xn yn) false
xn,yn,xs,ys : nat
*****
or (not (eq xn yn)) (not (eq xs ys))
+++++
apply beq_nat_false in H.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.
simpl.
intros.
apply andb_false_elim in H.
destruct H as [H | H].
apply beq_nat_false in H.

*****
H : not (eq xn yn)
xn,yn,xs,ys : nat
*****
or (not (eq xn yn)) (not (eq xs ys))
+++++
tauto.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.
simpl.
intros.
apply andb_false_elim in H.
destruct H as [H | H].

*****
H : eq (Nat.eqb xs ys) false
xn,yn,xs,ys : nat
*****
or (not (eq xn yn)) (not (eq xs ys))
+++++
apply beq_nat_false in H.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.
simpl.
intros.
apply andb_false_elim in H.
destruct H as [H | H].
apply beq_nat_false in H.

*****
H : not (eq xs ys)
xn,yn,xs,ys : nat
*****
or (not (eq xn yn)) (not (eq xs ys))
+++++
tauto.
-----
Lemma aeq_eq_conv xn yn xs ys : aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \\/ xs <> ys.
Proof.
simpl.
intros.
apply andb_false_elim in H.
destruct H as [H | H].

*****

*****

+++++
Qed.
-----
Fixpoint arities (e:BC) : Arities :=\n  match e with\n  | zero => ok_arities 0 0\n  | proj n s i => \n    if leb (S i) (n + s) then ok_arities n s\n      else error_proj n s i\n  | succ _ => ok_arities 0 1\n  | pred => ok_arities 0 1\n  | cond => ok_arities 0 4\n  | rec g h0 h1 =>\n      match arities g, arities h0, arities h1 \n        with | ok_arities gn gs, ok_arities h0n h0s, ok_arities h1n h1s =>\n          if beq_nat (S gn) h0n && beq_nat h0n h1n &&\n            beq_nat (S gs) h0s && beq_nat h0s h1s \n          then ok_arities h0n gs \n            else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s)\n        | e1, e2, e3 => error_rec e1 e2 e3\n      end\n    | comp n s h nl sl =>\n      match arities h, map arities nl, map arities sl with\n      | ok_arities hn hs, anl, asl =>\n        if beq_nat hn (length nl) && beq_nat hs (length sl) && \n          forallb (fun ne => aeq (arities ne) (ok_arities n 0)) nl &&\n          forallb (fun se => aeq (arities se) (ok_arities n s)) sl\n          then ok_arities n s\n          else error_comp (ok_arities hn hs) anl asl \n      | e , anl, asl => error_comp e anl asl\n      end\n  end.
-----
Definition arities2 e :=\n  match arities e with\n    | ok_arities n s => (n, s)\n    | _ => (0, 0)\n  end.
-----
Lemma proj_arities : forall n s i, \n  i < n+s -> \n  arities (proj n s i) = ok_arities n s.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), eq (arities (proj n s i)) (ok_arities n s)
+++++
Proof.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), eq (arities (proj n s i)) (ok_arities n s)
+++++
intros n s i Hi.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.

*****
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (arities (proj n s i)) (ok_arities n s)
+++++
simpl.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.

*****
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (if match Init.Nat.add n s with | O => false | S m' => Nat.leb i m' end then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
case_eq (n+s).
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).

*****
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
forall _ : eq (Init.Nat.add n s) O, eq (error_proj n s i) (ok_arities n s)
+++++
intro H.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intro H.

*****
H : eq (Init.Nat.add n s) O
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
contradict Hi.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intro H.
contradict Hi.

*****
H : eq (Init.Nat.add n s) O
n,s,i : nat
*****
not (lt i (Init.Nat.add n s))
+++++
omega.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).

*****
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n s) (S n0)), eq (if Nat.leb i n0 then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
intros ns Hns.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intros ns Hns.

*****
Hns : eq (Init.Nat.add n s) (S ns)
ns : nat
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (if Nat.leb i ns then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
case_eq (leb i ns).
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intros ns Hns.
case_eq (leb i ns).

*****
Hns : eq (Init.Nat.add n s) (S ns)
ns : nat
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
forall _ : eq (Nat.leb i ns) true, eq (ok_arities n s) (ok_arities n s)
+++++
intros H0.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intros ns Hns.
case_eq (leb i ns).
intros H0.

*****
H0 : eq (Nat.leb i ns) true
Hns : eq (Init.Nat.add n s) (S ns)
ns : nat
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (ok_arities n s) (ok_arities n s)
+++++
apply leb_complete in H0.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intros ns Hns.
case_eq (leb i ns).
intros H0.
apply leb_complete in H0.

*****
H0 : le i ns
Hns : eq (Init.Nat.add n s) (S ns)
ns : nat
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (ok_arities n s) (ok_arities n s)
+++++
trivial.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intros ns Hns.
case_eq (leb i ns).

*****
Hns : eq (Init.Nat.add n s) (S ns)
ns : nat
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
forall _ : eq (Nat.leb i ns) false, eq (error_proj n s i) (ok_arities n s)
+++++
intros H0.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intros ns Hns.
case_eq (leb i ns).
intros H0.

*****
H0 : eq (Nat.leb i ns) false
Hns : eq (Init.Nat.add n s) (S ns)
ns : nat
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
apply leb_complete_conv in H0.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intros ns Hns.
case_eq (leb i ns).
intros H0.
apply leb_complete_conv in H0.

*****
H0 : lt ns i
Hns : eq (Init.Nat.add n s) (S ns)
ns : nat
Hi : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
contradict Hi.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).
intros ns Hns.
case_eq (leb i ns).
intros H0.
apply leb_complete_conv in H0.
contradict Hi.

*****
H0 : lt ns i
Hns : eq (Init.Nat.add n s) (S ns)
n,s,i,ns : nat
*****
not (lt i (Init.Nat.add n s))
+++++
omega.
-----
Lemma proj_arities : forall n s i, i < n+s -> arities (proj n s i) = ok_arities n s.
Proof.
intros n s i Hi.
simpl.
case_eq (n+s).

*****

*****

+++++
Qed.
-----
Lemma comp_arities : forall n s e nel sel,\n  arities e = ok_arities (length nel) (length sel) ->\n  andl (fun ne => arities ne = ok_arities n 0) nel ->\n  andl (fun se => arities se = ok_arities n s) sel ->\n  arities (comp n s e nel sel) = ok_arities n s.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.

*****

*****
forall (n s : nat) (e : BC) (nel sel : list BC) (_ : eq (arities e) (ok_arities (length nel) (length sel))) (_ : andl (fun ne : BC => eq (arities ne) (ok_arities n O)) nel) (_ : andl (fun se : BC => eq (arities se) (ok_arities n s)) sel), eq (arities (comp n s e nel sel)) (ok_arities n s)
+++++
Proof.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.

*****

*****
forall (n s : nat) (e : BC) (nel sel : list BC) (_ : eq (arities e) (ok_arities (length nel) (length sel))) (_ : andl (fun ne : BC => eq (arities ne) (ok_arities n O)) nel) (_ : andl (fun se : BC => eq (arities se) (ok_arities n s)) sel), eq (arities (comp n s e nel sel)) (ok_arities n s)
+++++
intros b s e nel sel He Hnel Hsel.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (arities (comp b s e nel sel)) (ok_arities b s)
+++++
simpl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq match arities e with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities nel) (map arities sel) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities nel) (map arities sel) | error_proj n n0 n1 => error_comp (error_proj n n0 n1) (map arities nel) (map arities sel) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length nel)) (Nat.eqb hs (length sel))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities b O)) nel)) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities hn hs) (map arities nel) (map arities sel) end (ok_arities b s)
+++++
rewrite He.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb (Nat.eqb (length nel) (length nel)) (Nat.eqb (length sel) (length sel))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities b O)) nel)) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
rewrite <- !beq_nat_refl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) (forallb (fun ne : BC => aeq (arities ne) (ok_arities b O)) nel)) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
forall _ : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b O)) nel) true, eq (if andb (andb (andb true true) true) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
intros _.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) true) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
forall _ : eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) true, eq (if andb (andb (andb true true) true) true then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
intros _.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intros _.

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) true) true then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
trivial.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
forall _ : eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) false, eq (if andb (andb (andb true true) true) false then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
intro Hsel'.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.

*****
Hsel' : eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel)\n false
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) true) false then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
rewrite forallb_forall_conv in Hsel'.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.

*****
Hsel' : ex\n (fun x : BC =>\n and (In x sel) (eq (aeq (arities x) (ok_arities b s)) false))
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) true) false then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
destruct Hsel' as [e' [H1 H2] ].
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].

*****
H2 : eq (aeq (arities e') (ok_arities b s)) false
H1 : In e' sel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) true) false then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
contradict H2.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].
contradict H2.

*****
H1 : In e' sel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (aeq (arities e') (ok_arities b s)) false)
+++++
rewrite <- forall_andl in Hsel.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hsel.

*****
H1 : In e' sel
e' : BC
Hsel : forall (x : BC) (_ : In x sel), eq (arities x) (ok_arities b s)
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (aeq (arities e') (ok_arities b s)) false)
+++++
rewrite Hsel.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hsel.
rewrite Hsel.

*****
H1 : In e' sel
e' : BC
Hsel : forall (x : BC) (_ : In x sel), eq (arities x) (ok_arities b s)
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (aeq (ok_arities b s) (ok_arities b s)) false)
+++++
simpl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hsel.
rewrite Hsel.
simpl.

*****
H1 : In e' sel
e' : BC
Hsel : forall (x : BC) (_ : In x sel), eq (arities x) (ok_arities b s)
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (andb (Nat.eqb b b) (Nat.eqb s s)) false)
+++++
do 2 rewrite <- beq_nat_refl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hsel.
rewrite Hsel.
simpl.
do 2 rewrite <- beq_nat_refl.

*****
H1 : In e' sel
e' : BC
Hsel : forall (x : BC) (_ : In x sel), eq (arities x) (ok_arities b s)
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (andb true true) false)
+++++
simpl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hsel.
rewrite Hsel.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.

*****
H1 : In e' sel
e' : BC
Hsel : forall (x : BC) (_ : In x sel), eq (arities x) (ok_arities b s)
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq true false)
+++++
congruence.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hsel.
rewrite Hsel.

*****
H1 : In e' sel
e' : BC
Hsel : forall (x : BC) (_ : In x sel), eq (arities x) (ok_arities b s)
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
In e' sel
+++++
simpl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intros _.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel).
intro Hsel'.
rewrite forallb_forall_conv in Hsel'.
destruct Hsel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hsel.
rewrite Hsel.
simpl.

*****
H1 : In e' sel
e' : BC
Hsel : forall (x : BC) (_ : In x sel), eq (arities x) (ok_arities b s)
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
In e' sel
+++++
trivial.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).

*****
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
forall _ : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b O)) nel) false, eq (if andb (andb (andb true true) false) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
intro Hnel'.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.

*****
Hnel' : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b O)) nel)\n false
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) false) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
rewrite forallb_forall_conv in Hnel'.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.

*****
Hnel' : ex\n (fun x : BC =>\n and (In x nel) (eq (aeq (arities x) (ok_arities b O)) false))
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) false) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
destruct Hnel' as [e' [H1 H2] ].
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.
destruct Hnel' as [e' [H1 H2] ].

*****
H2 : eq (aeq (arities e') (ok_arities b O)) false
H1 : In e' nel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
eq (if andb (andb (andb true true) false) (forallb (fun se : BC => aeq (arities se) (ok_arities b s)) sel) then ok_arities b s else error_comp (ok_arities (length nel) (length sel)) (map arities nel) (map arities sel)) (ok_arities b s)
+++++
contradict H2.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.
destruct Hnel' as [e' [H1 H2] ].
contradict H2.

*****
H1 : In e' nel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : andl (fun ne : BC => eq (arities ne) (ok_arities b O)) nel
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (aeq (arities e') (ok_arities b O)) false)
+++++
rewrite <- forall_andl in Hnel.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.
destruct Hnel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hnel.

*****
H1 : In e' nel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : forall (x : BC) (_ : In x nel), eq (arities x) (ok_arities b O)
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (aeq (arities e') (ok_arities b O)) false)
+++++
rewrite Hnel.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.
destruct Hnel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hnel.
rewrite Hnel.

*****
H1 : In e' nel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : forall (x : BC) (_ : In x nel), eq (arities x) (ok_arities b O)
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (aeq (ok_arities b O) (ok_arities b O)) false)
+++++
simpl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.
destruct Hnel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hnel.
rewrite Hnel.
simpl.

*****
H1 : In e' nel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : forall (x : BC) (_ : In x nel), eq (arities x) (ok_arities b O)
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (andb (Nat.eqb b b) true) false)
+++++
rewrite <- beq_nat_refl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.
destruct Hnel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hnel.
rewrite Hnel.
simpl.
rewrite <- beq_nat_refl.

*****
H1 : In e' nel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : forall (x : BC) (_ : In x nel), eq (arities x) (ok_arities b O)
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq (andb true true) false)
+++++
simpl.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.
destruct Hnel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hnel.
rewrite Hnel.
simpl.
rewrite <- beq_nat_refl.
simpl.

*****
H1 : In e' nel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : forall (x : BC) (_ : In x nel), eq (arities x) (ok_arities b O)
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
not (eq true false)
+++++
congruence.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).
intro Hnel'.
rewrite forallb_forall_conv in Hnel'.
destruct Hnel' as [e' [H1 H2] ].
contradict H2.
rewrite <- forall_andl in Hnel.
rewrite Hnel.

*****
H1 : In e' nel
e' : BC
Hsel : andl (fun se : BC => eq (arities se) (ok_arities b s)) sel
Hnel : forall (x : BC) (_ : In x nel), eq (arities x) (ok_arities b O)
He : eq (arities e) (ok_arities (length nel) (length sel))
nel,sel : list BC
e : BC
b,s : nat
*****
In e' nel
+++++
trivial.
-----
Lemma comp_arities : forall n s e nel sel, arities e = ok_arities (length nel) (length sel) -> andl (fun ne => arities ne = ok_arities n 0) nel -> andl (fun se => arities se = ok_arities n s) sel -> arities (comp n s e nel sel) = ok_arities n s.
Proof.
intros b s e nel sel He Hnel Hsel.
simpl.
rewrite He.
rewrite <- !beq_nat_refl.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities b 0)) nel).

*****

*****

+++++
Qed.
-----
Lemma arities_nth :\n  forall l i e n s,\n  (forall e, In e l -> arities e = ok_arities n s) ->\n  arities e = ok_arities n s ->\n  arities (nth i l e) = ok_arities n s.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.

*****

*****
forall (l : list BC) (i : nat) (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : In e0 l), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities (nth i l e)) (ok_arities n s)
+++++
Proof.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.

*****

*****
forall (l : list BC) (i : nat) (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : In e0 l), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities (nth i l e)) (ok_arities n s)
+++++
induction l as [ | e1 l IH].
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].

*****

*****
forall (i : nat) (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : In e0 nil), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities (nth i nil e)) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].
simpl.

*****

*****
forall (i : nat) (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : False), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities match i with | O | _ => e end) (ok_arities n s)
+++++
intros [ | i].
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].
simpl.
intros [ | i].

*****

*****
forall (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : False), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities e) (ok_arities n s)
+++++
trivial.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].
simpl.
intros [ | i].

*****
i : nat
*****
forall (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : False), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities e) (ok_arities n s)
+++++
trivial.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].

*****
IH : forall (i : nat) (e : BC) (n s : nat)\n (_ : forall (e0 : BC) (_ : In e0 l), eq (arities e0) (ok_arities n s))\n (_ : eq (arities e) (ok_arities n s)),\neq (arities (nth i l e)) (ok_arities n s)
l : list BC
e1 : BC
*****
forall (i : nat) (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : In e0 (cons e1 l)), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities (nth i (cons e1 l) e)) (ok_arities n s)
+++++
simpl.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].
simpl.

*****
IH : forall (i : nat) (e : BC) (n s : nat)\n (_ : forall (e0 : BC) (_ : In e0 l), eq (arities e0) (ok_arities n s))\n (_ : eq (arities e) (ok_arities n s)),\neq (arities (nth i l e)) (ok_arities n s)
l : list BC
e1 : BC
*****
forall (i : nat) (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : or (eq e1 e0) (In e0 l)), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities match i with | O => e1 | S m => nth m l e end) (ok_arities n s)
+++++
intros [ | i].
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].
simpl.
intros [ | i].

*****
IH : forall (i : nat) (e : BC) (n s : nat)\n (_ : forall (e0 : BC) (_ : In e0 l), eq (arities e0) (ok_arities n s))\n (_ : eq (arities e) (ok_arities n s)),\neq (arities (nth i l e)) (ok_arities n s)
l : list BC
e1 : BC
*****
forall (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : or (eq e1 e0) (In e0 l)), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities e1) (ok_arities n s)
+++++
trivial.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].
simpl.
intros [ | i].
trivial.

*****
IH : forall (i : nat) (e : BC) (n s : nat)\n (_ : forall (e0 : BC) (_ : In e0 l), eq (arities e0) (ok_arities n s))\n (_ : eq (arities e) (ok_arities n s)),\neq (arities (nth i l e)) (ok_arities n s)
l : list BC
e1 : BC
*****
forall (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : or (eq e1 e0) (In e0 l)), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities e1) (ok_arities n s)
+++++
auto.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].
simpl.
intros [ | i].

*****
i : nat
IH : forall (i : nat) (e : BC) (n s : nat)\n (_ : forall (e0 : BC) (_ : In e0 l), eq (arities e0) (ok_arities n s))\n (_ : eq (arities e) (ok_arities n s)),\neq (arities (nth i l e)) (ok_arities n s)
l : list BC
e1 : BC
*****
forall (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : or (eq e1 e0) (In e0 l)), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities (nth i l e)) (ok_arities n s)
+++++
trivial.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].
simpl.
intros [ | i].
trivial.

*****
i : nat
IH : forall (i : nat) (e : BC) (n s : nat)\n (_ : forall (e0 : BC) (_ : In e0 l), eq (arities e0) (ok_arities n s))\n (_ : eq (arities e) (ok_arities n s)),\neq (arities (nth i l e)) (ok_arities n s)
l : list BC
e1 : BC
*****
forall (e : BC) (n s : nat) (_ : forall (e0 : BC) (_ : or (eq e1 e0) (In e0 l)), eq (arities e0) (ok_arities n s)) (_ : eq (arities e) (ok_arities n s)), eq (arities (nth i l e)) (ok_arities n s)
+++++
auto.
-----
Lemma arities_nth : forall l i e n s, (forall e, In e l -> arities e = ok_arities n s) -> arities e = ok_arities n s -> arities (nth i l e) = ok_arities n s.
Proof.
induction l as [ | e1 l IH].

*****

*****

+++++
Qed.
-----
Lemma BC_ind_inf' :\n  forall (P : nat -> nat -> BC -> Prop),\n  forall Q : nat -> nat -> list BC -> Prop,\n  (forall n s, Q n s nil) ->\n  (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) ->\n  P 0 0 zero ->\n  (forall n s i, i < n + s ->  P n s (proj n s i)) ->\n  (forall b, P 0 1 (succ b)) ->\n  P 0 1 pred ->\n  P 0 4 cond ->\n  (forall n s g h0 h1, \n    arities g = ok_arities n s ->\n    arities h0 = ok_arities (S n) (S s) ->\n    arities h1 = ok_arities (S n) (S s) ->\n    P n s g -> \n    P (S n) (S s) h0 -> \n    P (S n) (S s) h1 -> \n    P (S n) s (rec g h0 h1)) ->\n  (forall n s h rl tl, \n    arities h = ok_arities (length rl) (length tl) ->\n    (forall e, In e rl -> arities e = ok_arities n 0) ->\n    (forall e, In e tl -> arities e = ok_arities n s) ->\n    P (length rl) (length tl) h -> \n    Q n 0 rl -> \n    Q n s tl ->\n    P n s (comp n s h rl tl)) ->\n  forall e n s , arities e = ok_arities n s -> P n s e.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.

*****

*****
forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop) (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop) (_ : forall n s : nat, Q n s nil) (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero) (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b)) (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond) (_ : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)) (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), P n s e
+++++
Proof.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.

*****

*****
forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop) (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop) (_ : forall n s : nat, Q n s nil) (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero) (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b)) (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond) (_ : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)) (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), P n s e
+++++
fix BC_ind_inf' 12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.

*****
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop) (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop) (_ : forall n s : nat, Q n s nil) (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero) (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b)) (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond) (_ : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)) (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), P n s e
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.

*****
H8 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s e
+++++
destruct e.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.

*****
H8 : eq (arities zero) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s zero
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.

*****
H8 : eq (ok_arities O O) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s zero
+++++
injection H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.

*****
H8 : eq (ok_arities O O) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (_ : eq O s) (_ : eq O n), P n s zero
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.
intros.

*****
H10 : eq O n
H9 : eq O s
H8 : eq (ok_arities O O) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s zero
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.
intros.
subst.

*****
H8 : eq (ok_arities O O) (ok_arities O O)
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O O zero
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.

*****
H8 : eq (arities (proj n0 n1 n2)) (ok_arities n s)
n0,n1,n2,n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.

*****
H8 : eq\n (if\n match Init.Nat.add n0 n1 with\n | O => false\n | S m' => Nat.leb n2 m'\n end\n then ok_arities n0 n1\n else error_proj n0 n1 n2) (ok_arities n s)
n0,n1,n2,n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
case_eq (n0 + n1).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).

*****
H8 : eq\n (if\n match Init.Nat.add n0 n1 with\n | O => false\n | S m' => Nat.leb n2 m'\n end\n then ok_arities n0 n1\n else error_proj n0 n1 n2) (ok_arities n s)
n0,n1,n2,n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Init.Nat.add n0 n1) O, P n s (proj n0 n1 n2)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.

*****
H9 : eq (Init.Nat.add n0 n1) O
H8 : eq\n (if\n match Init.Nat.add n0 n1 with\n | O => false\n | S m' => Nat.leb n2 m'\n end\n then ok_arities n0 n1\n else error_proj n0 n1 n2) (ok_arities n s)
n0,n1,n2,n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.

*****
H9 : eq (Init.Nat.add n0 n1) O
H8 : eq (error_proj n0 n1 n2) (ok_arities n s)
n0,n1,n2,n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).

*****
H8 : eq\n (if\n match Init.Nat.add n0 n1 with\n | O => false\n | S m' => Nat.leb n2 m'\n end\n then ok_arities n0 n1\n else error_proj n0 n1 n2) (ok_arities n s)
n0,n1,n2,n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n3 : nat) (_ : eq (Init.Nat.add n0 n1) (S n3)), P n s (proj n0 n1 n2)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.

*****
H9 : eq (Init.Nat.add n0 n1) (S n3)
n3 : nat
H8 : eq\n (if\n match Init.Nat.add n0 n1 with\n | O => false\n | S m' => Nat.leb n2 m'\n end\n then ok_arities n0 n1\n else error_proj n0 n1 n2) (ok_arities n s)
n0,n1,n2,n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.

*****
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (if Nat.leb n2 n3 then ok_arities n0 n1 else error_proj n0 n1 n2)\n (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.

*****
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (if Nat.leb n2 n3 then ok_arities n0 n1 else error_proj n0 n1 n2)\n (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
case_eq (leb n2 n3).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).

*****
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (if Nat.leb n2 n3 then ok_arities n0 n1 else error_proj n0 n1 n2)\n (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.leb n2 n3) true, P n s (proj n0 n1 n2)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.

*****
H10 : eq (Nat.leb n2 n3) true
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (if Nat.leb n2 n3 then ok_arities n0 n1 else error_proj n0 n1 n2)\n (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
rewrite H10 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.

*****
H10 : eq (Nat.leb n2 n3) true
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (ok_arities n0 n1) (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.
try discriminate.

*****
H10 : eq (Nat.leb n2 n3) true
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (ok_arities n0 n1) (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
injection H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.
try discriminate.
injection H8.

*****
H10 : eq (Nat.leb n2 n3) true
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (ok_arities n0 n1) (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (_ : eq n1 s) (_ : eq n0 n), P n s (proj n0 n1 n2)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.
try discriminate.
injection H8.
intros.

*****
H12 : eq n0 n
H11 : eq n1 s
H10 : eq (Nat.leb n2 n3) true
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (ok_arities n0 n1) (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.
try discriminate.
injection H8.
intros.
subst.

*****
H10 : eq (Nat.leb n2 n3) true
H9 : eq (Init.Nat.add n s) (S n3)
H8 : eq (ok_arities n s) (ok_arities n s)
n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n s n2)
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.
try discriminate.
injection H8.
intros.
subst.
auto.

*****
H10 : eq (Nat.leb n2 n3) true
H9 : eq (Init.Nat.add n s) (S n3)
H8 : eq (ok_arities n s) (ok_arities n s)
n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n s n2)
+++++
apply H2.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.
try discriminate.
injection H8.
intros.
subst.
auto.
apply H2.

*****
H10 : eq (Nat.leb n2 n3) true
H9 : eq (Init.Nat.add n s) (S n3)
H8 : eq (ok_arities n s) (ok_arities n s)
n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
lt n2 (Init.Nat.add n s)
+++++
apply leb_complete in H10.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.
try discriminate.
injection H8.
intros.
subst.
auto.
apply H2.
apply leb_complete in H10.

*****
H10 : le n2 n3
H9 : eq (Init.Nat.add n s) (S n3)
H8 : eq (ok_arities n s) (ok_arities n s)
n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
lt n2 (Init.Nat.add n s)
+++++
omega.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).

*****
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (if Nat.leb n2 n3 then ok_arities n0 n1 else error_proj n0 n1 n2)\n (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.leb n2 n3) false, P n s (proj n0 n1 n2)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.

*****
H10 : eq (Nat.leb n2 n3) false
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (if Nat.leb n2 n3 then ok_arities n0 n1 else error_proj n0 n1 n2)\n (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
rewrite H10 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (n0 + n1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (leb n2 n3).
intros.
rewrite H10 in H8.

*****
H10 : eq (Nat.leb n2 n3) false
H9 : eq (Init.Nat.add n0 n1) (S n3)
H8 : eq (error_proj n0 n1 n2) (ok_arities n s)
n0,n1,n2,n,s,n3 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (proj n0 n1 n2)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.

*****
H8 : eq (arities (succ b)) (ok_arities n s)
n,s : nat
b : bool
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (succ b)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.

*****
H8 : eq (ok_arities O (S O)) (ok_arities n s)
n,s : nat
b : bool
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (succ b)
+++++
injection H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.

*****
H8 : eq (ok_arities O (S O)) (ok_arities n s)
n,s : nat
b : bool
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (_ : eq (S O) s) (_ : eq O n), P n s (succ b)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.
intros.

*****
H10 : eq O n
H9 : eq (S O) s
H8 : eq (ok_arities O (S O)) (ok_arities n s)
n,s : nat
b : bool
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (succ b)
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.
intros.
subst.

*****
H8 : eq (ok_arities O (S O)) (ok_arities O (S O))
b : bool
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S O) (succ b)
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.

*****
H8 : eq (arities pred) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s pred
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.

*****
H8 : eq (ok_arities O (S O)) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s pred
+++++
injection H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.

*****
H8 : eq (ok_arities O (S O)) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (_ : eq (S O) s) (_ : eq O n), P n s pred
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.
intros.

*****
H10 : eq O n
H9 : eq (S O) s
H8 : eq (ok_arities O (S O)) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s pred
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.
intros.
subst.

*****
H8 : eq (ok_arities O (S O)) (ok_arities O (S O))
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S O) pred
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.

*****
H8 : eq (arities cond) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s cond
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.

*****
H8 : eq (ok_arities O (S (S (S (S O))))) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s cond
+++++
injection H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.

*****
H8 : eq (ok_arities O (S (S (S (S O))))) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (_ : eq (S (S (S (S O)))) s) (_ : eq O n), P n s cond
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.
intros.

*****
H10 : eq O n
H9 : eq (S (S (S (S O)))) s
H8 : eq (ok_arities O (S (S (S (S O))))) (ok_arities n s)
n,s : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s cond
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
injection H8.
intros.
subst.

*****
H8 : eq (ok_arities O (S (S (S (S O))))) (ok_arities O (S (S (S (S O)))))
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S (S (S (S O)))) cond
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.

*****
H8 : eq (arities (rec e1 e2 e3)) (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.

*****
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
case_eq (arities e1).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).

*****
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (a a0 a1 : Arities) (_ : eq (arities e1) (error_rec a a0 a1)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.

*****
H9 : eq (arities e1) (error_rec a a0 a1)
a,a0,a1 : Arities
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.

*****
H9 : eq (arities e1) (error_rec a a0 a1)
H8 : eq (error_rec (error_rec a a0 a1) (arities e2) (arities e3))\n (ok_arities n s)
a,a0,a1 : Arities
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).

*****
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (a : Arities) (l l0 : list Arities) (_ : eq (arities e1) (error_comp a l l0)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.

*****
H9 : eq (arities e1) (error_comp a l l0)
l,l0 : list Arities
a : Arities
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.

*****
H9 : eq (arities e1) (error_comp a l l0)
H8 : eq (error_rec (error_comp a l l0) (arities e2) (arities e3))\n (ok_arities n s)
l,l0 : list Arities
a : Arities
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).

*****
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n0 n1 n2 : nat) (_ : eq (arities e1) (error_proj n0 n1 n2)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.

*****
H9 : eq (arities e1) (error_proj n0 n1 n2)
n0,n1,n2 : nat
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.

*****
H9 : eq (arities e1) (error_proj n0 n1 n2)
H8 : eq (error_rec (error_proj n0 n1 n2) (arities e2) (arities e3))\n (ok_arities n s)
n,s,n0,n1,n2 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).

*****
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n0 n1 : nat) (_ : eq (arities e1) (ok_arities n0 n1)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.

*****
H9 : eq (arities e1) (ok_arities n0 n1)
n0,n1 : nat
H8 : eq\n match arities e1 with\n | error_rec a a0 a1 =>\n error_rec (error_rec a a0 a1) (arities e2) (arities e3)\n | error_comp a l l0 =>\n error_rec (error_comp a l l0) (arities e2) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (error_proj n n0 n1) (arities e2) (arities e3)\n | ok_arities gn gs =>\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (error_comp a l l0) (arities e3)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (error_proj n n0 n1)\n (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n0 n1 =>\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (error_proj n n0 n1)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb gn m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb gs m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n gs\n else\n error_rec (ok_arities gn gs) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end\n end (ok_arities n s)
n,s : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.

*****
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.

*****
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
case_eq (arities e2).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).

*****
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (a a0 a1 : Arities) (_ : eq (arities e2) (error_rec a a0 a1)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.

*****
H10 : eq (arities e2) (error_rec a a0 a1)
a,a0,a1 : Arities
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H10 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.

*****
H10 : eq (arities e2) (error_rec a a0 a1)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq (error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3))\n (ok_arities n s)
a,a0,a1 : Arities
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).

*****
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (a : Arities) (l l0 : list Arities) (_ : eq (arities e2) (error_comp a l l0)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.

*****
H10 : eq (arities e2) (error_comp a l l0)
l,l0 : list Arities
a : Arities
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H10 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.

*****
H10 : eq (arities e2) (error_comp a l l0)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq (error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3))\n (ok_arities n s)
l,l0 : list Arities
a : Arities
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).

*****
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n0 n1 n2 : nat) (_ : eq (arities e2) (error_proj n0 n1 n2)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.

*****
H10 : eq (arities e2) (error_proj n2 n3 n4)
n2,n3,n4 : nat
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H10 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.

*****
H10 : eq (arities e2) (error_proj n2 n3 n4)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq (error_rec (ok_arities n0 n1) (error_proj n2 n3 n4) (arities e3))\n (ok_arities n s)
n,s,n0,n1,n2,n3,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).

*****
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n0 n1 : nat) (_ : eq (arities e2) (ok_arities n0 n1)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.

*****
H10 : eq (arities e2) (ok_arities n2 n3)
n2,n3 : nat
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e2 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (error_rec a a0 a1) (arities e3)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (error_comp a l l0) (arities e3)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (error_proj n n2 n3) (arities e3)\n | ok_arities h0n h0s =>\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_comp a l l0)\n | error_proj n n2 n3 =>\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (error_proj n n2 n3)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match h0n with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb h0n h1n))\n match h0s with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb h0s h1s)\n then ok_arities h0n n1\n else\n error_rec (ok_arities n0 n1) (ok_arities h0n h0s)\n (ok_arities h1n h1s)\n end\n end (ok_arities n s)
n,s,n0,n1 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H10 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.

*****
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.

*****
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
case_eq (arities e3).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).

*****
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (a a0 a1 : Arities) (_ : eq (arities e3) (error_rec a a0 a1)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.

*****
H11 : eq (arities e3) (error_rec a a0 a1)
a,a0,a1 : Arities
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H11 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.

*****
H11 : eq (arities e3) (error_rec a a0 a1)
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (error_rec (ok_arities n0 n1) (ok_arities n2 n3) (error_rec a a0 a1))\n (ok_arities n s)
a,a0,a1 : Arities
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).

*****
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (a : Arities) (l l0 : list Arities) (_ : eq (arities e3) (error_comp a l l0)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.

*****
H11 : eq (arities e3) (error_comp a l l0)
l,l0 : list Arities
a : Arities
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H11 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.

*****
H11 : eq (arities e3) (error_comp a l l0)
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (error_rec (ok_arities n0 n1) (ok_arities n2 n3) (error_comp a l l0))\n (ok_arities n s)
l,l0 : list Arities
a : Arities
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).

*****
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n0 n1 n2 : nat) (_ : eq (arities e3) (error_proj n0 n1 n2)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.

*****
H11 : eq (arities e3) (error_proj n4 n5 n6)
n4,n5,n6 : nat
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H11 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.

*****
H11 : eq (arities e3) (error_proj n4 n5 n6)
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n4 n5 n6)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5,n6 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).

*****
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n0 n1 : nat) (_ : eq (arities e3) (ok_arities n0 n1)), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
n4,n5 : nat
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n match arities e3 with\n | error_rec a a0 a1 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_rec a a0 a1)\n | error_comp a l l0 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_comp a l l0)\n | error_proj n n4 n5 =>\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (error_proj n n4 n5)\n | ok_arities h1n h1s =>\n if\n andb\n (andb\n (andb\n match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 h1n))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 h1s)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3)\n (ok_arities h1n h1s)\n end (ok_arities n s)
n,s,n0,n1,n2,n3 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H11 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 n4))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3) (ok_arities n4 n5))\n (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities n2 n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb match n2 with\n | O => false\n | S m' => Nat.eqb n0 m'\n end (Nat.eqb n2 n4))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities n2 n1\n else\n error_rec (ok_arities n0 n1) (ok_arities n2 n3) (ok_arities n4 n5))\n (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
destruct n2.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities O n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb (andb false (Nat.eqb O n4))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities O n1\n else\n error_rec (ok_arities n0 n1) (ok_arities O n3) (ok_arities n4 n5))\n (ok_arities n s)
n,s,n0,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities O n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq (error_rec (ok_arities n0 n1) (ok_arities O n3) (ok_arities n4 n5))\n (ok_arities n s)
n,s,n0,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb (andb (Nat.eqb n0 n2) (Nat.eqb (S n2) n4))\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb (Nat.eqb n0 n2)\n match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end) match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb (Nat.eqb n0 n2)\n match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end) match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
case_eq (beq_nat n0 n2).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb (Nat.eqb n0 n2)\n match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end) match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n0 n2) true, P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.

*****
H12 : eq (Nat.eqb n0 n2) true
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb (Nat.eqb n0 n2)\n match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end) match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.

*****
H12 : eq (Nat.eqb n0 n2) true
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb true\n match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end) match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.

*****
H12 : eq (Nat.eqb n0 n2) true
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.

*****
H12 : eq (Nat.eqb n0 n2) true
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
apply beq_nat_true in H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.

*****
H12 : eq n0 n2
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
destruct n4.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.

*****
H11 : eq (arities e3) (ok_arities O n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb false\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities O n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.

*****
H11 : eq (arities e3) (ok_arities O n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities O n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb (Nat.eqb n2 n4)\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb (Nat.eqb n2 n4)\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb (Nat.eqb n2 n4)\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
case_eq (beq_nat n2 n4).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb (Nat.eqb n2 n4)\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n2 n4) true, P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.

*****
H12 : eq (Nat.eqb n2 n4) true
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb (Nat.eqb n2 n4)\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.

*****
H12 : eq (Nat.eqb n2 n4) true
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb true match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.

*****
H12 : eq (Nat.eqb n2 n4) true
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.

*****
H12 : eq (Nat.eqb n2 n4) true
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
apply beq_nat_true in H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.

*****
H12 : eq n2 n4
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if\n andb match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end (Nat.eqb n3 n5)\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) n3)
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
destruct n3.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if andb false (Nat.eqb O n5)\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) O)\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) O)
n,s,n1,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (error_rec (ok_arities n4 n1) (ok_arities (S n4) O)\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) O)
n,s,n1,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if andb (Nat.eqb n1 n3) (Nat.eqb (S n3) n5)\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if\n andb (Nat.eqb n1 n3)\n match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if\n andb (Nat.eqb n1 n3)\n match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
case_eq (beq_nat n1 n3).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if\n andb (Nat.eqb n1 n3)\n match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n1 n3) true, P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.

*****
H12 : eq (Nat.eqb n1 n3) true
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if\n andb (Nat.eqb n1 n3)\n match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.

*****
H12 : eq (Nat.eqb n1 n3) true
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if andb true match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.

*****
H12 : eq (Nat.eqb n1 n3) true
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.

*****
H12 : eq (Nat.eqb n1 n3) true
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
apply beq_nat_true in H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.

*****
H12 : eq n1 n3
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H8 : eq\n (if match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n3\n else\n error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
destruct n5.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.

*****
H11 : eq (arities e3) (ok_arities (S n4) O)
H8 : eq\n (error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) O)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.

*****
H11 : eq (arities e3) (ok_arities (S n4) O)
H8 : eq\n (error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) O)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.

*****
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (if Nat.eqb n3 n5\n then ok_arities (S n4) n3\n else\n error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.

*****
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (if Nat.eqb n3 n5\n then ok_arities (S n4) n3\n else\n error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.

*****
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (if Nat.eqb n3 n5\n then ok_arities (S n4) n3\n else\n error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
case_eq (beq_nat n3 n5).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).

*****
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (if Nat.eqb n3 n5\n then ok_arities (S n4) n3\n else\n error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n3 n5) true, P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.

*****
H12 : eq (Nat.eqb n3 n5) true
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (if Nat.eqb n3 n5\n then ok_arities (S n4) n3\n else\n error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.

*****
H12 : eq (Nat.eqb n3 n5) true
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq (ok_arities (S n4) n3) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.

*****
H12 : eq (Nat.eqb n3 n5) true
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq (ok_arities (S n4) n3) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.

*****
H12 : eq (Nat.eqb n3 n5) true
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq (ok_arities (S n4) n3) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
apply beq_nat_true in H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.

*****
H12 : eq n3 n5
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq (ok_arities (S n4) n3) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.

*****
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H10 : eq (arities e2) (ok_arities (S n4) (S n5))
H9 : eq (arities e1) (ok_arities n4 n5)
H8 : eq (ok_arities (S n4) n5) (ok_arities n s)
n,s,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
injection H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.

*****
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H10 : eq (arities e2) (ok_arities (S n4) (S n5))
H9 : eq (arities e1) (ok_arities n4 n5)
H8 : eq (ok_arities (S n4) n5) (ok_arities n s)
n,s,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (_ : eq n5 s) (_ : eq (S n4) n), P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.

*****
H13 : eq (S n4) n
H12 : eq n5 s
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H10 : eq (arities e2) (ok_arities (S n4) (S n5))
H9 : eq (arities e1) (ok_arities n4 n5)
H8 : eq (ok_arities (S n4) n5) (ok_arities n s)
n,s,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P (S n4) s (rec e1 e2 e3)
+++++
apply (@H6 n4 s).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e1) (ok_arities n4 s)
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e2) (ok_arities (S n4) (S s))
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e3) (ok_arities (S n4) (S s))
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n4 s e1
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n4 s e1
+++++
eapply BC_ind_inf'.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall n s0 : nat, ?Q n s0 nil
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O O zero
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall b : bool, P O (S O) (succ b)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S O) pred
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S (S (S (S O)))) cond
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e1) (ok_arities n4 s)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P (S n4) (S s) e2
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P (S n4) (S s) e2
+++++
eapply BC_ind_inf'.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall n s0 : nat, ?Q n s0 nil
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O O zero
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall b : bool, P O (S O) (succ b)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S O) pred
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S (S (S (S O)))) cond
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e2) (ok_arities (S n4) (S s))
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P (S n4) (S s) e3
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P (S n4) (S s) e3
+++++
eapply BC_ind_inf'.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall n s0 : nat, ?Q n s0 nil
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O O zero
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall b : bool, P O (S O) (succ b)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S O) pred
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S (S (S (S O)))) cond
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
injection H8.
intros.
subst.
apply (@H6 n4 s).
auto.
eapply BC_ind_inf'.

*****
H8 : eq (ok_arities (S n4) s) (ok_arities (S n4) s)
H9 : eq (arities e1) (ok_arities n4 s)
H10 : eq (arities e2) (ok_arities (S n4) (S s))
H11 : eq (arities e3) (ok_arities (S n4) (S s))
s,n4 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e3) (ok_arities (S n4) (S s))
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).

*****
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (if Nat.eqb n3 n5\n then ok_arities (S n4) n3\n else\n error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n3 n5) false, P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.

*****
H12 : eq (Nat.eqb n3 n5) false
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (if Nat.eqb n3 n5\n then ok_arities (S n4) n3\n else\n error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.

*****
H12 : eq (Nat.eqb n3 n5) false
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n5.
simpl in *.
try discriminate.
case_eq (beq_nat n3 n5).
intros.
rewrite H12 in H8.
simpl in *.

*****
H12 : eq (Nat.eqb n3 n5) false
H11 : eq (arities e3) (ok_arities (S n4) (S n5))
H8 : eq\n (error_rec (ok_arities n4 n3) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) (S n5))) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n4 n3)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if\n andb (Nat.eqb n1 n3)\n match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n1 n3) false, P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.

*****
H12 : eq (Nat.eqb n1 n3) false
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if\n andb (Nat.eqb n1 n3)\n match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.

*****
H12 : eq (Nat.eqb n1 n3) false
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (if andb false match n5 with\n | O => false\n | S m' => Nat.eqb n3 m'\n end\n then ok_arities (S n4) n1\n else\n error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n3.
simpl in *.
try discriminate.
case_eq (beq_nat n1 n3).
intros.
rewrite H12 in H8.
simpl in *.

*****
H12 : eq (Nat.eqb n1 n3) false
H11 : eq (arities e3) (ok_arities (S n4) n5)
H9 : eq (arities e1) (ok_arities n4 n1)
H8 : eq\n (error_rec (ok_arities n4 n1) (ok_arities (S n4) (S n3))\n (ok_arities (S n4) n5)) (ok_arities n s)
H10 : eq (arities e2) (ok_arities (S n4) (S n3))
n,s,n1,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).

*****
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb (Nat.eqb n2 n4)\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n2 n4) false, P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.

*****
H12 : eq (Nat.eqb n2 n4) false
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb (Nat.eqb n2 n4)\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.

*****
H12 : eq (Nat.eqb n2 n4) false
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (if\n andb\n (andb false\n match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.
try discriminate.
apply beq_nat_true in H12.
subst.
destruct n4.
simpl in *.
try discriminate.
case_eq (beq_nat n2 n4).
intros.
rewrite H12 in H8.
simpl in *.

*****
H12 : eq (Nat.eqb n2 n4) false
H11 : eq (arities e3) (ok_arities (S n4) n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H8 : eq\n (error_rec (ok_arities n2 n1) (ok_arities (S n2) n3)\n (ok_arities (S n4) n5)) (ok_arities n s)
H9 : eq (arities e1) (ok_arities n2 n1)
n,s,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).

*****
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb (Nat.eqb n0 n2)\n match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end) match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n0 n2) false, P n s (rec e1 e2 e3)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.

*****
H12 : eq (Nat.eqb n0 n2) false
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb (Nat.eqb n0 n2)\n match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end) match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.

*****
H12 : eq (Nat.eqb n0 n2) false
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (if\n andb\n (andb\n (andb false\n match n4 with\n | O => false\n | S m' => Nat.eqb n2 m'\n end) match n3 with\n | O => false\n | S m' => Nat.eqb n1 m'\n end) (Nat.eqb n3 n5)\n then ok_arities (S n2) n1\n else\n error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e1).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (arities e2).
intros.
rewrite H10 in H8.
try discriminate.
case_eq (arities e3).
intros.
rewrite H11 in H8.
try discriminate.
destruct n2.
simpl in *.
try discriminate.
case_eq (beq_nat n0 n2).
intros.
rewrite H12 in H8.
simpl in *.

*****
H12 : eq (Nat.eqb n0 n2) false
H11 : eq (arities e3) (ok_arities n4 n5)
H10 : eq (arities e2) (ok_arities (S n2) n3)
H9 : eq (arities e1) (ok_arities n0 n1)
H8 : eq\n (error_rec (ok_arities n0 n1) (ok_arities (S n2) n3)\n (ok_arities n4 n5)) (ok_arities n s)
n,s,n0,n1,n2,n3,n4,n5 : nat
e1,e2,e3 : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (rec e1 e2 e3)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.

*****
H8 : eq (arities (comp n0 n1 e l l0)) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
simpl in *.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.

*****
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
case_eq (arities e).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).

*****
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (a a0 a1 : Arities) (_ : eq (arities e) (error_rec a a0 a1)), P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.

*****
H9 : eq (arities e) (error_rec a a0 a1)
a,a0,a1 : Arities
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.

*****
H9 : eq (arities e) (error_rec a a0 a1)
H8 : eq (error_comp (error_rec a a0 a1) (map arities l) (map arities l0))\n (ok_arities n s)
a,a0,a1 : Arities
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).

*****
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (a : Arities) (l1 l2 : list Arities) (_ : eq (arities e) (error_comp a l1 l2)), P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.

*****
H9 : eq (arities e) (error_comp a l1 l2)
l1,l2 : list Arities
a : Arities
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.

*****
H9 : eq (arities e) (error_comp a l1 l2)
H8 : eq (error_comp (error_comp a l1 l2) (map arities l) (map arities l0))\n (ok_arities n s)
l1,l2 : list Arities
a : Arities
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).

*****
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n2 n3 n4 : nat) (_ : eq (arities e) (error_proj n2 n3 n4)), P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.

*****
H9 : eq (arities e) (error_proj n2 n3 n4)
n2,n3,n4 : nat
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.

*****
H9 : eq (arities e) (error_proj n2 n3 n4)
H8 : eq (error_comp (error_proj n2 n3 n4) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3,n4 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).

*****
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n2 n3 : nat) (_ : eq (arities e) (ok_arities n2 n3)), P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.

*****
H9 : eq (arities e) (ok_arities n2 n3)
n2,n3 : nat
H8 : eq\n match arities e with\n | error_rec a a0 a1 =>\n error_comp (error_rec a a0 a1) (map arities l) (map arities l0)\n | error_comp a l1 l2 =>\n error_comp (error_comp a l1 l2) (map arities l) (map arities l0)\n | error_proj n n0 n1 =>\n error_comp (error_proj n n0 n1) (map arities l) (map arities l0)\n | ok_arities hn hs =>\n if\n andb\n (andb (andb (Nat.eqb hn (length l)) (Nat.eqb hs (length l0)))\n (forallb\n (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1))\n l0)\n then ok_arities n0 n1\n else\n error_comp (ok_arities hn hs) (map arities l) (map arities l0)\n end (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H9 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.

*****
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb (Nat.eqb n2 (length l)) (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.

*****
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb (Nat.eqb n2 (length l)) (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
case_eq (beq_nat n2 (length l)).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).

*****
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb (Nat.eqb n2 (length l)) (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n2 (length l)) true, P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.

*****
H10 : eq (Nat.eqb n2 (length l)) true
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb (Nat.eqb n2 (length l)) (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H10 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.

*****
H10 : eq (Nat.eqb n2 (length l)) true
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.

*****
H10 : eq (Nat.eqb n2 (length l)) true
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
apply beq_nat_true in H10.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.

*****
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
case_eq (beq_nat n3 (length l0)).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).

*****
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n3 (length l0)) true, P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.

*****
H11 : eq (Nat.eqb n3 (length l0)) true
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H11 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.

*****
H11 : eq (Nat.eqb n3 (length l0)) true
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true true)\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.

*****
H11 : eq (Nat.eqb n3 (length l0)) true
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true true)\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
apply beq_nat_true in H11.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.

*****
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true true)\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).

*****
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true true)\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true, P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.

*****
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true true)\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.

*****
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb (andb (andb true true) true)\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.

*****
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb (andb (andb true true) true)\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).

*****
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb (andb (andb true true) true)\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0) true, P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.

*****
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n true
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb (andb (andb true true) true)\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H13 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.

*****
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n true
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if andb (andb (andb true true) true) true\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.

*****
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n true
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if andb (andb (andb true true) true) true\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
simpl in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.

*****
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n true
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq (ok_arities n0 n1) (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
injection H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.

*****
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n true
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq (ok_arities n0 n1) (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (_ : eq n1 s) (_ : eq n0 n), P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.

*****
H15 : eq n0 n
H14 : eq n1 s
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n true
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq (ok_arities n0 n1) (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
subst.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.

*****
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n O)) l) true
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) l0) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n s e l l0)
+++++
rewrite forallb_forall in H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) l0) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n s e l l0)
+++++
rewrite forallb_forall in H13.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n s e l l0)
+++++
apply H7.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e) (ok_arities (length l) (length l0))
+++++
trivial.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (_ : In e l), eq (arities e) (ok_arities n O)
+++++
trivial.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (_ : In e l), eq (arities e) (ok_arities n O)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
intros.

*****
H10 : In e0 l
e0 : BC
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e0) (ok_arities n O)
+++++
apply aeq_eq.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
intros.
apply aeq_eq.

*****
H10 : In e0 l
e0 : BC
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (aeq (arities e0) (ok_arities n O)) true
+++++
apply H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
intros.
apply aeq_eq.
apply H12.

*****
H10 : In e0 l
e0 : BC
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
In e0 l
+++++
trivial.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (_ : In e l0), eq (arities e) (ok_arities n s)
+++++
trivial.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (_ : In e l0), eq (arities e) (ok_arities n s)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
intros.

*****
H10 : In e0 l0
e0 : BC
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e0) (ok_arities n s)
+++++
apply aeq_eq.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
intros.
apply aeq_eq.

*****
H10 : In e0 l0
e0 : BC
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (aeq (arities e0) (ok_arities n s)) true
+++++
apply H13.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
intros.
apply aeq_eq.
apply H13.

*****
H10 : In e0 l0
e0 : BC
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
In e0 l0
+++++
trivial.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P (length l) (length l0) e
+++++
trivial.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P (length l) (length l0) e
+++++
eapply BC_ind_inf'.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall n0 s0 : nat, ?Q n0 s0 nil
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O O zero
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall b : bool, P O (S O) (succ b)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S O) pred
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S (S (S (S O)))) cond
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities e) (ok_arities (length l) (length l0))
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n O l
+++++
trivial.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n O l
+++++
clear H9.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n O l
+++++
revert l H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.

*****
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (l : list BC) (_ : forall (x : BC) (_ : In x l), eq (aeq (arities x) (ok_arities n O)) true), Q n O l
+++++
fix BC_ind_inf'0 1.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.

*****
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (l : list BC) (_ : forall (x : BC) (_ : In x l), eq (aeq (arities x) (ok_arities n O)) true), Q n O l
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n O l
+++++
destruct l.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.

*****
H12 : forall (x : BC) (_ : In x nil),\neq (aeq (arities x) (ok_arities n O)) true
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n O nil
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n O (cons b l)
+++++
eapply H0.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n O b
+++++
eapply BC_ind_inf'.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall n0 s0 : nat, ?Q n0 s0 nil
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O O zero
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall b : bool, P O (S O) (succ b)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S O) pred
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S (S (S (S O)))) cond
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities b) (ok_arities n O)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.
eauto.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities b) (ok_arities n O)
+++++
apply aeq_eq.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.
eauto.
apply aeq_eq.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (aeq (arities b) (ok_arities n O)) true
+++++
apply H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.
eauto.
apply aeq_eq.
apply H12.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
In b (cons b l)
+++++
simpl.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
eapply BC_ind_inf'.
eauto.
apply aeq_eq.
apply H12.
simpl.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
or (eq b b) (In b l)
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n O l
+++++
apply BC_ind_inf'0.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
apply BC_ind_inf'0.

*****
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (x : BC) (_ : In x l), eq (aeq (arities x) (ok_arities n O)) true
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
apply BC_ind_inf'0.
intros.

*****
H9 : In x l
x : BC
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (aeq (arities x) (ok_arities n O)) true
+++++
apply H12.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
apply BC_ind_inf'0.
intros.
apply H12.

*****
H9 : In x l
x : BC
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
In x (cons b l)
+++++
simpl.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l H12.
fix BC_ind_inf'0 1.
intros.
destruct l.
eapply H0.
apply BC_ind_inf'0.
intros.
apply H12.
simpl.

*****
H9 : In x l
x : BC
H12 : forall (x : BC) (_ : In x (cons b l)),\neq (aeq (arities x) (ok_arities n O)) true
l : list BC
b : BC
BC_ind_inf'0 : forall (l : list BC)\n (_ : forall (x : BC) (_ : In x l),\n eq (aeq (arities x) (ok_arities n O)) true), \nQ n O l
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
or (eq b x) (In x l)
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n s l0
+++++
trivial.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H9 : eq (arities e) (ok_arities (length l) (length l0))
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n s l0
+++++
clear H9.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l,l0 : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n s l0
+++++
revert l0 H13.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.

*****
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (l0 : list BC) (_ : forall (x : BC) (_ : In x l0), eq (aeq (arities x) (ok_arities n s)) true), Q n s l0
+++++
fix BC_ind_inf'0 1.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.

*****
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (l0 : list BC) (_ : forall (x : BC) (_ : In x l0), eq (aeq (arities x) (ok_arities n s)) true), Q n s l0
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.

*****
H13 : forall (x : BC) (_ : In x l0),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n s l0
+++++
destruct l0.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.

*****
H13 : forall (x : BC) (_ : In x nil),\neq (aeq (arities x) (ok_arities n s)) true
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n s nil
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n s (cons b l0)
+++++
eapply H0.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s b
+++++
eapply BC_ind_inf'.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall n0 s0 : nat, ?Q n0 s0 nil
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l), Q n s (cons e l)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O O zero
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall b : bool, P O (S O) (succ b)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S O) pred
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P O (S (S (S (S O)))) cond
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : Q n O rl) (_ : Q n s tl), P n s (comp n s h rl tl)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities b) (ok_arities n s)
+++++
eauto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.
eauto.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (arities b) (ok_arities n s)
+++++
apply aeq_eq.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.
eauto.
apply aeq_eq.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (aeq (arities b) (ok_arities n s)) true
+++++
apply H13.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.
eauto.
apply aeq_eq.
apply H13.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
In b (cons b l0)
+++++
simpl.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
eapply BC_ind_inf'.
eauto.
apply aeq_eq.
apply H13.
simpl.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
or (eq b b) (In b l0)
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
Q n s l0
+++++
apply BC_ind_inf'0.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
apply BC_ind_inf'0.

*****
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall (x : BC) (_ : In x l0), eq (aeq (arities x) (ok_arities n s)) true
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
apply BC_ind_inf'0.
intros.

*****
H9 : In x l0
x : BC
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
eq (aeq (arities x) (ok_arities n s)) true
+++++
apply H13.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
apply BC_ind_inf'0.
intros.
apply H13.

*****
H9 : In x l0
x : BC
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
In x (cons b l0)
+++++
simpl.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.
try discriminate.
simpl in H8.
injection H8.
intros.
subst.
rewrite forallb_forall in H12.
rewrite forallb_forall in H13.
apply H7.
trivial.
clear H9.
revert l0 H13.
fix BC_ind_inf'0 1.
intros.
destruct l0.
eapply H0.
apply BC_ind_inf'0.
intros.
apply H13.
simpl.

*****
H9 : In x l0
x : BC
H13 : forall (x : BC) (_ : In x (cons b l0)),\neq (aeq (arities x) (ok_arities n s)) true
l0 : list BC
b : BC
BC_ind_inf'0 : forall (l0 : list BC)\n (_ : forall (x : BC) (_ : In x l0),\n eq (aeq (arities x) (ok_arities n s)) true), \nQ n s l0
H12 : forall (x : BC) (_ : In x l),\neq (aeq (arities x) (ok_arities n O)) true
H8 : eq (ok_arities n s) (ok_arities n s)
n,s : nat
l : list BC
e : BC
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
or (eq b x) (In x l0)
+++++
auto.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).

*****
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb (andb (andb true true) true)\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0) false, P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.

*****
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n false
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb (andb (andb true true) true)\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H13 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.
try discriminate.
case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0).
intros.
rewrite H13 in H8.

*****
H13 : eq (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n false
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) true
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if andb (andb (andb true true) true) false\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).

*****
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true true)\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l) false, P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.

*****
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l)\n false
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true true)\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H12 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.
try discriminate.
apply beq_nat_true in H11.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 0)) l).
intros.
rewrite H12 in H8.

*****
H12 : eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l)\n false
H11 : eq n3 (length l0)
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb (andb (andb true true) false)\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).

*****
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n3 (length l0)) false, P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.

*****
H11 : eq (Nat.eqb n3 (length l0)) false
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H11 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.
try discriminate.
apply beq_nat_true in H10.
case_eq (beq_nat n3 (length l0)).
intros.
rewrite H11 in H8.

*****
H11 : eq (Nat.eqb n3 (length l0)) false
H10 : eq n2 (length l)
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb true false)\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).

*****
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb (Nat.eqb n2 (length l)) (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
forall _ : eq (Nat.eqb n2 (length l)) false, P n s (comp n0 n1 e l l0)
+++++
intros.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.

*****
H10 : eq (Nat.eqb n2 (length l)) false
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb (Nat.eqb n2 (length l)) (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
rewrite H10 in H8.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.
simpl in *.
case_eq (arities e).
intros.
rewrite H9 in H8.
try discriminate.
case_eq (beq_nat n2 (length l)).
intros.
rewrite H10 in H8.

*****
H10 : eq (Nat.eqb n2 (length l)) false
H9 : eq (arities e) (ok_arities n2 n3)
H8 : eq\n (if\n andb\n (andb (andb false (Nat.eqb n3 (length l0)))\n (forallb (fun ne : BC => aeq (arities ne) (ok_arities n0 O)) l))\n (forallb (fun se : BC => aeq (arities se) (ok_arities n0 n1)) l0)\n then ok_arities n0 n1\n else error_comp (ok_arities n2 n3) (map arities l) (map arities l0))\n (ok_arities n s)
n,s,n2,n3 : nat
l,l0 : list BC
e : BC
n0,n1 : nat
H7 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl) \n (_ : Q n s tl), P n s (comp n s h rl tl)
H6 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H5 : P O (S (S (S (S O)))) cond
H4 : P O (S O) pred
H3 : forall b : bool, P O (S O) (succ b)
H2 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H1 : P O O zero
H0 : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : Q n s l),\nQ n s (cons e l)
H : forall n s : nat, Q n s nil
Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
BC_ind_inf' : forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop)\n (Q : forall (_ : nat) (_ : nat) (_ : list BC), Prop)\n (_ : forall n s : nat, Q n s nil)\n (_ : forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e)\n (_ : Q n s l), Q n s (cons e l)) (_ : P O O zero)\n (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)),\n P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b))\n (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond)\n (_ : forall (n s : nat) (g h0 h1 : BC)\n (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) \n (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\n P (S n) s (rec g h0 h1))\n (_ : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl),\n eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl),\n eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h) (_ : Q n O rl)\n (_ : Q n s tl), P n s (comp n s h rl tl)) \n (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), \nP n s e
*****
P n s (comp n0 n1 e l l0)
+++++
try discriminate.
-----
Lemma BC_ind_inf' : forall (P : nat -> nat -> BC -> Prop), forall Q : nat -> nat -> list BC -> Prop, (forall n s, Q n s nil) -> (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) -> P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> Q n 0 rl -> Q n s tl -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
fix BC_ind_inf' 12.
intros.
destruct e.

*****

*****

+++++
Qed.
-----
Lemma BC_ind_inf :\n  forall (P : nat -> nat -> BC -> Prop),\n  P 0 0 zero ->\n  (forall n s i, i < n + s ->  P n s (proj n s i)) ->\n  (forall b, P 0 1 (succ b)) ->\n  P 0 1 pred ->\n  P 0 4 cond ->\n  (forall n s g h0 h1, \n    arities g = ok_arities n s ->\n    arities h0 = ok_arities (S n) (S s) ->\n    arities h1 = ok_arities (S n) (S s) ->\n    P n s g -> \n    P (S n) (S s) h0 -> \n    P (S n) (S s) h1 -> \n    P (S n) s (rec g h0 h1)) ->\n  (forall n s h rl tl, \n    arities h = ok_arities (length rl) (length tl) ->\n    (forall e, In e rl -> arities e = ok_arities n 0) ->\n    (forall e, In e tl -> arities e = ok_arities n s) ->\n    P (length rl) (length tl) h -> \n    (forall r, In r rl -> P n 0 r) ->\n    (forall r, In r tl -> P n s r) ->\n    P n s (comp n s h rl tl)) ->\n  forall e n s , arities e = ok_arities n s -> P n s e.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.

*****

*****
forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop) (_ : P O O zero) (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b)) (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond) (_ : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : forall (r : BC) (_ : In r rl), P n O r) (_ : forall (r : BC) (_ : In r tl), P n s r), P n s (comp n s h rl tl)) (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), P n s e
+++++
Proof.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.

*****

*****
forall (P : forall (_ : nat) (_ : nat) (_ : BC), Prop) (_ : P O O zero) (_ : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)) (_ : forall b : bool, P O (S O) (succ b)) (_ : P O (S O) pred) (_ : P O (S (S (S (S O)))) cond) (_ : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)) (_ : forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : forall (r : BC) (_ : In r rl), P n O r) (_ : forall (r : BC) (_ : In r tl), P n s r), P n s (comp n s h rl tl)) (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), P n s e
+++++
intros.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P n s e
+++++
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (n s : nat) (e : BC) (_ : In e nil), P n s e
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (n s : nat) (e : BC) (_ : In e nil), P n s e
+++++
simpl in *.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.
simpl in *.

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (n s : nat) (e : BC) (_ : False), P n s e
+++++
intros.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.
simpl in *.
intros.

*****
H7 : False
e0 : BC
n0,s0 : nat
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P n0 s0 e0
+++++
tauto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : forall (e0 : BC) (_ : In e0 l), P n s e0) (e0 : BC) (_ : In e0 (cons e l)), P n s e0
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : forall (e0 : BC) (_ : In e0 l), P n s e0) (e0 : BC) (_ : In e0 (cons e l)), P n s e0
+++++
simpl in *.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.
simpl in *.

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (e : BC) (n s : nat) (l : list BC) (_ : P n s e) (_ : forall (e0 : BC) (_ : In e0 l), P n s e0) (e0 : BC) (_ : or (eq e e0) (In e0 l)), P n s e0
+++++
intros.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.
simpl in *.
intros.

*****
H9 : or (eq e0 e1) (In e1 l)
e1 : BC
H8 : forall (e : BC) (_ : In e l), P n0 s0 e
H7 : P n0 s0 e0
l : list BC
n0,s0 : nat
e0 : BC
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P n0 s0 e1
+++++
destruct H9.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.
simpl in *.
intros.
destruct H9.

*****
H9 : eq e0 e1
e1 : BC
H8 : forall (e : BC) (_ : In e l), P n0 s0 e
H7 : P n0 s0 e0
l : list BC
n0,s0 : nat
e0 : BC
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P n0 s0 e1
+++++
subst.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.
simpl in *.
intros.
destruct H9.
subst.

*****
H8 : forall (e : BC) (_ : In e l), P n0 s0 e
H7 : P n0 s0 e1
e1 : BC
l : list BC
n0,s0 : nat
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P n0 s0 e1
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.
simpl in *.
intros.
destruct H9.

*****
H9 : In e1 l
e1 : BC
H8 : forall (e : BC) (_ : In e l), P n0 s0 e
H7 : P n0 s0 e0
l : list BC
n0,s0 : nat
e0 : BC
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P n0 s0 e1
+++++
subst.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).
auto.
simpl in *.
intros.
destruct H9.
subst.

*****
H9 : In e1 l
e1 : BC
H8 : forall (e : BC) (_ : In e l), P n0 s0 e
H7 : P n0 s0 e0
l : list BC
n0,s0 : nat
e0 : BC
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P n0 s0 e1
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P O O zero
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall b : bool, P O (S O) (succ b)
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P O (S O) pred
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
P O (S (S (S (S O)))) cond
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g) (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1), P (S n) s (rec g h0 h1)
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : P (length rl) (length tl) h) (_ : forall (e : BC) (_ : In e rl), P n O e) (_ : forall (e : BC) (_ : In e tl), P n s e), P n s (comp n s h rl tl)
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****
H6 : eq (arities e) (ok_arities n s)
n,s : nat
e : BC
H5 : forall (n s : nat) (h : BC) (rl tl : list BC)\n (_ : eq (arities h) (ok_arities (length rl) (length tl)))\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : P (length rl) (length tl) h)\n (_ : forall (r : BC) (_ : In r rl), P n O r)\n (_ : forall (r : BC) (_ : In r tl), P n s r),\nP n s (comp n s h rl tl)
H4 : forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s))\n (_ : eq (arities h0) (ok_arities (S n) (S s)))\n (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : P n s g)\n (_ : P (S n) (S s) h0) (_ : P (S n) (S s) h1),\nP (S n) s (rec g h0 h1)
H3 : P O (S (S (S (S O)))) cond
H2 : P O (S O) pred
H1 : forall b : bool, P O (S O) (succ b)
H0 : forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), P n s (proj n s i)
H : P O O zero
P : forall (_ : nat) (_ : nat) (_ : BC), Prop
*****
eq (arities e) (ok_arities n s)
+++++
auto.
-----
Lemma BC_ind_inf : forall (P : nat -> nat -> BC -> Prop), P 0 0 zero -> (forall n s i, i < n + s -> P n s (proj n s i)) -> (forall b, P 0 1 (succ b)) -> P 0 1 pred -> P 0 4 cond -> (forall n s g h0 h1, arities g = ok_arities n s -> arities h0 = ok_arities (S n) (S s) -> arities h1 = ok_arities (S n) (S s) -> P n s g -> P (S n) (S s) h0 -> P (S n) (S s) h1 -> P (S n) s (rec g h0 h1)) -> (forall n s h rl tl, arities h = ok_arities (length rl) (length tl) -> (forall e, In e rl -> arities e = ok_arities n 0) -> (forall e, In e tl -> arities e = ok_arities n s) -> P (length rl) (length tl) h -> (forall r, In r rl -> P n 0 r) -> (forall r, In r tl -> P n s r) -> P n s (comp n s h rl tl)) -> forall e n s , arities e = ok_arities n s -> P n s e.
Proof.
intros.
apply BC_ind_inf' with (Q := fun n s l => forall e , In e l -> P n s e).

*****

*****

+++++
Qed.
-----
Fixpoint sem_rec (sem_g sem_h0 sem_h1:list bs->list bs->bs)(v:bs)(vnl vsl:list bs) :=\n  match v with\n    | nil => sem_g vnl vsl\n    | b::v' =>\n      if b then sem_h1 (v'::vnl) (sem_rec sem_g sem_h0 sem_h1 v' vnl vsl :: vsl)\n      else sem_h0 (v'::vnl) (sem_rec sem_g sem_h0 sem_h1 v' vnl vsl :: vsl)\n  end.
-----
Fixpoint sem (e:BC)(vnl vsl:list bs) : bs :=\n  match e with\n  | zero => nil\n  | proj n s j => \n    if leb (S j) n then\n      nth j vnl nil\n      else nth (j-n) vsl nil\n  | succ b => b :: hd nil vsl\n  | pred => tail (hd nil vsl)\n  | cond =>\n      match vsl with\n      | a :: b :: c :: d :: _ => \n        match a with \n          | nil => b\n          | true :: _ => c\n          | false :: _ => d\n        end\n      | a :: b :: c :: _ => \n        match a with \n          | nil => b\n          | true :: _ => c\n          | false :: _ => nil\n        end\n      | a :: b :: _ => \n        match a with \n          | nil => b\n          | _ => nil\n        end\n      | _ => nil\n      end\n  | rec g h0 h1 => sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tail vnl) vsl\n  | comp _ _ h nl sl => \n    sem h (List.map (fun ne => sem ne vnl nil) nl) \n          (List.map (fun se => sem se vnl vsl) sl)\n  end.
-----
Lemma sem_comp :\n  forall n s f nel sel nl sl, \n  sem (comp n s f nel sel) nl sl =\n  sem f (map (fun ne => sem ne nl nil) nel) (map (fun se => sem se nl sl) sel).
-----
Lemma sem_comp : forall n s f nel sel nl sl, sem (comp n s f nel sel) nl sl = sem f (map (fun ne => sem ne nl nil) nel) (map (fun se => sem se nl sl) sel).

*****

*****
forall (n s : nat) (f : BC) (nel sel : list BC) (nl sl : list (list bool)), eq (sem (comp n s f nel sel) nl sl) (sem f (map (fun ne : BC => sem ne nl nil) nel) (map (fun se : BC => sem se nl sl) sel))
+++++
Proof.
-----
Lemma sem_comp : forall n s f nel sel nl sl, sem (comp n s f nel sel) nl sl = sem f (map (fun ne => sem ne nl nil) nel) (map (fun se => sem se nl sl) sel).
Proof.

*****

*****
forall (n s : nat) (f : BC) (nel sel : list BC) (nl sl : list (list bool)), eq (sem (comp n s f nel sel) nl sl) (sem f (map (fun ne : BC => sem ne nl nil) nel) (map (fun se : BC => sem se nl sl) sel))
+++++
trivial.
-----
Lemma sem_comp : forall n s f nel sel nl sl, sem (comp n s f nel sel) nl sl = sem f (map (fun ne => sem ne nl nil) nel) (map (fun se => sem se nl sl) sel).
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma cond_simpl_nil n s fn fc ff ft l1 l2 :\n  sem fc l1 l2 = nil ->\n  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.
-----
Lemma cond_simpl_nil n s fn fc ff ft l1 l2 : sem fc l1 l2 = nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.

*****
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (sem fc l1 l2) nil, eq (sem (comp n s cond nil (cons fc (cons fn (cons ft (cons ff nil))))) l1 l2) (sem fn l1 l2)
+++++
Proof.
-----
Lemma cond_simpl_nil n s fn fc ff ft l1 l2 : sem fc l1 l2 = nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.
Proof.

*****
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (sem fc l1 l2) nil, eq (sem (comp n s cond nil (cons fc (cons fn (cons ft (cons ff nil))))) l1 l2) (sem fn l1 l2)
+++++
simpl.
-----
Lemma cond_simpl_nil n s fn fc ff ft l1 l2 : sem fc l1 l2 = nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.
Proof.
simpl.

*****
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (sem fc l1 l2) nil, eq match sem fc l1 l2 with | nil => sem fn l1 l2 | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end (sem fn l1 l2)
+++++
intros.
-----
Lemma cond_simpl_nil n s fn fc ff ft l1 l2 : sem fc l1 l2 = nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.
Proof.
simpl.
intros.

*****
H : eq (sem fc l1 l2) nil
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq match sem fc l1 l2 with | nil => sem fn l1 l2 | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end (sem fn l1 l2)
+++++
rewrite H.
-----
Lemma cond_simpl_nil n s fn fc ff ft l1 l2 : sem fc l1 l2 = nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.
Proof.
simpl.
intros.
rewrite H.

*****
H : eq (sem fc l1 l2) nil
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem fn l1 l2) (sem fn l1 l2)
+++++
simpl.
-----
Lemma cond_simpl_nil n s fn fc ff ft l1 l2 : sem fc l1 l2 = nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.
Proof.
simpl.
intros.
rewrite H.
simpl.

*****
H : eq (sem fc l1 l2) nil
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem fn l1 l2) (sem fn l1 l2)
+++++
trivial.
-----
Lemma cond_simpl_nil n s fn fc ff ft l1 l2 : sem fc l1 l2 = nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.
Proof.
simpl.
intros.
rewrite H.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 :\n  sem fc l1 l2 <> nil ->\n  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = \n  match sem fc l1 l2 with\n    | nil => nil \n    | true :: _ => sem ft l1 l2 \n    | false :: _ => sem ff l1 l2\n  end.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.

*****
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
forall _ : not (eq (sem fc l1 l2) nil), eq (sem (comp n s cond nil (cons fc (cons fn (cons ft (cons ff nil))))) l1 l2) match sem fc l1 l2 with | nil => nil | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end
+++++
Proof.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.

*****
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
forall _ : not (eq (sem fc l1 l2) nil), eq (sem (comp n s cond nil (cons fc (cons fn (cons ft (cons ff nil))))) l1 l2) match sem fc l1 l2 with | nil => nil | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end
+++++
simpl.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.

*****
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
forall _ : not (eq (sem fc l1 l2) nil), eq match sem fc l1 l2 with | nil => sem fn l1 l2 | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end match sem fc l1 l2 with | nil => nil | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end
+++++
intros.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.
intros.

*****
H : not (eq (sem fc l1 l2) nil)
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
eq match sem fc l1 l2 with | nil => sem fn l1 l2 | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end match sem fc l1 l2 with | nil => nil | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end
+++++
destruct (sem fc l1 l2).
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).

*****
H : not (eq nil nil)
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
eq (sem fn l1 l2) nil
+++++
intros.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
intros.

*****
H : not (eq nil nil)
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
eq (sem fn l1 l2) nil
+++++
auto.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
intros.
auto.

*****
H : not (eq nil nil)
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
eq (sem fn l1 l2) nil
+++++
elim H.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
intros.
auto.
elim H.

*****
H : not (eq nil nil)
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).

*****
H : not (eq (cons b l) nil)
l : list bool
b : bool
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
eq (if b then sem ft l1 l2 else sem ff l1 l2) (if b then sem ft l1 l2 else sem ff l1 l2)
+++++
intros.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
intros.

*****
H : not (eq (cons b l) nil)
l : list bool
b : bool
l1,l2 : list (list bool)
fn,fc,ft,ff : BC
n,s : nat
*****
eq (if b then sem ft l1 l2 else sem ff l1 l2) (if b then sem ft l1 l2 else sem ff l1 l2)
+++++
auto.
-----
Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 : sem fc l1 l2 <> nil -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = match sem fc l1 l2 with | nil => nil | true :: _ => sem ft l1 l2 | false :: _ => sem ff l1 l2 end.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).

*****

*****

+++++
Qed.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 :\n  hd false (sem fc l1 l2) = true ->\n  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.

*****
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (hd false (sem fc l1 l2)) true, eq (sem (comp n s cond nil (cons fc (cons fn (cons ft (cons ff nil))))) l1 l2) (sem ft l1 l2)
+++++
Proof.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.

*****
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (hd false (sem fc l1 l2)) true, eq (sem (comp n s cond nil (cons fc (cons fn (cons ft (cons ff nil))))) l1 l2) (sem ft l1 l2)
+++++
simpl.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.

*****
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (hd false (sem fc l1 l2)) true, eq match sem fc l1 l2 with | nil => sem fn l1 l2 | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end (sem ft l1 l2)
+++++
intros.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.

*****
H : eq (hd false (sem fc l1 l2)) true
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq match sem fc l1 l2 with | nil => sem fn l1 l2 | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end (sem ft l1 l2)
+++++
destruct (sem fc l1 l2).
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).

*****
H : eq (hd false nil) true
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem fn l1 l2) (sem ft l1 l2)
+++++
simpl in H.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
simpl in H.

*****
H : eq false true
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem fn l1 l2) (sem ft l1 l2)
+++++
discriminate.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).

*****
H : eq (hd false (cons b l)) true
l : list bool
b : bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (if b then sem ft l1 l2 else sem ff l1 l2) (sem ft l1 l2)
+++++
destruct b.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
destruct b.

*****
H : eq (hd false (cons true l)) true
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem ft l1 l2) (sem ft l1 l2)
+++++
simpl in *.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
destruct b.
simpl in *.

*****
H : eq true true
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem ft l1 l2) (sem ft l1 l2)
+++++
trivial.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
destruct b.

*****
H : eq (hd false (cons false l)) true
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem ff l1 l2) (sem ft l1 l2)
+++++
simpl in *.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
destruct b.
simpl in *.

*****
H : eq false true
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem ff l1 l2) (sem ft l1 l2)
+++++
trivial.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).
destruct b.
simpl in *.
trivial.

*****
H : eq false true
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem ff l1 l2) (sem ft l1 l2)
+++++
discriminate.
-----
Lemma cond_simpl_true n s fn fc ff ft l1 l2 : hd false (sem fc l1 l2) = true -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.
Proof.
simpl.
intros.
destruct (sem fc l1 l2).

*****

*****

+++++
Qed.
-----
Lemma cond_simpl_false n s fn fc ff ft l1 l2 l :\n  sem fc l1 l2 = false :: l ->\n  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.
-----
Lemma cond_simpl_false n s fn fc ff ft l1 l2 l : sem fc l1 l2 = false :: l -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.

*****
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (sem fc l1 l2) (cons false l), eq (sem (comp n s cond nil (cons fc (cons fn (cons ft (cons ff nil))))) l1 l2) (sem ff l1 l2)
+++++
Proof.
-----
Lemma cond_simpl_false n s fn fc ff ft l1 l2 l : sem fc l1 l2 = false :: l -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.
Proof.

*****
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (sem fc l1 l2) (cons false l), eq (sem (comp n s cond nil (cons fc (cons fn (cons ft (cons ff nil))))) l1 l2) (sem ff l1 l2)
+++++
simpl.
-----
Lemma cond_simpl_false n s fn fc ff ft l1 l2 l : sem fc l1 l2 = false :: l -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.
Proof.
simpl.

*****
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
forall _ : eq (sem fc l1 l2) (cons false l), eq match sem fc l1 l2 with | nil => sem fn l1 l2 | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end (sem ff l1 l2)
+++++
intros.
-----
Lemma cond_simpl_false n s fn fc ff ft l1 l2 l : sem fc l1 l2 = false :: l -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.
Proof.
simpl.
intros.

*****
H : eq (sem fc l1 l2) (cons false l)
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq match sem fc l1 l2 with | nil => sem fn l1 l2 | cons true _ => sem ft l1 l2 | cons false _ => sem ff l1 l2 end (sem ff l1 l2)
+++++
rewrite H.
-----
Lemma cond_simpl_false n s fn fc ff ft l1 l2 l : sem fc l1 l2 = false :: l -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.
Proof.
simpl.
intros.
rewrite H.

*****
H : eq (sem fc l1 l2) (cons false l)
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem ff l1 l2) (sem ff l1 l2)
+++++
simpl.
-----
Lemma cond_simpl_false n s fn fc ff ft l1 l2 l : sem fc l1 l2 = false :: l -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.
Proof.
simpl.
intros.
rewrite H.
simpl.

*****
H : eq (sem fc l1 l2) (cons false l)
l : list bool
l1,l2 : list (list bool)
fn,fc,ff,ft : BC
n,s : nat
*****
eq (sem ff l1 l2) (sem ff l1 l2)
+++++
trivial.
-----
Lemma cond_simpl_false n s fn fc ff ft l1 l2 l : sem fc l1 l2 = false :: l -> sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.
Proof.
simpl.
intros.
rewrite H.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma sem_nth :\n  forall i start len f d vnl vsl,\n  0 <= i < len ->\n  sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.

*****

*****
forall (i start len : nat) (f : forall _ : nat, BC) (d : BC) (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)), eq (sem (nth i (map f (seq start len)) d) vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
Proof.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.

*****

*****
forall (i start len : nat) (f : forall _ : nat, BC) (d : BC) (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)), eq (sem (nth i (map f (seq start len)) d) vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
intros i start len.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.

*****
i,start,len : nat
*****
forall (f : forall _ : nat, BC) (d : BC) (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)), eq (sem (nth i (map f (seq start len)) d) vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
revert i start.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.

*****
len : nat
*****
forall (i start : nat) (f : forall _ : nat, BC) (d : BC) (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)), eq (sem (nth i (map f (seq start len)) d) vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
induction len as [ | len IH].
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].

*****

*****
forall (i start : nat) (f : forall _ : nat, BC) (d : BC) (vnl vsl : list (list bool)) (_ : and (le O i) (lt i O)), eq (sem (nth i (map f (seq start O)) d) vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
simpl.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.

*****

*****
forall (i start : nat) (f : forall _ : nat, BC) (d : BC) (vnl vsl : list (list bool)) (_ : and (le O i) (lt i O)), eq (sem match i with | O | _ => d end vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
intros.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.
intros.

*****
H : and (le O i) (lt i O)
vnl,vsl : list (list bool)
d : BC
f : forall _ : nat, BC
i,start : nat
*****
eq (sem match i with | O | _ => d end vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
contradict H.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.
intros.
contradict H.

*****
vnl,vsl : list (list bool)
d : BC
f : forall _ : nat, BC
i,start : nat
*****
not (and (le O i) (lt i O))
+++++
omega.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].

*****
IH : forall (i start : nat) (f : forall _ : nat, BC) (d : BC)\n (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)),\neq (sem (nth i (map f (seq start len)) d) vnl vsl)\n (sem (f (Init.Nat.add i start)) vnl vsl)
len : nat
*****
forall (i start : nat) (f : forall _ : nat, BC) (d : BC) (vnl vsl : list (list bool)) (_ : and (le O i) (lt i (S len))), eq (sem (nth i (map f (seq start (S len))) d) vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
simpl.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.

*****
IH : forall (i start : nat) (f : forall _ : nat, BC) (d : BC)\n (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)),\neq (sem (nth i (map f (seq start len)) d) vnl vsl)\n (sem (f (Init.Nat.add i start)) vnl vsl)
len : nat
*****
forall (i start : nat) (f : forall _ : nat, BC) (d : BC) (vnl vsl : list (list bool)) (_ : and (le O i) (lt i (S len))), eq (sem match i with | O => f start | S m => nth m (map f (seq (S start) len)) d end vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
intros.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.
intros.

*****
H : and (le O i) (lt i (S len))
vnl,vsl : list (list bool)
d : BC
f : forall _ : nat, BC
i,start : nat
IH : forall (i start : nat) (f : forall _ : nat, BC) (d : BC)\n (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)),\neq (sem (nth i (map f (seq start len)) d) vnl vsl)\n (sem (f (Init.Nat.add i start)) vnl vsl)
len : nat
*****
eq (sem match i with | O => f start | S m => nth m (map f (seq (S start) len)) d end vnl vsl) (sem (f (Init.Nat.add i start)) vnl vsl)
+++++
destruct i as [ | i].
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.
intros.
destruct i as [ | i].

*****
H : and (le O O) (lt O (S len))
vnl,vsl : list (list bool)
d : BC
f : forall _ : nat, BC
start : nat
IH : forall (i start : nat) (f : forall _ : nat, BC) (d : BC)\n (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)),\neq (sem (nth i (map f (seq start len)) d) vnl vsl)\n (sem (f (Init.Nat.add i start)) vnl vsl)
len : nat
*****
eq (sem (f start) vnl vsl) (sem (f (Init.Nat.add O start)) vnl vsl)
+++++
trivial.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.
intros.
destruct i as [ | i].

*****
H : and (le O (S i)) (lt (S i) (S len))
vnl,vsl : list (list bool)
d : BC
f : forall _ : nat, BC
i,start : nat
IH : forall (i start : nat) (f : forall _ : nat, BC) (d : BC)\n (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)),\neq (sem (nth i (map f (seq start len)) d) vnl vsl)\n (sem (f (Init.Nat.add i start)) vnl vsl)
len : nat
*****
eq (sem (nth i (map f (seq (S start) len)) d) vnl vsl) (sem (f (Init.Nat.add (S i) start)) vnl vsl)
+++++
rewrite IH.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.
intros.
destruct i as [ | i].
rewrite IH.

*****
H : and (le O (S i)) (lt (S i) (S len))
vnl,vsl : list (list bool)
d : BC
f : forall _ : nat, BC
i,start : nat
IH : forall (i start : nat) (f : forall _ : nat, BC) (d : BC)\n (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)),\neq (sem (nth i (map f (seq start len)) d) vnl vsl)\n (sem (f (Init.Nat.add i start)) vnl vsl)
len : nat
*****
eq (sem (f (Init.Nat.add i (S start))) vnl vsl) (sem (f (Init.Nat.add (S i) start)) vnl vsl)
+++++
do 2 f_equal.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.
intros.
destruct i as [ | i].
rewrite IH.
do 2 f_equal.

*****
H : and (le O (S i)) (lt (S i) (S len))
vnl,vsl : list (list bool)
d : BC
f : forall _ : nat, BC
i,start : nat
IH : forall (i start : nat) (f : forall _ : nat, BC) (d : BC)\n (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)),\neq (sem (nth i (map f (seq start len)) d) vnl vsl)\n (sem (f (Init.Nat.add i start)) vnl vsl)
len : nat
*****
eq (Init.Nat.add i (S start)) (Init.Nat.add (S i) start)
+++++
ring.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].
simpl.
intros.
destruct i as [ | i].
rewrite IH.

*****
H : and (le O (S i)) (lt (S i) (S len))
vnl,vsl : list (list bool)
d : BC
f : forall _ : nat, BC
i,start : nat
IH : forall (i start : nat) (f : forall _ : nat, BC) (d : BC)\n (vnl vsl : list (list bool)) (_ : and (le O i) (lt i len)),\neq (sem (nth i (map f (seq start len)) d) vnl vsl)\n (sem (f (Init.Nat.add i start)) vnl vsl)
len : nat
*****
and (le O i) (lt i len)
+++++
omega.
-----
Lemma sem_nth : forall i start len f d vnl vsl, 0 <= i < len -> sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.
Proof.
intros i start len.
revert i start.
induction len as [ | len IH].

*****

*****

+++++
Qed.
-----
Lemma map_sem_nth :\n  forall i f1 f2 vnl vsl d,\n  map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 ->\n  sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.

*****

*****
forall (i : nat) (f1 f2 : list BC) (vnl vsl : list (list bool)) (d : BC) (_ : eq (map (fun f : BC => sem f vnl vsl) f1) (map (fun f : BC => sem f vnl vsl) f2)), eq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
+++++
Proof.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.

*****

*****
forall (i : nat) (f1 f2 : list BC) (vnl vsl : list (list bool)) (d : BC) (_ : eq (map (fun f : BC => sem f vnl vsl) f1) (map (fun f : BC => sem f vnl vsl) f2)), eq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
+++++
induction i as [ | i IH].
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].

*****

*****
forall (f1 f2 : list BC) (vnl vsl : list (list bool)) (d : BC) (_ : eq (map (fun f : BC => sem f vnl vsl) f1) (map (fun f : BC => sem f vnl vsl) f2)), eq (sem (nth O f1 d) vnl vsl) (sem (nth O f2 d) vnl vsl)
+++++
simpl.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.

*****

*****
forall (f1 f2 : list BC) (vnl vsl : list (list bool)) (d : BC) (_ : eq (map (fun f : BC => sem f vnl vsl) f1) (map (fun f : BC => sem f vnl vsl) f2)), eq (sem (nth O f1 d) vnl vsl) (sem (nth O f2 d) vnl vsl)
+++++
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.

*****
H : eq (map (fun f : BC => sem f vnl vsl) nil)\n (map (fun f : BC => sem f vnl vsl) nil)
d : BC
vnl,vsl : list (list bool)
*****
eq (sem (nth O nil d) vnl vsl) (sem (nth O nil d) vnl vsl)
+++++
simpl in *.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.

*****
H : eq nil nil
d : BC
vnl,vsl : list (list bool)
*****
eq (sem d vnl vsl) (sem d vnl vsl)
+++++
trivial.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.

*****
H : eq (map (fun f : BC => sem f vnl vsl) nil)\n (map (fun f : BC => sem f vnl vsl) (cons e2 f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
*****
eq (sem (nth O nil d) vnl vsl) (sem (nth O (cons e2 f2) d) vnl vsl)
+++++
simpl in *.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.

*****
H : eq nil (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
*****
eq (sem d vnl vsl) (sem e2 vnl vsl)
+++++
trivial.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.
trivial.

*****
H : eq nil (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
*****
eq (sem d vnl vsl) (sem e2 vnl vsl)
+++++
try congruence.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.

*****
H : eq (map (fun f : BC => sem f vnl vsl) (cons e1 f1))\n (map (fun f : BC => sem f vnl vsl) nil)
d : BC
vnl,vsl : list (list bool)
f1 : list BC
e1 : BC
*****
eq (sem (nth O (cons e1 f1) d) vnl vsl) (sem (nth O nil d) vnl vsl)
+++++
simpl in *.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1)) nil
d : BC
vnl,vsl : list (list bool)
f1 : list BC
e1 : BC
*****
eq (sem e1 vnl vsl) (sem d vnl vsl)
+++++
trivial.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.
trivial.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1)) nil
d : BC
vnl,vsl : list (list bool)
f1 : list BC
e1 : BC
*****
eq (sem e1 vnl vsl) (sem d vnl vsl)
+++++
try congruence.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.

*****
H : eq (map (fun f : BC => sem f vnl vsl) (cons e1 f1))\n (map (fun f : BC => sem f vnl vsl) (cons e2 f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
f1 : list BC
e1 : BC
*****
eq (sem (nth O (cons e1 f1) d) vnl vsl) (sem (nth O (cons e2 f2) d) vnl vsl)
+++++
simpl in *.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1))\n (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
f1 : list BC
e1 : BC
*****
eq (sem e1 vnl vsl) (sem e2 vnl vsl)
+++++
trivial.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.
trivial.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1))\n (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
f1 : list BC
e1 : BC
*****
eq (sem e1 vnl vsl) (sem e2 vnl vsl)
+++++
try congruence.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].

*****
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
forall (f1 f2 : list BC) (vnl vsl : list (list bool)) (d : BC) (_ : eq (map (fun f : BC => sem f vnl vsl) f1) (map (fun f : BC => sem f vnl vsl) f2)), eq (sem (nth (S i) f1 d) vnl vsl) (sem (nth (S i) f2 d) vnl vsl)
+++++
simpl.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.

*****
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
forall (f1 f2 : list BC) (vnl vsl : list (list bool)) (d : BC) (_ : eq (map (fun f : BC => sem f vnl vsl) f1) (map (fun f : BC => sem f vnl vsl) f2)), eq (sem (nth (S i) f1 d) vnl vsl) (sem (nth (S i) f2 d) vnl vsl)
+++++
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.

*****
H : eq (map (fun f : BC => sem f vnl vsl) nil)\n (map (fun f : BC => sem f vnl vsl) nil)
d : BC
vnl,vsl : list (list bool)
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth (S i) nil d) vnl vsl) (sem (nth (S i) nil d) vnl vsl)
+++++
simpl in *.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.

*****
H : eq nil nil
d : BC
vnl,vsl : list (list bool)
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem d vnl vsl) (sem d vnl vsl)
+++++
trivial.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.

*****
H : eq (map (fun f : BC => sem f vnl vsl) nil)\n (map (fun f : BC => sem f vnl vsl) (cons e2 f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth (S i) nil d) vnl vsl) (sem (nth (S i) (cons e2 f2) d) vnl vsl)
+++++
simpl in *.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.

*****
H : eq nil (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem d vnl vsl) (sem (nth i f2 d) vnl vsl)
+++++
trivial.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.
trivial.

*****
H : eq nil (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem d vnl vsl) (sem (nth i f2 d) vnl vsl)
+++++
try congruence.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.

*****
H : eq (map (fun f : BC => sem f vnl vsl) (cons e1 f1))\n (map (fun f : BC => sem f vnl vsl) nil)
d : BC
vnl,vsl : list (list bool)
f1 : list BC
e1 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth (S i) (cons e1 f1) d) vnl vsl) (sem (nth (S i) nil d) vnl vsl)
+++++
simpl in *.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1)) nil
d : BC
vnl,vsl : list (list bool)
f1 : list BC
e1 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth i f1 d) vnl vsl) (sem d vnl vsl)
+++++
trivial.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.
trivial.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1)) nil
d : BC
vnl,vsl : list (list bool)
f1 : list BC
e1 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth i f1 d) vnl vsl) (sem d vnl vsl)
+++++
try congruence.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.

*****
H : eq (map (fun f : BC => sem f vnl vsl) (cons e1 f1))\n (map (fun f : BC => sem f vnl vsl) (cons e2 f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
f1 : list BC
e1 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth (S i) (cons e1 f1) d) vnl vsl) (sem (nth (S i) (cons e2 f2) d) vnl vsl)
+++++
simpl in *.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1))\n (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
f1 : list BC
e1 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
+++++
trivial.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.
trivial.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1))\n (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
f1 : list BC
e1 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
+++++
try congruence.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.
trivial.
try congruence.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1))\n (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
f1 : list BC
e1 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
+++++
apply IH.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].
simpl.
intros [ | e1 f1] [ | e2 f2] vnl vsl d H.
simpl in *.
trivial.
try congruence.
apply IH.

*****
H : eq (cons (sem e1 vnl vsl) (map (fun f : BC => sem f vnl vsl) f1))\n (cons (sem e2 vnl vsl) (map (fun f : BC => sem f vnl vsl) f2))
d : BC
vnl,vsl : list (list bool)
f2 : list BC
e2 : BC
f1 : list BC
e1 : BC
IH : forall (f1 f2 : list BC) (vnl vsl : list (list bool)) \n (d : BC)\n (_ : eq (map (fun f : BC => sem f vnl vsl) f1)\n (map (fun f : BC => sem f vnl vsl) f2)),\neq (sem (nth i f1 d) vnl vsl) (sem (nth i f2 d) vnl vsl)
i : nat
*****
eq (map (fun f : BC => sem f vnl vsl) f1) (map (fun f : BC => sem f vnl vsl) f2)
+++++
congruence.
-----
Lemma map_sem_nth : forall i f1 f2 vnl vsl d, map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 -> sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.
Proof.
induction i as [ | i IH].

*****

*****

+++++
Qed.
-----
Lemma sem_proj_S_normal :\n  forall n s i f vsl vnl,\n  i < n ->\n  sem (proj (S n) s (S i)) (f::vnl) vsl =\n  sem (proj n s i) vnl vsl.
-----
Lemma sem_proj_S_normal : forall n s i f vsl vnl, i < n -> sem (proj (S n) s (S i)) (f::vnl) vsl = sem (proj n s i) vnl vsl.

*****

*****
forall (n s i : nat) (f : list bool) (vsl vnl : list (list bool)) (_ : lt i n), eq (sem (proj (S n) s (S i)) (cons f vnl) vsl) (sem (proj n s i) vnl vsl)
+++++
Proof.
-----
Lemma sem_proj_S_normal : forall n s i f vsl vnl, i < n -> sem (proj (S n) s (S i)) (f::vnl) vsl = sem (proj n s i) vnl vsl.
Proof.

*****

*****
forall (n s i : nat) (f : list bool) (vsl vnl : list (list bool)) (_ : lt i n), eq (sem (proj (S n) s (S i)) (cons f vnl) vsl) (sem (proj n s i) vnl vsl)
+++++
trivial.
-----
Lemma sem_proj_S_normal : forall n s i f vsl vnl, i < n -> sem (proj (S n) s (S i)) (f::vnl) vsl = sem (proj n s i) vnl vsl.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma sem_proj_S_safe :\n  forall n s i f vsl vnl,\n  n <= i ->\n  sem (proj n (S s) (S i)) vnl (f::vsl) =\n  sem (proj n s i) vnl vsl.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.

*****

*****
forall (n s i : nat) (f : list bool) (vsl vnl : list (list bool)) (_ : le n i), eq (sem (proj n (S s) (S i)) vnl (cons f vsl)) (sem (proj n s i) vnl vsl)
+++++
Proof.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.

*****

*****
forall (n s i : nat) (f : list bool) (vsl vnl : list (list bool)) (_ : le n i), eq (sem (proj n (S s) (S i)) vnl (cons f vsl)) (sem (proj n s i) vnl vsl)
+++++
intros.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.

*****
H : le n i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq (sem (proj n (S s) (S i)) vnl (cons f vsl)) (sem (proj n s i) vnl vsl)
+++++
simpl.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.

*****
H : le n i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq (if match n with | S (S m'0) => Nat.leb i m'0 | _ => false end then nth (S i) vnl nil else match match n with | O => S i | S l => Init.Nat.sub i l end with | O => f | S m => nth m vsl nil end) (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil)
+++++
destruct n as [ | n].
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].

*****
H : le O i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
eq (nth i vsl nil) (nth (Init.Nat.sub i O) vsl nil)
+++++
f_equal.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
f_equal.

*****
H : le O i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
eq i (Init.Nat.sub i O)
+++++
omega.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].

*****
H : le (S n) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq (if match n with | O => false | S m' => Nat.leb i m' end then nth (S i) vnl nil else match Init.Nat.sub i n with | O => f | S m => nth m vsl nil end) (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil)
+++++
destruct n as [ | n].
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].

*****
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
eq match Init.Nat.sub i O with | O => f | S m => nth m vsl nil end (if Nat.leb i O then nth i vnl nil else nth (Init.Nat.sub i (S O)) vsl nil)
+++++
cutrewrite (i-0 = S (i-1)).
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
cutrewrite (i-0 = S (i-1)).

*****
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
eq (nth (Init.Nat.sub i (S O)) vsl nil) (if Nat.leb i O then nth i vnl nil else nth (Init.Nat.sub i (S O)) vsl nil)
+++++
case_eq (leb i 0).
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
cutrewrite (i-0 = S (i-1)).
case_eq (leb i 0).

*****
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
forall _ : eq (Nat.leb i O) true, eq (nth (Init.Nat.sub i (S O)) vsl nil) (nth i vnl nil)
+++++
intro Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
cutrewrite (i-0 = S (i-1)).
case_eq (leb i 0).
intro Hi.

*****
Hi : eq (Nat.leb i O) true
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
eq (nth (Init.Nat.sub i (S O)) vsl nil) (nth i vnl nil)
+++++
apply leb_complete in Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
cutrewrite (i-0 = S (i-1)).
case_eq (leb i 0).
intro Hi.
apply leb_complete in Hi.

*****
Hi : le i O
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
eq (nth (Init.Nat.sub i (S O)) vsl nil) (nth i vnl nil)
+++++
contradict Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
cutrewrite (i-0 = S (i-1)).
case_eq (leb i 0).
intro Hi.
apply leb_complete in Hi.
contradict Hi.

*****
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
not (le i O)
+++++
omega.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
cutrewrite (i-0 = S (i-1)).
case_eq (leb i 0).

*****
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
forall _ : eq (Nat.leb i O) false, eq (nth (Init.Nat.sub i (S O)) vsl nil) (nth (Init.Nat.sub i (S O)) vsl nil)
+++++
intro Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
cutrewrite (i-0 = S (i-1)).
case_eq (leb i 0).
intro Hi.

*****
Hi : eq (Nat.leb i O) false
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
eq (nth (Init.Nat.sub i (S O)) vsl nil) (nth (Init.Nat.sub i (S O)) vsl nil)
+++++
trivial.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
cutrewrite (i-0 = S (i-1)).

*****
H : le (S O) i
vsl,vnl : list (list bool)
f : list bool
s,i : nat
*****
eq (Init.Nat.sub i O) (S (Init.Nat.sub i (S O)))
+++++
omega.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq (if Nat.leb i n then nth (S i) vnl nil else match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end) (if Nat.leb i (S n) then nth i vnl nil else nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
case_eq (leb i n).
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) true, eq (nth (S i) vnl nil) (if Nat.leb i (S n) then nth i vnl nil else nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
intro Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.

*****
Hi : eq (Nat.leb i n) true
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq (nth (S i) vnl nil) (if Nat.leb i (S n) then nth i vnl nil else nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
apply leb_complete in Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
apply leb_complete in Hi.

*****
Hi : le i n
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq (nth (S i) vnl nil) (if Nat.leb i (S n) then nth i vnl nil else nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
contradict Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
apply leb_complete in Hi.
contradict Hi.

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
not (le i n)
+++++
omega.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) false, eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (if Nat.leb i (S n) then nth i vnl nil else nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
intro Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.

*****
Hi : eq (Nat.leb i n) false
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (if Nat.leb i (S n) then nth i vnl nil else nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
clear Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (if Nat.leb i (S n) then nth i vnl nil else nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
case_eq (leb i (S n)).
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
forall _ : eq (Nat.leb i (S n)) true, eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (nth i vnl nil)
+++++
intro Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.

*****
Hi : eq (Nat.leb i (S n)) true
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (nth i vnl nil)
+++++
apply leb_complete in Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
apply leb_complete in Hi.

*****
Hi : le i (S n)
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (nth i vnl nil)
+++++
contradict Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
apply leb_complete in Hi.
contradict Hi.

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
not (le i (S n))
+++++
omega.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
forall _ : eq (Nat.leb i (S n)) false, eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
intro Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.

*****
Hi : eq (Nat.leb i (S n)) false
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
clear Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
clear Hi.

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq match Init.Nat.sub i (S n) with | O => f | S m => nth m vsl nil end (nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
case_eq (i - S n).
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
clear Hi.
case_eq (i - S n).

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
forall _ : eq (Init.Nat.sub i (S n)) O, eq f (nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
intro Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
clear Hi.
case_eq (i - S n).
intro Hi.

*****
Hi : eq (Init.Nat.sub i (S n)) O
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq f (nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
contradict Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
clear Hi.
case_eq (i - S n).
intro Hi.
contradict Hi.

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
not (eq (Init.Nat.sub i (S n)) O)
+++++
omega.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
clear Hi.
case_eq (i - S n).

*****
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.sub i (S n)) (S n0)), eq (nth n0 vsl nil) (nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
intros j Hi.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
clear Hi.
case_eq (i - S n).
intros j Hi.

*****
Hi : eq (Init.Nat.sub i (S n)) (S j)
j : nat
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq (nth j vsl nil) (nth (Init.Nat.sub i (S (S n))) vsl nil)
+++++
f_equal.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].
destruct n as [ | n].
case_eq (leb i n).
intro Hi.
clear Hi.
case_eq (leb i (S n)).
intro Hi.
clear Hi.
case_eq (i - S n).
intros j Hi.
f_equal.

*****
Hi : eq (Init.Nat.sub i (S n)) (S j)
j : nat
H : le (S (S n)) i
vsl,vnl : list (list bool)
f : list bool
n,s,i : nat
*****
eq j (Init.Nat.sub i (S (S n)))
+++++
omega.
-----
Lemma sem_proj_S_safe : forall n s i f vsl vnl, n <= i -> sem (proj n (S s) (S i)) vnl (f::vsl) = sem (proj n s i) vnl vsl.
Proof.
intros.
simpl.
destruct n as [ | n].

*****

*****

+++++
Qed.
-----
Lemma sem_firstn_safe :\n  forall f n s vnl vsl,\n  arities f = ok_arities n s ->\n  sem f vnl vsl = sem f vnl (firstn s vsl).
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).

*****

*****
forall (f : BC) (n s : nat) (vnl vsl : list (list bool)) (_ : eq (arities f) (ok_arities n s)), eq (sem f vnl vsl) (sem f vnl (firstn s vsl))
+++++
Proof.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.

*****

*****
forall (f : BC) (n s : nat) (vnl vsl : list (list bool)) (_ : eq (arities f) (ok_arities n s)), eq (sem f vnl vsl) (sem f vnl (firstn s vsl))
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.

*****
H : eq (arities f) (ok_arities n s)
vnl,vsl : list (list bool)
n,s : nat
f : BC
*****
eq (sem f vnl vsl) (sem f vnl (firstn s vsl))
+++++
revert f n s H vnl vsl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.

*****

*****
forall (f : BC) (n s : nat) (_ : eq (arities f) (ok_arities n s)) (vnl vsl : list (list bool)), eq (sem f vnl vsl) (sem f vnl (firstn s vsl))
+++++
refine (BC_ind_inf _ _ _ _ _ _ _ _).
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (sem zero vnl vsl) (sem zero vnl (firstn O vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (_ : list (list bool)), eq nil nil
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)) (vnl vsl : list (list bool)), eq (sem (proj n s i) vnl vsl) (sem (proj n s i) vnl (firstn s vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)) (vnl vsl : list (list bool)), eq (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil) (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) (firstn s vsl) nil)
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil) (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) (firstn s vsl) nil)
+++++
destruct n as [ | n].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add O s)
s,i : nat
*****
eq (nth (Init.Nat.sub i O) vsl nil) (nth (Init.Nat.sub i O) (firstn s vsl) nil)
+++++
simpl in *.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth (Init.Nat.sub i O) vsl nil) (nth (Init.Nat.sub i O) (firstn s vsl) nil)
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth (Init.Nat.sub i O) vsl nil) (nth (Init.Nat.sub i O) (firstn s vsl) nil)
+++++
rewrite <- minus_n_O.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
rewrite <- minus_n_O.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth i vsl nil) (nth i (firstn s vsl) nil)
+++++
rewrite nth_firstn.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
rewrite <- minus_n_O.
rewrite nth_firstn.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth i vsl nil) (nth i vsl nil)
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
rewrite <- minus_n_O.
rewrite nth_firstn.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
lt i s
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil) (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) (firstn s vsl) nil)
+++++
simpl in *.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil) (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) (firstn s vsl) nil)
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil) (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) (firstn s vsl) nil)
+++++
case_eq (leb i n).
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) true, eq (nth i vnl nil) (nth i vnl nil)
+++++
intro H0.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.

*****
H0 : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i vnl nil)
+++++
destruct vnl as [ | v vnl].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].

*****
H0 : eq (Nat.leb i n) true
vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i nil nil) (nth i nil nil)
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].

*****
H0 : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
v : list bool
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i (cons v vnl) nil) (nth i (cons v vnl) nil)
+++++
destruct i as [ | i].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].

*****
H0 : eq (Nat.leb O n) true
vnl,vsl : list (list bool)
v : list bool
H : lt O (S (Init.Nat.add n s))
n,s : nat
*****
eq (nth O (cons v vnl) nil) (nth O (cons v vnl) nil)
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].

*****
H0 : eq (Nat.leb (S i) n) true
vnl,vsl : list (list bool)
v : list bool
H : lt (S i) (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (S i) (cons v vnl) nil) (nth (S i) (cons v vnl) nil)
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].
simpl.

*****
H0 : eq (Nat.leb (S i) n) true
vnl,vsl : list (list bool)
v : list bool
H : lt (S i) (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i vnl nil)
+++++
apply leb_complete in H0.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].
simpl.
apply leb_complete in H0.

*****
H0 : le (S i) n
vnl,vsl : list (list bool)
v : list bool
H : lt (S i) (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i vnl nil)
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) false, eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) (firstn s vsl) nil)
+++++
intro H0.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.

*****
H0 : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) (firstn s vsl) nil)
+++++
rewrite nth_firstn.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
rewrite nth_firstn.

*****
H0 : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) vsl nil)
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
rewrite nth_firstn.

*****
H0 : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
lt (Init.Nat.sub i (S n)) s
+++++
apply leb_complete_conv in H0.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
rewrite nth_firstn.
apply leb_complete_conv in H0.

*****
H0 : lt n i
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
lt (Init.Nat.sub i (S n)) s
+++++
omega.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (b : bool) (vnl vsl : list (list bool)), eq (sem (succ b) vnl vsl) (sem (succ b) vnl (firstn (S O) vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (b : bool) (_ : list (list bool)) (vsl : list (list bool)), eq (cons b (hd nil vsl)) (cons b (hd nil match vsl with | nil => nil | cons a _ => cons a nil end))
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (hd nil vsl)) (cons b (hd nil match vsl with | nil => nil | cons a _ => cons a nil end))
+++++
f_equal.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
f_equal.

*****
vnl,vsl : list (list bool)
b : bool
*****
eq (hd nil vsl) (hd nil match vsl with | nil => nil | cons a _ => cons a nil end)
+++++
destruct vsl as [ | v vsl].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
f_equal.
destruct vsl as [ | v vsl].

*****
vnl : list (list bool)
b : bool
*****
eq (hd nil nil) (hd nil nil)
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
f_equal.
destruct vsl as [ | v vsl].

*****
vsl : list (list bool)
v : list bool
vnl : list (list bool)
b : bool
*****
eq (hd nil (cons v vsl)) (hd nil (cons v nil))
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (sem pred vnl vsl) (sem pred vnl (firstn (S O) vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (vsl : list (list bool)), eq (tl (hd nil vsl)) (tl (hd nil match vsl with | nil => nil | cons a _ => cons a nil end))
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq (tl (hd nil vsl)) (tl (hd nil match vsl with | nil => nil | cons a _ => cons a nil end))
+++++
destruct vsl as [ | v vsl].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].

*****
vnl : list (list bool)
*****
eq (tl (hd nil nil)) (tl (hd nil nil))
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].

*****
vsl : list (list bool)
v : list bool
vnl : list (list bool)
*****
eq (tl (hd nil (cons v vsl))) (tl (hd nil (cons v nil)))
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (sem cond vnl vsl) (sem cond vnl (firstn (S (S (S (S O)))) vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (vsl : list (list bool)), eq match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end match match vsl with | nil => nil | cons a l => cons a match l with | nil => nil | cons a0 l0 => cons a0 match l0 with | nil => nil | cons a1 l1 => cons a1 match l1 with | nil => nil | cons a2 _ => cons a2 nil end end end end with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end match match vsl with | nil => nil | cons a l => cons a match l with | nil => nil | cons a0 l0 => cons a0 match l0 with | nil => nil | cons a1 l1 => cons a1 match l1 with | nil => nil | cons a2 _ => cons a2 nil end end end end with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v vsl].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].

*****
vnl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].

*****
vsl : list (list bool)
v : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => nil | cons b nil => match v with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match v with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match v with | nil => b | cons true _ => c | cons false _ => d end end match match vsl with | nil => nil | cons a l => cons a match l with | nil => nil | cons a0 l0 => cons a0 match l0 with | nil => nil | cons a1 _ => cons a1 nil end end end with | nil => nil | cons b nil => match v with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match v with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match v with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v' vsl].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].

*****
v : list bool
vnl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].

*****
vsl : list (list bool)
v,v' : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => match v with | nil => v' | cons _ _ => nil end | cons c nil => match v with | nil => v' | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match v with | nil => v' | cons true _ => c | cons false _ => d end end match match vsl with | nil => nil | cons a l => cons a match l with | nil => nil | cons a0 _ => cons a0 nil end end with | nil => match v with | nil => v' | cons _ _ => nil end | cons c nil => match v with | nil => v' | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match v with | nil => v' | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v'' vsl].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].
destruct vsl as [ | v'' vsl].

*****
v,v' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons _ _ => nil end match v with | nil => v' | cons _ _ => nil end
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].
destruct vsl as [ | v'' vsl].

*****
vsl : list (list bool)
v,v',v'' : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => match v with | nil => v' | cons true _ => v'' | cons false _ => nil end | cons d _ => match v with | nil => v' | cons true _ => v'' | cons false _ => d end end match match vsl with | nil => nil | cons a _ => cons a nil end with | nil => match v with | nil => v' | cons true _ => v'' | cons false _ => nil end | cons d _ => match v with | nil => v' | cons true _ => v'' | cons false _ => d end end
+++++
destruct vsl as [ | v''' vsl].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].
destruct vsl as [ | v'' vsl].
destruct vsl as [ | v''' vsl].

*****
v,v',v'' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons true _ => v'' | cons false _ => nil end match v with | nil => v' | cons true _ => v'' | cons false _ => nil end
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].
destruct vsl as [ | v'' vsl].
destruct vsl as [ | v''' vsl].

*****
vsl : list (list bool)
v,v',v'',v''' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons true _ => v'' | cons false _ => v''' end match v with | nil => v' | cons true _ => v'' | cons false _ => v''' end
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : forall vnl vsl : list (list bool), eq (sem g vnl vsl) (sem g vnl (firstn s vsl))) (_ : forall vnl vsl : list (list bool), eq (sem h0 vnl vsl) (sem h0 vnl (firstn (S s) vsl))) (_ : forall vnl vsl : list (list bool), eq (sem h1 vnl vsl) (sem h1 vnl (firstn (S s) vsl))) (vnl vsl : list (list bool)), eq (sem (rec g h0 h1) vnl vsl) (sem (rec g h0 h1) vnl (firstn s vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : forall vnl vsl : list (list bool), eq (sem g vnl vsl) (sem g vnl (firstn s vsl))) (_ : forall vnl vsl : list (list bool), eq (sem h0 vnl vsl) (sem h0 vnl match vsl with | nil => nil | cons a l => cons a (firstn s l) end)) (_ : forall vnl vsl : list (list bool), eq (sem h1 vnl vsl) (sem h1 vnl match vsl with | nil => nil | cons a l => cons a (firstn s l) end)) (vnl vsl : list (list bool)), eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) (firstn s vsl))
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) (firstn s vsl))
+++++
destruct vnl as [ | v vnl].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil nil) (tl nil) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil nil) (tl nil) (firstn s vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g nil vsl) (sem g nil (firstn s vsl))
+++++
rewrite H2.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
rewrite H2.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g nil (firstn s vsl)) (sem g nil (firstn s vsl))
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].

*****
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil (cons v vnl)) (tl (cons v vnl)) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil (cons v vnl)) (tl (cons v vnl)) (firstn s vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.

*****
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl))
+++++
induction v as [ | [ | ] v IH].
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) nil vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) nil vnl (firstn s vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g vnl vsl) (sem g vnl (firstn s vsl))
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (cons true v) vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) (cons true v) vnl (firstn s vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl)) (sem h1 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl)) (firstn s vsl)))
+++++
rewrite H4.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.
rewrite H4.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) (firstn s vsl))) (sem h1 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl)) (firstn s vsl)))
+++++
congruence.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (cons false v) vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) (cons false v) vnl (firstn s vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl)) (sem h0 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl)) (firstn s vsl)))
+++++
rewrite H3.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.
rewrite H3.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0 vnl\n match vsl with\n | nil => nil\n | cons a l => cons a (firstn s l)\n end)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g vnl (firstn s vsl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) (firstn s vsl))) (sem h0 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl (firstn s vsl)) (firstn s vsl)))
+++++
congruence.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : forall vnl vsl : list (list bool), eq (sem h vnl vsl) (sem h vnl (firstn (length tl) vsl))) (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r vnl (firstn O vsl))) (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r vnl (firstn s vsl))) (vnl vsl : list (list bool)), eq (sem (comp n s h rl tl) vnl vsl) (sem (comp n s h rl tl) vnl (firstn s vsl))
+++++
simpl.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : forall vnl vsl : list (list bool), eq (sem h vnl vsl) (sem h vnl (firstn (length tl) vsl))) (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r vnl nil)) (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r vnl (firstn s vsl))) (vnl vsl : list (list bool)), eq (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl)) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl (firstn s vsl)) tl))
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl (firstn s vsl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl nil)
H2 : forall vnl vsl : list (list bool),\neq (sem h vnl vsl) (sem h vnl (firstn (length tl) vsl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl)) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl (firstn s vsl)) tl))
+++++
clear H H2.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl (firstn s vsl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl nil)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl)) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl (firstn s vsl)) tl))
+++++
f_equal.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.
f_equal.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl (firstn s vsl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl nil)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun se : BC => sem se vnl vsl) tl) (map (fun se : BC => sem se vnl (firstn s vsl)) tl)
+++++
apply map_ext2.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.
f_equal.
apply map_ext2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl (firstn s vsl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl nil)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
forall (a : BC) (_ : In a tl), eq (sem a vnl vsl) (sem a vnl (firstn s vsl))
+++++
intros.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.
f_equal.
apply map_ext2.
intros.

*****
H : In a tl
a : BC
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl (firstn s vsl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl nil)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem a vnl vsl) (sem a vnl (firstn s vsl))
+++++
apply H4.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.
f_equal.
apply map_ext2.
intros.
apply H4.

*****
H : In a tl
a : BC
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl (firstn s vsl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r vnl nil)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
In a tl
+++++
trivial.
-----
Lemma sem_firstn_safe : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f vnl (firstn s vsl).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****

+++++
Qed.
-----
Lemma sem_firstn_normal :\n  forall f n s vnl vsl,\n  arities f = ok_arities n s ->\n  sem f vnl vsl = sem f (firstn n vnl) vsl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.

*****

*****
forall (f : BC) (n s : nat) (vnl vsl : list (list bool)) (_ : eq (arities f) (ok_arities n s)), eq (sem f vnl vsl) (sem f (firstn n vnl) vsl)
+++++
Proof.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.

*****

*****
forall (f : BC) (n s : nat) (vnl vsl : list (list bool)) (_ : eq (arities f) (ok_arities n s)), eq (sem f vnl vsl) (sem f (firstn n vnl) vsl)
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.

*****
H : eq (arities f) (ok_arities n s)
vnl,vsl : list (list bool)
n,s : nat
f : BC
*****
eq (sem f vnl vsl) (sem f (firstn n vnl) vsl)
+++++
revert f n s H vnl vsl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.

*****

*****
forall (f : BC) (n s : nat) (_ : eq (arities f) (ok_arities n s)) (vnl vsl : list (list bool)), eq (sem f vnl vsl) (sem f (firstn n vnl) vsl)
+++++
refine (BC_ind_inf _ _ _ _ _ _ _ _).
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (sem zero vnl vsl) (sem zero (firstn O vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (_ : list (list bool)), eq nil nil
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)) (vnl vsl : list (list bool)), eq (sem (proj n s i) vnl vsl) (sem (proj n s i) (firstn n vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)) (vnl vsl : list (list bool)), eq (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil) (if match n with | O => false | S m' => Nat.leb i m' end then nth i (firstn n vnl) nil else nth (Init.Nat.sub i n) vsl nil)
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil) (if match n with | O => false | S m' => Nat.leb i m' end then nth i (firstn n vnl) nil else nth (Init.Nat.sub i n) vsl nil)
+++++
destruct n as [ | n].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add O s)
s,i : nat
*****
eq (nth (Init.Nat.sub i O) vsl nil) (nth (Init.Nat.sub i O) vsl nil)
+++++
simpl in *.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth (Init.Nat.sub i O) vsl nil) (nth (Init.Nat.sub i O) vsl nil)
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth (Init.Nat.sub i O) vsl nil) (nth (Init.Nat.sub i O) vsl nil)
+++++
rewrite <- minus_n_O.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
rewrite <- minus_n_O.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth i vsl nil) (nth i vsl nil)
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil) (if Nat.leb i n then nth i (firstn (S n) vnl) nil else nth (Init.Nat.sub i (S n)) vsl nil)
+++++
simpl in *.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil) (if Nat.leb i n then nth i match vnl with | nil => nil | cons a l => cons a (firstn n l) end nil else nth (Init.Nat.sub i (S n)) vsl nil)
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil) (if Nat.leb i n then nth i match vnl with | nil => nil | cons a l => cons a (firstn n l) end nil else nth (Init.Nat.sub i (S n)) vsl nil)
+++++
case_eq (leb i n).
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) true, eq (nth i vnl nil) (nth i match vnl with | nil => nil | cons a l => cons a (firstn n l) end nil)
+++++
intro H0.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.

*****
H0 : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i match vnl with | nil => nil | cons a l => cons a (firstn n l) end nil)
+++++
destruct vnl as [ | v vnl].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].

*****
H0 : eq (Nat.leb i n) true
vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i nil nil) (nth i nil nil)
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].

*****
H0 : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
v : list bool
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i (cons v vnl) nil) (nth i (cons v (firstn n vnl)) nil)
+++++
destruct i as [ | i].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].

*****
H0 : eq (Nat.leb O n) true
vnl,vsl : list (list bool)
v : list bool
H : lt O (S (Init.Nat.add n s))
n,s : nat
*****
eq (nth O (cons v vnl) nil) (nth O (cons v (firstn n vnl)) nil)
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].

*****
H0 : eq (Nat.leb (S i) n) true
vnl,vsl : list (list bool)
v : list bool
H : lt (S i) (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (S i) (cons v vnl) nil) (nth (S i) (cons v (firstn n vnl)) nil)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].
simpl.

*****
H0 : eq (Nat.leb (S i) n) true
vnl,vsl : list (list bool)
v : list bool
H : lt (S i) (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i (firstn n vnl) nil)
+++++
apply leb_complete in H0.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].
simpl.
apply leb_complete in H0.

*****
H0 : le (S i) n
vnl,vsl : list (list bool)
v : list bool
H : lt (S i) (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i (firstn n vnl) nil)
+++++
rewrite nth_firstn.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].
simpl.
apply leb_complete in H0.
rewrite nth_firstn.

*****
H0 : le (S i) n
vnl,vsl : list (list bool)
v : list bool
H : lt (S i) (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i vnl nil)
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.
destruct vnl as [ | v vnl].
destruct i as [ | i].
simpl.
apply leb_complete in H0.
rewrite nth_firstn.

*****
H0 : le (S i) n
vnl,vsl : list (list bool)
v : list bool
H : lt (S i) (S (Init.Nat.add n s))
n,s,i : nat
*****
lt i n
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) false, eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) vsl nil)
+++++
intro H0.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct n as [ | n].
simpl in *.
intros.
case_eq (leb i n).
intro H0.

*****
H0 : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) vsl nil)
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (b : bool) (vnl vsl : list (list bool)), eq (sem (succ b) vnl vsl) (sem (succ b) (firstn O vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (b : bool) (_ : list (list bool)) (vsl : list (list bool)), eq (cons b (hd nil vsl)) (cons b (hd nil vsl))
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (hd nil vsl)) (cons b (hd nil vsl))
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (sem pred vnl vsl) (sem pred (firstn O vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (vsl : list (list bool)), eq (tl (hd nil vsl)) (tl (hd nil vsl))
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq (tl (hd nil vsl)) (tl (hd nil vsl))
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall vnl vsl : list (list bool), eq (sem cond vnl vsl) (sem cond (firstn O vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (_ : list (list bool)) (vsl : list (list bool)), eq match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
*****
eq match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v vsl].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].

*****
vnl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].

*****
vsl : list (list bool)
v : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => nil | cons b nil => match v with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match v with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match v with | nil => b | cons true _ => c | cons false _ => d end end match vsl with | nil => nil | cons b nil => match v with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match v with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match v with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v' vsl].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].

*****
v : list bool
vnl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].

*****
vsl : list (list bool)
v,v' : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => match v with | nil => v' | cons _ _ => nil end | cons c nil => match v with | nil => v' | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match v with | nil => v' | cons true _ => c | cons false _ => d end end match vsl with | nil => match v with | nil => v' | cons _ _ => nil end | cons c nil => match v with | nil => v' | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match v with | nil => v' | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v'' vsl].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].
destruct vsl as [ | v'' vsl].

*****
v,v' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons _ _ => nil end match v with | nil => v' | cons _ _ => nil end
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].
destruct vsl as [ | v'' vsl].

*****
vsl : list (list bool)
v,v',v'' : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => match v with | nil => v' | cons true _ => v'' | cons false _ => nil end | cons d _ => match v with | nil => v' | cons true _ => v'' | cons false _ => d end end match vsl with | nil => match v with | nil => v' | cons true _ => v'' | cons false _ => nil end | cons d _ => match v with | nil => v' | cons true _ => v'' | cons false _ => d end end
+++++
destruct vsl as [ | v''' vsl].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].
destruct vsl as [ | v'' vsl].
destruct vsl as [ | v''' vsl].

*****
v,v',v'' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons true _ => v'' | cons false _ => nil end match v with | nil => v' | cons true _ => v'' | cons false _ => nil end
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vsl as [ | v vsl].
destruct vsl as [ | v' vsl].
destruct vsl as [ | v'' vsl].
destruct vsl as [ | v''' vsl].

*****
vsl : list (list bool)
v,v',v'',v''' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons true _ => v'' | cons false _ => v''' end match v with | nil => v' | cons true _ => v'' | cons false _ => v''' end
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : forall vnl vsl : list (list bool), eq (sem g vnl vsl) (sem g (firstn n vnl) vsl)) (_ : forall vnl vsl : list (list bool), eq (sem h0 vnl vsl) (sem h0 (firstn (S n) vnl) vsl)) (_ : forall vnl vsl : list (list bool), eq (sem h1 vnl vsl) (sem h1 (firstn (S n) vnl) vsl)) (vnl vsl : list (list bool)), eq (sem (rec g h0 h1) vnl vsl) (sem (rec g h0 h1) (firstn (S n) vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : forall vnl vsl : list (list bool), eq (sem g vnl vsl) (sem g (firstn n vnl) vsl)) (_ : forall vnl vsl : list (list bool), eq (sem h0 vnl vsl) (sem h0 match vnl with | nil => nil | cons a l => cons a (firstn n l) end vsl)) (_ : forall vnl vsl : list (list bool), eq (sem h1 vnl vsl) (sem h1 match vnl with | nil => nil | cons a l => cons a (firstn n l) end vsl)) (vnl vsl : list (list bool)), eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil match vnl with | nil => nil | cons a l => cons a (firstn n l) end) (tl match vnl with | nil => nil | cons a l => cons a (firstn n l) end) vsl)
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil match vnl with | nil => nil | cons a l => cons a (firstn n l) end) (tl match vnl with | nil => nil | cons a l => cons a (firstn n l) end) vsl)
+++++
destruct vnl as [ | v vnl].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil nil) (tl nil) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil nil) (tl nil) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g nil vsl) (sem g nil vsl)
+++++
rewrite H2.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
rewrite H2.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g (firstn n nil) vsl) (sem g (firstn n nil) vsl)
+++++
rewrite firstn_nil.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
rewrite H2.
rewrite firstn_nil.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g nil vsl) (sem g nil vsl)
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].

*****
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil (cons v vnl)) (tl (cons v vnl)) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil (cons v (firstn n vnl))) (tl (cons v (firstn n vnl))) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.

*****
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl)
+++++
induction v as [ | [ | ] v IH].
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) nil vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) nil (firstn n vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
+++++
trivial.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl)
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (cons true v) vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) (cons true v) (firstn n vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl)
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl)) (sem h1 (cons v (firstn n vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl) vsl))
+++++
rewrite H4.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.
rewrite H4.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl)
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (cons v (firstn n vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl)) (sem h1 (cons v (firstn n vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl) vsl))
+++++
congruence.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl)
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (cons false v) vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) (cons false v) (firstn n vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl)
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl)) (sem h0 (cons v (firstn n vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl) vsl))
+++++
rewrite H3.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
destruct vnl as [ | v vnl].
simpl.
induction v as [ | [ | ] v IH].
simpl.
rewrite H3.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl)
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n match vnl with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl) (sem g (firstn n vnl) vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (cons v (firstn n vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl)) (sem h0 (cons v (firstn n vnl)) (cons (sem_rec (sem g) (sem h0) (sem h1) v (firstn n vnl) vsl) vsl))
+++++
congruence.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : forall vnl vsl : list (list bool), eq (sem h vnl vsl) (sem h (firstn (length rl) vnl) vsl)) (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r (firstn n vnl) vsl)) (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r (firstn n vnl) vsl)) (vnl vsl : list (list bool)), eq (sem (comp n s h rl tl) vnl vsl) (sem (comp n s h rl tl) (firstn n vnl) vsl)
+++++
simpl.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : forall vnl vsl : list (list bool), eq (sem h vnl vsl) (sem h (firstn (length rl) vnl) vsl)) (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r (firstn n vnl) vsl)) (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r (firstn n vnl) vsl)) (vnl vsl : list (list bool)), eq (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl)) (sem h (map (fun ne : BC => sem ne (firstn n vnl) nil) rl) (map (fun se : BC => sem se (firstn n vnl) vsl) tl))
+++++
intros.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H2 : forall vnl vsl : list (list bool),\neq (sem h vnl vsl) (sem h (firstn (length rl) vnl) vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl)) (sem h (map (fun ne : BC => sem ne (firstn n vnl) nil) rl) (map (fun se : BC => sem se (firstn n vnl) vsl) tl))
+++++
clear H H2.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl)) (sem h (map (fun ne : BC => sem ne (firstn n vnl) nil) rl) (map (fun se : BC => sem se (firstn n vnl) vsl) tl))
+++++
f_equal.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.
f_equal.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne vnl nil) rl) (map (fun ne : BC => sem ne (firstn n vnl) nil) rl)
+++++
apply map_ext2.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.
f_equal.
apply map_ext2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
forall (a : BC) (_ : In a rl), eq (sem a vnl nil) (sem a (firstn n vnl) nil)
+++++
auto.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.
f_equal.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun se : BC => sem se vnl vsl) tl) (map (fun se : BC => sem se (firstn n vnl) vsl) tl)
+++++
apply map_ext2.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
intros.
clear H H2.
f_equal.
apply map_ext2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl) (sem r (firstn n vnl) vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
forall (a : BC) (_ : In a tl), eq (sem a vnl vsl) (sem a (firstn n vnl) vsl)
+++++
auto.
-----
Lemma sem_firstn_normal : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) vsl.
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****

+++++
Qed.
-----
Lemma sem_firstn :\n  forall f n s vnl vsl,\n  arities f = ok_arities n s ->\n  sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).

*****

*****
forall (f : BC) (n s : nat) (vnl vsl : list (list bool)) (_ : eq (arities f) (ok_arities n s)), eq (sem f vnl vsl) (sem f (firstn n vnl) (firstn s vsl))
+++++
Proof.
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
Proof.

*****

*****
forall (f : BC) (n s : nat) (vnl vsl : list (list bool)) (_ : eq (arities f) (ok_arities n s)), eq (sem f vnl vsl) (sem f (firstn n vnl) (firstn s vsl))
+++++
intros.
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
Proof.
intros.

*****
H : eq (arities f) (ok_arities n s)
vnl,vsl : list (list bool)
n,s : nat
f : BC
*****
eq (sem f vnl vsl) (sem f (firstn n vnl) (firstn s vsl))
+++++
erewrite sem_firstn_safe.
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
Proof.
intros.
erewrite sem_firstn_safe.

*****
H : eq (arities f) (ok_arities n s)
vnl,vsl : list (list bool)
n,s : nat
f : BC
*****
eq (sem f vnl (firstn ?s vsl)) (sem f (firstn n vnl) (firstn s vsl))
+++++
eauto.
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
Proof.
intros.
erewrite sem_firstn_safe.
eauto.

*****
H : eq (arities f) (ok_arities n s)
vnl,vsl : list (list bool)
n,s : nat
f : BC
*****
eq (sem f vnl (firstn ?s vsl)) (sem f (firstn n vnl) (firstn s vsl))
+++++
erewrite sem_firstn_normal.
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
Proof.
intros.
erewrite sem_firstn_safe.
eauto.
erewrite sem_firstn_normal.

*****
H : eq (arities f) (ok_arities n s)
vnl,vsl : list (list bool)
n,s : nat
f : BC
*****
eq (sem f (firstn ?n0 vnl) (firstn ?s vsl)) (sem f (firstn n vnl) (firstn s vsl))
+++++
eauto.
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
Proof.
intros.
erewrite sem_firstn_safe.
eauto.
erewrite sem_firstn_normal.

*****
H : eq (arities f) (ok_arities n s)
vnl,vsl : list (list bool)
n,s : nat
f : BC
*****
eq (arities f) (ok_arities n ?s)
+++++
eauto.
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
Proof.
intros.
erewrite sem_firstn_safe.

*****
H : eq (arities f) (ok_arities n s)
vnl,vsl : list (list bool)
n,s : nat
f : BC
*****
eq (arities f) (ok_arities ?n s)
+++++
eauto.
-----
Lemma sem_firstn : forall f n s vnl vsl, arities f = ok_arities n s -> sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).
Proof.
intros.
erewrite sem_firstn_safe.

*****

*****

+++++
Qed.
-----
Lemma sem_repeat :\n  forall f vnl vsl n s,\n  arities f = ok_arities n s ->\n  sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).

*****

*****
forall (f : BC) (vnl vsl : list (list bool)) (n s : nat) (_ : eq (arities f) (ok_arities n s)), eq (sem f vnl vsl) (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
Proof.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.

*****

*****
forall (f : BC) (vnl vsl : list (list bool)) (n s : nat) (_ : eq (arities f) (ok_arities n s)), eq (sem f vnl vsl) (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
intros.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.

*****
H : eq (arities f) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
f : BC
*****
eq (sem f vnl vsl) (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
revert f n s H vnl vsl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.

*****

*****
forall (f : BC) (n s : nat) (_ : eq (arities f) (ok_arities n s)) (vnl vsl : list (list bool)), eq (sem f vnl vsl) (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.

*****
vnl,vsl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.

*****
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (if match n with | O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil) (if match n with | O => false | S m' => Nat.leb i m' end then nth i (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil else nth (Init.Nat.sub i n) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
destruct n as [ | n]; simpl in *; intros.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth (Init.Nat.sub i O) vsl nil) (nth (Init.Nat.sub i O) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
rewrite <- minus_n_O.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.

*****
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth i vsl nil) (nth i (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
destruct (le_dec (length vsl) i).
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).

*****
l : le (length vsl) i
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth i vsl nil) (nth i (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
rewrite app_nth2,nth_repeat, nth_overflow.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.

*****
l : le (length vsl) i
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.

*****
l : le (length vsl) i
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
le (length vsl) i
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.

*****
l : le (length vsl) i
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
lt (Init.Nat.sub i (length vsl)) (Init.Nat.sub s (length vsl))
+++++
omega.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.

*****
l : le (length vsl) i
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
ge i (length vsl)
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.

*****
n : not (le (length vsl) i)
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth i vsl nil) (nth i (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
rewrite app_nth1.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.

*****
n : not (le (length vsl) i)
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
eq (nth i vsl nil) (nth i vsl nil)
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.

*****
n : not (le (length vsl) i)
vnl,vsl : list (list bool)
H : lt i s
s,i : nat
*****
lt i (length vsl)
+++++
omega.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.

*****
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil) (if Nat.leb i n then nth i (app vnl (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil)) nil else nth (Init.Nat.sub i (S n)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
case_eq (leb i n); intro Hleb.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.

*****
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i (app vnl (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil)) nil)
+++++
destruct (le_dec (length vnl) i).
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).

*****
l : le (length vnl) i
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i (app vnl (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil)) nil)
+++++
rewrite app_nth2,nth_repeat, nth_overflow.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.

*****
l : le (length vnl) i
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.

*****
l : le (length vnl) i
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
le (length vnl) i
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.

*****
l : le (length vnl) i
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
lt (Init.Nat.sub i (length vnl)) match length vnl with | O => S n | S l => Init.Nat.sub n l end
+++++
apply leb_complete in Hleb.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.

*****
l : le (length vnl) i
Hleb : le i n
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
lt (Init.Nat.sub i (length vnl)) match length vnl with | O => S n | S l => Init.Nat.sub n l end
+++++
destruct (length vnl); omega.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.

*****
l : le (length vnl) i
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
ge i (length vnl)
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.

*****
n0 : not (le (length vnl) i)
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i (app vnl (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil)) nil)
+++++
rewrite app_nth1.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.

*****
n0 : not (le (length vnl) i)
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth i vnl nil) (nth i vnl nil)
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.

*****
n0 : not (le (length vnl) i)
Hleb : eq (Nat.leb i n) true
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
lt i (length vnl)
+++++
omega.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.

*****
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
destruct (le_dec (length vsl) (i - S n)).
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).

*****
l : le (length vsl) (Init.Nat.sub i (S n))
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
rewrite app_nth2,nth_repeat, nth_overflow.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.

*****
l : le (length vsl) (Init.Nat.sub i (S n))
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.

*****
l : le (length vsl) (Init.Nat.sub i (S n))
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
le (length vsl) (Init.Nat.sub i (S n))
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.

*****
l : le (length vsl) (Init.Nat.sub i (S n))
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
lt (Init.Nat.sub (Init.Nat.sub i (S n)) (length vsl)) (Init.Nat.sub s (length vsl))
+++++
apply leb_complete_conv in Hleb.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.

*****
l : le (length vsl) (Init.Nat.sub i (S n))
Hleb : lt n i
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
lt (Init.Nat.sub (Init.Nat.sub i (S n)) (length vsl)) (Init.Nat.sub s (length vsl))
+++++
omega.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.

*****
l : le (length vsl) (Init.Nat.sub i (S n))
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
ge (Init.Nat.sub i (S n)) (length vsl)
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.

*****
n0 : not (le (length vsl) (Init.Nat.sub i (S n)))
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) nil)
+++++
rewrite app_nth1.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.

*****
n0 : not (le (length vsl) (Init.Nat.sub i (S n)))
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth (Init.Nat.sub i (S n)) vsl nil)
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.

*****
n0 : not (le (length vsl) (Init.Nat.sub i (S n)))
Hleb : eq (Nat.leb i n) false
vnl,vsl : list (list bool)
H : lt i (S (Init.Nat.add n s))
n,s,i : nat
*****
lt (Init.Nat.sub i (S n)) (length vsl)
+++++
omega.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.

*****
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (hd nil vsl)) (cons b (hd nil (app vsl (repeat match length vsl with | O => S O | S _ => O end nil))))
+++++
f_equal.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.

*****
vnl,vsl : list (list bool)
b : bool
*****
eq (hd nil vsl) (hd nil (app vsl (repeat match length vsl with | O => S O | S _ => O end nil)))
+++++
destruct vsl as [ | v vsl].
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].

*****
vnl : list (list bool)
b : bool
*****
eq (hd nil nil) (hd nil (app nil (repeat match length nil with | O => S O | S _ => O end nil)))
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.

*****
vsl : list (list bool)
v : list bool
vnl : list (list bool)
b : bool
*****
eq (hd nil (cons v vsl)) (hd nil (app (cons v vsl) (repeat match length (cons v vsl) with | O => S O | S _ => O end nil)))
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.

*****
vnl,vsl : list (list bool)
*****
eq (tl (hd nil vsl)) (tl (hd nil (app vsl (repeat match length vsl with | O => S O | S _ => O end nil))))
+++++
destruct vsl as [ | v vsl].
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].

*****
vnl : list (list bool)
*****
eq (tl (hd nil nil)) (tl (hd nil (app nil (repeat match length nil with | O => S O | S _ => O end nil))))
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.

*****
vsl : list (list bool)
v : list bool
vnl : list (list bool)
*****
eq (tl (hd nil (cons v vsl))) (tl (hd nil (app (cons v vsl) (repeat match length (cons v vsl) with | O => S O | S _ => O end nil))))
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.

*****
vnl,vsl : list (list bool)
*****
eq match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end match app vsl (repeat match length vsl with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v vsl].
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].

*****
vnl : list (list bool)
*****
eq nil match app nil (repeat match length nil with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.

*****
vsl : list (list bool)
v : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => nil | cons b nil => match v with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match v with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match v with | nil => b | cons true _ => c | cons false _ => d end end match app (cons v vsl) (repeat match length (cons v vsl) with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v' vsl].
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].

*****
v : list bool
vnl : list (list bool)
*****
eq nil match app (cons v nil) (repeat match length (cons v nil) with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
simpl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.

*****
v : list bool
vnl : list (list bool)
*****
eq nil match v with | nil | _ => nil end
+++++
destruct v as [ | [ | ] v]; trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.

*****
vsl : list (list bool)
v,v' : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => match v with | nil => v' | cons _ _ => nil end | cons c nil => match v with | nil => v' | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match v with | nil => v' | cons true _ => c | cons false _ => d end end match app (cons v (cons v' vsl)) (repeat match length (cons v (cons v' vsl)) with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v'' vsl].
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].

*****
v,v' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons _ _ => nil end match app (cons v (cons v' nil)) (repeat match length (cons v (cons v' nil)) with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
simpl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.

*****
v,v' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons _ _ => nil end match v with | nil => v' | _ => nil end
+++++
destruct v as [ | [ | ] v]; trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.

*****
vsl : list (list bool)
v,v',v'' : list bool
vnl : list (list bool)
*****
eq match vsl with | nil => match v with | nil => v' | cons true _ => v'' | cons false _ => nil end | cons d _ => match v with | nil => v' | cons true _ => v'' | cons false _ => d end end match app (cons v (cons v' (cons v'' vsl))) (repeat match length (cons v (cons v' (cons v'' vsl))) with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl as [ | v''' vsl].
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].

*****
v,v',v'' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons true _ => v'' | cons false _ => nil end match app (cons v (cons v' (cons v'' nil))) (repeat match length (cons v (cons v' (cons v'' nil))) with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
simpl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.

*****
v,v',v'' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons true _ => v'' | cons false _ => nil end match v with | nil => v' | cons true _ => v'' | cons false _ => nil end
+++++
destruct v as [ | [ | ] v]; trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.

*****
vsl : list (list bool)
v,v',v'',v''' : list bool
vnl : list (list bool)
*****
eq match v with | nil => v' | cons true _ => v'' | cons false _ => v''' end match app (cons v (cons v' (cons v'' (cons v''' vsl)))) (repeat match length (cons v (cons v' (cons v'' (cons v''' vsl)))) with | O => S (S (S (S O))) | S O => S (S (S O)) | S (S O) => S (S O) | S (S (S O)) => S O | S (S (S (S _))) => O end nil) with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct v as [ | [ | ] v]; trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl) (sem_rec (sem g) (sem h0) (sem h1) (hd nil (app vnl (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil))) (tl (app vnl (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil))) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
destruct vnl as [ | v vnl]; simpl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g nil vsl) (sem g (repeat n nil) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
rewrite H2.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g (app nil (repeat (Init.Nat.sub n (length nil)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (sem g (repeat n nil) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
f_equal.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (app nil (repeat (Init.Nat.sub n (length nil)) nil)) (repeat n nil)
+++++
simpl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (repeat (Init.Nat.sub n O) nil) (repeat n nil)
+++++
cutrewrite (n-0 = n).
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (repeat n nil) (repeat n nil)
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.

*****
vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (Init.Nat.sub n O) n
+++++
omega.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.

*****
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) (sem_rec (sem g) (sem h0) (sem h1) v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
induction v as [ | [ | ] v IH]; simpl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem g vnl vsl) (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v\n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl)) (sem h1 (cons v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))) (cons (sem_rec (sem g) (sem h0) (sem h1) v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))))
+++++
rewrite H4.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v\n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h1 (app (cons v vnl) (repeat match length (cons v vnl) with | O => S n | S l => Init.Nat.sub n l end nil)) (app (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl) (repeat match length (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl) with | O => S s | S l => Init.Nat.sub s l end nil))) (sem h1 (cons v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))) (cons (sem_rec (sem g) (sem h0) (sem h1) v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))))
+++++
simpl; congruence.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v\n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (cons v vnl) (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl)) (sem h0 (cons v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))) (cons (sem_rec (sem g) (sem h0) (sem h1) v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))))
+++++
rewrite H3.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.

*****
IH : eq (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl)\n (sem_rec (sem g) (sem h0) (sem h1) v\n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
vnl,vsl : list (list bool)
v : list bool
H4 : forall vnl vsl : list (list bool),\neq (sem h1 vnl vsl)\n (sem h1\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H3 : forall vnl vsl : list (list bool),\neq (sem h0 vnl vsl)\n (sem h0\n (app vnl\n (repeat\n match length vnl with\n | O => S n\n | S l => Init.Nat.sub n l\n end nil))\n (app vsl\n (repeat\n match length vsl with\n | O => S s\n | S l => Init.Nat.sub s l\n end nil)))
H2 : forall vnl vsl : list (list bool),\neq (sem g vnl vsl)\n (sem g (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (sem h0 (app (cons v vnl) (repeat match length (cons v vnl) with | O => S n | S l => Init.Nat.sub n l end nil)) (app (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl) (repeat match length (cons (sem_rec (sem g) (sem h0) (sem h1) v vnl vsl) vsl) with | O => S s | S l => Init.Nat.sub s l end nil))) (sem h0 (cons v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))) (cons (sem_rec (sem g) (sem h0) (sem h1) v (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))))
+++++
simpl; congruence.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H2 : forall vnl vsl : list (list bool),\neq (sem h vnl vsl)\n (sem h (app vnl (repeat (Init.Nat.sub (length rl) (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub (length tl) (length vsl)) nil)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl)) (sem h (map (fun ne : BC => sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) rl) (map (fun se : BC => sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl))
+++++
clear H H2.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl)) (sem h (map (fun ne : BC => sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) rl) (map (fun se : BC => sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl))
+++++
f_equal.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne vnl nil) rl) (map (fun ne : BC => sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) rl)
+++++
induction rl as [ | r rl IH]; simpl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r nil) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e nil), eq (arities e) (ok_arities n O)
tl : list BC
h : BC
n,s : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))),\neq (map (fun ne : BC => sem ne vnl nil) rl)\n (map\n (fun ne : BC =>\n sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)\n rl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r0 : BC) (_ : In r0 (cons r rl)) (vnl vsl : list (list bool)),\neq (sem r0 vnl vsl)\n (sem r0 (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e (cons r rl)), eq (arities e) (ok_arities n O)
rl,tl : list BC
h,r : BC
n,s : nat
*****
eq (cons (sem r vnl nil) (map (fun ne : BC => sem ne vnl nil) rl)) (cons (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) (map (fun ne : BC => sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) rl))
+++++
f_equal.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))),\neq (map (fun ne : BC => sem ne vnl nil) rl)\n (map\n (fun ne : BC =>\n sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)\n rl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r0 : BC) (_ : In r0 (cons r rl)) (vnl vsl : list (list bool)),\neq (sem r0 vnl vsl)\n (sem r0 (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e (cons r rl)), eq (arities e) (ok_arities n O)
rl,tl : list BC
h,r : BC
n,s : nat
*****
eq (sem r vnl nil) (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)
+++++
apply H3.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))),\neq (map (fun ne : BC => sem ne vnl nil) rl)\n (map\n (fun ne : BC =>\n sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)\n rl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r0 : BC) (_ : In r0 (cons r rl)) (vnl vsl : list (list bool)),\neq (sem r0 vnl vsl)\n (sem r0 (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e (cons r rl)), eq (arities e) (ok_arities n O)
rl,tl : list BC
h,r : BC
n,s : nat
*****
In r (cons r rl)
+++++
simpl; tauto.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))),\neq (map (fun ne : BC => sem ne vnl nil) rl)\n (map\n (fun ne : BC =>\n sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)\n rl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r0 : BC) (_ : In r0 (cons r rl)) (vnl vsl : list (list bool)),\neq (sem r0 vnl vsl)\n (sem r0 (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e (cons r rl)), eq (arities e) (ok_arities n O)
rl,tl : list BC
h,r : BC
n,s : nat
*****
eq (map (fun ne : BC => sem ne vnl nil) rl) (map (fun ne : BC => sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) rl)
+++++
apply IH.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))),\neq (map (fun ne : BC => sem ne vnl nil) rl)\n (map\n (fun ne : BC =>\n sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)\n rl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r0 : BC) (_ : In r0 (cons r rl)) (vnl vsl : list (list bool)),\neq (sem r0 vnl vsl)\n (sem r0 (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e (cons r rl)), eq (arities e) (ok_arities n O)
rl,tl : list BC
h,r : BC
n,s : nat
*****
forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
+++++
auto with *.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))),\neq (map (fun ne : BC => sem ne vnl nil) rl)\n (map\n (fun ne : BC =>\n sem ne (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)\n rl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r0 : BC) (_ : In r0 (cons r rl)) (vnl vsl : list (list bool)),\neq (sem r0 vnl vsl)\n (sem r0 (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e (cons r rl)), eq (arities e) (ok_arities n O)
rl,tl : list BC
h,r : BC
n,s : nat
*****
forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl nil))
+++++
auto with *.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.
auto with *.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
*****
eq (map (fun se : BC => sem se vnl vsl) tl) (map (fun se : BC => sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl)
+++++
induction tl as [ | t tl IH]; simpl.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.
auto with *.
induction tl as [ | t tl IH]; simpl.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r nil) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e nil), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl : list BC
h : BC
n,s : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.
auto with *.
induction tl as [ | t tl IH]; simpl.
trivial.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))),\neq (map (fun se : BC => sem se vnl vsl) tl)\n (map\n (fun se : BC =>\n sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r (cons t tl)) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e (cons t tl)), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
tl : list BC
t : BC
rl : list BC
h : BC
n,s : nat
*****
eq (cons (sem t vnl vsl) (map (fun se : BC => sem se vnl vsl) tl)) (cons (sem t (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (map (fun se : BC => sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl))
+++++
f_equal.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.
auto with *.
induction tl as [ | t tl IH]; simpl.
trivial.
f_equal.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))),\neq (map (fun se : BC => sem se vnl vsl) tl)\n (map\n (fun se : BC =>\n sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r (cons t tl)) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e (cons t tl)), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
tl : list BC
t : BC
rl : list BC
h : BC
n,s : nat
*****
eq (sem t vnl vsl) (sem t (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
auto with *.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.
auto with *.
induction tl as [ | t tl IH]; simpl.
trivial.
f_equal.
auto with *.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))),\neq (map (fun se : BC => sem se vnl vsl) tl)\n (map\n (fun se : BC =>\n sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r (cons t tl)) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e (cons t tl)), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
tl : list BC
t : BC
rl : list BC
h : BC
n,s : nat
*****
eq (map (fun se : BC => sem se vnl vsl) tl) (map (fun se : BC => sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl)
+++++
apply IH.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.
auto with *.
induction tl as [ | t tl IH]; simpl.
trivial.
f_equal.
auto with *.
apply IH.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))),\neq (map (fun se : BC => sem se vnl vsl) tl)\n (map\n (fun se : BC =>\n sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r (cons t tl)) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e (cons t tl)), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
tl : list BC
t : BC
rl : list BC
h : BC
n,s : nat
*****
forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
+++++
auto with *.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.
auto with *.
induction tl as [ | t tl IH]; simpl.
trivial.
f_equal.
auto with *.
apply IH.
auto with *.

*****
IH : forall\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\n eq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))),\neq (map (fun se : BC => sem se vnl vsl) tl)\n (map\n (fun se : BC =>\n sem se (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) tl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r (cons t tl)) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (sem r vnl vsl)\n (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl nil))
H1 : forall (e : BC) (_ : In e (cons t tl)), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
tl : list BC
t : BC
rl : list BC
h : BC
n,s : nat
*****
forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)), eq (sem r vnl vsl) (sem r (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
auto with *.
-----
Lemma sem_repeat : forall f vnl vsl n s, arities f = ok_arities n s -> sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).
Proof.
intros.
revert f n s H vnl vsl.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros.
trivial.
destruct n as [ | n]; simpl in *; intros.
rewrite <- minus_n_O.
destruct (le_dec (length vsl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
case_eq (leb i n); intro Hleb.
destruct (le_dec (length vnl) i).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete in Hleb.
destruct (length vnl); omega.
trivial.
rewrite app_nth1.
trivial.
omega.
destruct (le_dec (length vsl) (i - S n)).
rewrite app_nth2,nth_repeat, nth_overflow.
trivial.
trivial.
apply leb_complete_conv in Hleb.
omega.
trivial.
rewrite app_nth1.
trivial.
omega.
f_equal.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
trivial.
destruct vsl as [ | v vsl].
trivial.
destruct vsl as [ | v' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v'' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct vsl as [ | v''' vsl].
simpl.
destruct v as [ | [ | ] v]; trivial.
destruct v as [ | [ | ] v]; trivial.
destruct vnl as [ | v vnl]; simpl.
rewrite H2.
f_equal.
simpl.
cutrewrite (n-0 = n).
trivial.
omega.
induction v as [ | [ | ] v IH]; simpl.
trivial.
rewrite H4.
simpl; congruence.
rewrite H3.
simpl; congruence.
clear H H2.
f_equal.
induction rl as [ | r rl IH]; simpl.
trivial.
f_equal.
apply H3.
simpl; tauto.
apply IH.
auto with *.
auto with *.
induction tl as [ | t tl IH]; simpl.
trivial.
f_equal.
auto with *.
apply IH.
auto with *.
auto with *.

*****

*****

+++++
Qed.
-----
Lemma map_sem_repeat :\n  forall fl vnl vsl n s,\n  (forall f, In f fl -> arities f = ok_arities n s) ->\n  map (fun f => sem f vnl vsl) fl =\n  map (\n    fun f =>\n      sem f\n        (vnl ++ repeat (n - length vnl) nil)\n        (vsl ++ repeat (s - length vsl) nil)\n  ) fl.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.

*****

*****
forall (fl : list BC) (vnl vsl : list (list bool)) (n s : nat) (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)), eq (map (fun f : BC => sem f vnl vsl) fl) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
+++++
Proof.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.

*****

*****
forall (fl : list BC) (vnl vsl : list (list bool)) (n s : nat) (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)), eq (map (fun f : BC => sem f vnl vsl) fl) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
+++++
induction fl as [ | f fl IH].
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].

*****

*****
forall (vnl vsl : list (list bool)) (n s : nat) (_ : forall (f : BC) (_ : In f nil), eq (arities f) (ok_arities n s)), eq (map (fun f : BC => sem f vnl vsl) nil) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) nil)
+++++
intros vnl vsl n s H.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.

*****
H : forall (f : BC) (_ : In f nil), eq (arities f) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
*****
eq (map (fun f : BC => sem f vnl vsl) nil) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) nil)
+++++
simpl.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.

*****
H : forall (f : BC) (_ : In f nil), eq (arities f) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].

*****
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
forall (vnl vsl : list (list bool)) (n s : nat) (_ : forall (f0 : BC) (_ : In f0 (cons f fl)), eq (arities f0) (ok_arities n s)), eq (map (fun f : BC => sem f vnl vsl) (cons f fl)) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (cons f fl))
+++++
intros vnl vsl n s H.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.

*****
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
eq (map (fun f : BC => sem f vnl vsl) (cons f fl)) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (cons f fl))
+++++
simpl.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.

*****
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
eq (cons (sem f vnl vsl) (map (fun f : BC => sem f vnl vsl) fl)) (cons (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl))
+++++
f_equal.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.

*****
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
eq (sem f vnl vsl) (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
apply sem_repeat.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.
apply sem_repeat.

*****
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
eq (arities f) (ok_arities n s)
+++++
apply H.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.
apply sem_repeat.
apply H.

*****
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
In f (cons f fl)
+++++
simpl.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.
apply sem_repeat.
apply H.
simpl.

*****
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
or (eq f f) (In f fl)
+++++
tauto.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.

*****
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
eq (map (fun f : BC => sem f vnl vsl) fl) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
+++++
apply IH.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.
apply IH.

*****
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)
+++++
intros.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.
apply IH.
intros.

*****
H0 : In f0 fl
f0 : BC
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
eq (arities f0) (ok_arities n s)
+++++
apply H.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.
apply IH.
intros.
apply H.

*****
H0 : In f0 fl
f0 : BC
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
In f0 (cons f fl)
+++++
simpl.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].
intros vnl vsl n s H.
simpl.
f_equal.
apply IH.
intros.
apply H.
simpl.

*****
H0 : In f0 fl
f0 : BC
H : forall (f0 : BC) (_ : In f0 (cons f fl)),\neq (arities f0) (ok_arities n s)
n,s : nat
vnl,vsl : list (list bool)
IH : forall (vnl vsl : list (list bool)) (n s : nat)\n (_ : forall (f : BC) (_ : In f fl), eq (arities f) (ok_arities n s)),\neq (map (fun f : BC => sem f vnl vsl) fl)\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))\n (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) fl)
fl : list BC
f : BC
*****
or (eq f f0) (In f0 fl)
+++++
tauto.
-----
Lemma map_sem_repeat : forall fl vnl vsl n s, (forall f, In f fl -> arities f = ok_arities n s) -> map (fun f => sem f vnl vsl) fl = map ( fun f => sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil) ) fl.
Proof.
induction fl as [ | f fl IH].

*****

*****

+++++
Qed.
-----
Lemma map_proj_seq_normal_gen :\n  forall n i vnl,\n  n+i <= length vnl ->\n  map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) =\n  firstn n (skipn i vnl).
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).

*****

*****
forall (n i : nat) (vnl : list (list bool)) (_ : le (Init.Nat.add n i) (length vnl)), eq (map (fun f : BC => sem f vnl nil) (map (proj (Init.Nat.add n i) O) (seq i n))) (firstn n (skipn i vnl))
+++++
Proof.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.

*****

*****
forall (n i : nat) (vnl : list (list bool)) (_ : le (Init.Nat.add n i) (length vnl)), eq (map (fun f : BC => sem f vnl nil) (map (proj (Init.Nat.add n i) O) (seq i n))) (firstn n (skipn i vnl))
+++++
induction n as [ | n IH].
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].

*****

*****
forall (i : nat) (vnl : list (list bool)) (_ : le (Init.Nat.add O i) (length vnl)), eq (map (fun f : BC => sem f vnl nil) (map (proj (Init.Nat.add O i) O) (seq i O))) (firstn O (skipn i vnl))
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.

*****

*****
forall (i : nat) (vnl : list (list bool)) (_ : le i (length vnl)), eq nil nil
+++++
intros i vnl Hn.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.

*****
Hn : le i (length vnl)
vnl : list (list bool)
i : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].

*****
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
forall (i : nat) (vnl : list (list bool)) (_ : le (Init.Nat.add (S n) i) (length vnl)), eq (map (fun f : BC => sem f vnl nil) (map (proj (Init.Nat.add (S n) i) O) (seq i (S n)))) (firstn (S n) (skipn i vnl))
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.

*****
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
forall (i : nat) (vnl : list (list bool)) (_ : le (S (Init.Nat.add n i)) (length vnl)), eq (cons (if Nat.leb i (Init.Nat.add n i) then nth i vnl nil else match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end) (map (fun f : BC => sem f vnl nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i vnl with | nil => nil | cons a l => cons a (firstn n l) end
+++++
intros i vnl Hn.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.

*****
Hn : le (S (Init.Nat.add n i)) (length vnl)
vnl : list (list bool)
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (if Nat.leb i (Init.Nat.add n i) then nth i vnl nil else match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end) (map (fun f : BC => sem f vnl nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i vnl with | nil => nil | cons a l => cons a (firstn n l) end
+++++
destruct vnl as [ | v vnl].
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].

*****
Hn : le (S (Init.Nat.add n i)) (length nil)
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (if Nat.leb i (Init.Nat.add n i) then nth i nil nil else match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end) (map (fun f : BC => sem f nil nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i nil with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl in *.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.

*****
Hn : le (S (Init.Nat.add n i)) O
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (if Nat.leb i (Init.Nat.add n i) then match i with | O | _ => nil end else match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end) (map (fun f : BC => sem f nil nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i nil with | nil => nil | cons a l => cons a (firstn n l) end
+++++
contradict Hn.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
contradict Hn.

*****
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
not (le (S (Init.Nat.add n i)) O)
+++++
omega.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].

*****
Hn : le (S (Init.Nat.add n i)) (length (cons v vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (if Nat.leb i (Init.Nat.add n i) then nth i (cons v vnl) nil else match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end) (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl in *.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.

*****
Hn : le (S (Init.Nat.add n i)) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (if Nat.leb i (Init.Nat.add n i) then match i with | O => v | S m => nth m vnl nil end else match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end) (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
case_eq (leb i (n+i)).
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).

*****
Hn : le (S (Init.Nat.add n i)) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
forall _ : eq (Nat.leb i (Init.Nat.add n i)) true, eq (cons match i with | O => v | S m => nth m vnl nil end (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
intro Hi.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.

*****
Hi : eq (Nat.leb i (Init.Nat.add n i)) true
Hn : le (S (Init.Nat.add n i)) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons match i with | O => v | S m => nth m vnl nil end (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
destruct i as [ | i].
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].

*****
Hi : eq (Nat.leb O (Init.Nat.add n O)) true
Hn : le (S (Init.Nat.add n O)) (S (length vnl))
vnl : list (list bool)
v : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons v (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n O)) O) (seq (S O) n)))) match skipn O (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.

*****
Hi : eq (Nat.leb O (Init.Nat.add n O)) true
Hn : le (S (Init.Nat.add n O)) (S (length vnl))
vnl : list (list bool)
v : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons v (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n O)) O) (seq (S O) n)))) (cons v (firstn n vnl))
+++++
f_equal.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
f_equal.

*****
Hi : eq (Nat.leb O (Init.Nat.add n O)) true
Hn : le (S (Init.Nat.add n O)) (S (length vnl))
vnl : list (list bool)
v : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n O)) O) (seq (S O) n))) (firstn n vnl)
+++++
cutrewrite (S (n+0) = n+1).
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (n+0) = n+1).

*****
Hi : eq (Nat.leb O (Init.Nat.add n O)) true
Hn : le (S (Init.Nat.add n O)) (S (length vnl))
vnl : list (list bool)
v : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (Init.Nat.add n (S O)) O) (seq (S O) n))) (firstn n vnl)
+++++
apply IH.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (n+0) = n+1).
apply IH.

*****
Hi : eq (Nat.leb O (Init.Nat.add n O)) true
Hn : le (S (Init.Nat.add n O)) (S (length vnl))
vnl : list (list bool)
v : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
le (Init.Nat.add n (S O)) (length (cons v vnl))
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (n+0) = n+1).
apply IH.
simpl.

*****
Hi : eq (Nat.leb O (Init.Nat.add n O)) true
Hn : le (S (Init.Nat.add n O)) (S (length vnl))
vnl : list (list bool)
v : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
le (Init.Nat.add n (S O)) (S (length vnl))
+++++
omega.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (n+0) = n+1).

*****
Hi : eq (Nat.leb O (Init.Nat.add n O)) true
Hn : le (S (Init.Nat.add n O)) (S (length vnl))
vnl : list (list bool)
v : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (S (Init.Nat.add n O)) (Init.Nat.add n (S O))
+++++
trivial.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n (S i))) O) (seq (S (S i)) n)))) match skipn (S i) (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n (S i))) O) (seq (S (S i)) n)))) match skipn i vnl with | nil => nil | cons a l => cons a (firstn n l) end
+++++
trivial.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n (S i))) O) (seq (S (S i)) n)))) match skipn i vnl with | nil => nil | cons a l => cons a (firstn n l) end
+++++
cutrewrite (S (n + S i) = n + S (S i)).
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (Init.Nat.add n (S (S i))) O) (seq (S (S i)) n)))) match skipn i vnl with | nil => nil | cons a l => cons a (firstn n l) end
+++++
rewrite IH.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (firstn n (skipn (S (S i)) (cons v vnl)))) match skipn i vnl with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (firstn n match vnl with | nil => nil | cons _ l => skipn i l end)) match skipn i vnl with | nil => nil | cons a l => cons a (firstn n l) end
+++++
destruct vnl as [ | v1 vnl].
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length nil))
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i nil nil) (firstn n nil)) match skipn i nil with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl in *.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.

*****
Hi : eq\n match Init.Nat.add n (S i) with\n | O => false\n | S m' => Nat.leb i m'\n end true
Hn : le (S (Init.Nat.add n (S i))) (S O)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons match i with | O | _ => nil end (firstn n nil)) match skipn i nil with | nil => nil | cons a l => cons a (firstn n l) end
+++++
contradict Hn.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.
contradict Hn.

*****
Hi : eq\n match Init.Nat.add n (S i) with\n | O => false\n | S m' => Nat.leb i m'\n end true
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
not (le (S (Init.Nat.add n (S i))) (S O))
+++++
omega.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length (cons v1 vnl)))
vnl : list (list bool)
v,v1 : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i (cons v1 vnl) nil) (firstn n (skipn i vnl))) match skipn i (cons v1 vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl in *.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.

*****
Hi : eq\n match Init.Nat.add n (S i) with\n | O => false\n | S m' => Nat.leb i m'\n end true
Hn : le (S (Init.Nat.add n (S i))) (S (S (length vnl)))
vnl : list (list bool)
v,v1 : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons match i with | O => v1 | S m => nth m vnl nil end (firstn n (skipn i vnl))) match skipn i (cons v1 vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
destruct i as [ | i].
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.
destruct i as [ | i].

*****
Hi : eq\n match Init.Nat.add n (S O) with\n | O => false\n | S m' => Nat.leb O m'\n end true
Hn : le (S (Init.Nat.add n (S O))) (S (S (length vnl)))
vnl : list (list bool)
v,v1 : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons v1 (firstn n (skipn O vnl))) match skipn O (cons v1 vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.
destruct i as [ | i].
simpl.

*****
Hi : eq\n match Init.Nat.add n (S O) with\n | O => false\n | S m' => Nat.leb O m'\n end true
Hn : le (S (Init.Nat.add n (S O))) (S (S (length vnl)))
vnl : list (list bool)
v,v1 : list bool
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons v1 (firstn n vnl)) (cons v1 (firstn n vnl))
+++++
trivial.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.
destruct i as [ | i].

*****
Hi : eq\n match Init.Nat.add n (S (S i)) with\n | O => false\n | S m' => Nat.leb (S i) m'\n end true
Hn : le (S (Init.Nat.add n (S (S i)))) (S (S (length vnl)))
vnl : list (list bool)
v,v1 : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (firstn n (skipn (S i) vnl))) match skipn (S i) (cons v1 vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.
destruct i as [ | i].
simpl.

*****
Hi : eq\n match Init.Nat.add n (S (S i)) with\n | O => false\n | S m' => Nat.leb (S i) m'\n end true
Hn : le (S (Init.Nat.add n (S (S i)))) (S (S (length vnl)))
vnl : list (list bool)
v,v1 : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (firstn n match vnl with | nil => nil | cons _ l => skipn i l end)) match skipn i vnl with | nil => nil | cons a l => cons a (firstn n l) end
+++++
rewrite <- cons_skipn with (d:=nil).
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).

*****
Hi : eq\n match Init.Nat.add n (S (S i)) with\n | O => false\n | S m' => Nat.leb (S i) m'\n end true
Hn : le (S (Init.Nat.add n (S (S i)))) (S (S (length vnl)))
vnl : list (list bool)
v,v1 : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons (nth i vnl nil) (firstn n match vnl with | nil => nil | cons _ l => skipn i l end)) (cons (nth i vnl nil) (firstn n (skipn (S i) vnl)))
+++++
trivial.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.
destruct vnl as [ | v1 vnl].
simpl in *.
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).

*****
Hi : eq\n match Init.Nat.add n (S (S i)) with\n | O => false\n | S m' => Nat.leb (S i) m'\n end true
Hn : le (S (Init.Nat.add n (S (S i)))) (S (S (length vnl)))
vnl : list (list bool)
v,v1 : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
lt i (length vnl)
+++++
omega.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
le (Init.Nat.add n (S (S i))) (length (cons v vnl))
+++++
simpl.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).
rewrite IH.
simpl.

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
le (Init.Nat.add n (S (S i))) (S (length vnl))
+++++
omega.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
destruct i as [ | i].
simpl.
trivial.
cutrewrite (S (n + S i) = n + S (S i)).

*****
Hi : eq (Nat.leb (S i) (Init.Nat.add n (S i))) true
Hn : le (S (Init.Nat.add n (S i))) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (S (Init.Nat.add n (S i))) (Init.Nat.add n (S (S i)))
+++++
trivial.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).

*****
Hn : le (S (Init.Nat.add n i)) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
forall _ : eq (Nat.leb i (Init.Nat.add n i)) false, eq (cons match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
intro Hi.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.

*****
Hi : eq (Nat.leb i (Init.Nat.add n i)) false
Hn : le (S (Init.Nat.add n i)) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
apply leb_complete_conv in Hi.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
apply leb_complete_conv in Hi.

*****
Hi : lt (Init.Nat.add n i) i
Hn : le (S (Init.Nat.add n i)) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
eq (cons match Init.Nat.sub i (S (Init.Nat.add n i)) with | O | _ => nil end (map (fun f : BC => sem f (cons v vnl) nil) (map (proj (S (Init.Nat.add n i)) O) (seq (S i) n)))) match skipn i (cons v vnl) with | nil => nil | cons a l => cons a (firstn n l) end
+++++
contradict Hi.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].
simpl.
intros i vnl Hn.
destruct vnl as [ | v vnl].
simpl in *.
case_eq (leb i (n+i)).
intro Hi.
apply leb_complete_conv in Hi.
contradict Hi.

*****
Hn : le (S (Init.Nat.add n i)) (S (length vnl))
vnl : list (list bool)
v : list bool
i : nat
IH : forall (i : nat) (vnl : list (list bool))\n (_ : le (Init.Nat.add n i) (length vnl)),\neq\n (map (fun f : BC => sem f vnl nil)\n (map (proj (Init.Nat.add n i) O) (seq i n)))\n (firstn n (skipn i vnl))
n : nat
*****
not (lt (Init.Nat.add n i) i)
+++++
omega.
-----
Lemma map_proj_seq_normal_gen : forall n i vnl, n+i <= length vnl -> map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) = firstn n (skipn i vnl).
Proof.
induction n as [ | n IH].

*****

*****

+++++
Qed.
-----
Lemma map_proj_seq_normal :\n  forall n vnl,\n  map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) =\n  firstn n vnl ++ repeat (n - length vnl) nil.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.

*****

*****
forall (n : nat) (vnl : list (list bool)), eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
+++++
Proof.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.

*****

*****
forall (n : nat) (vnl : list (list bool)), eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
+++++
intros n vnl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.

*****
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
+++++
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].

*****
H : le (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
+++++
cutrewrite (n - length vnl = 0).
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
cutrewrite (n - length vnl = 0).

*****
H : le (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (app (firstn n vnl) (repeat O nil))
+++++
generalize (map_proj_seq_normal_gen n 0 vnl H).
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
cutrewrite (n - length vnl = 0).
generalize (map_proj_seq_normal_gen n 0 vnl H).

*****
H : le (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl nil) (map (proj (Init.Nat.add n O) O) (seq O n))) (firstn n (skipn O vnl)), eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (app (firstn n vnl) (repeat O nil))
+++++
simpl_list.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
cutrewrite (n - length vnl = 0).
generalize (map_proj_seq_normal_gen n 0 vnl H).
simpl_list.

*****
H : le (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl nil) (map (proj (Init.Nat.add n O) O) (seq O n))) (firstn n (skipn O vnl)), eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n vnl)
+++++
rewrite <- plus_n_O.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
cutrewrite (n - length vnl = 0).
generalize (map_proj_seq_normal_gen n 0 vnl H).
simpl_list.
rewrite <- plus_n_O.

*****
H : le (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n (skipn O vnl)), eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n vnl)
+++++
trivial.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
cutrewrite (n - length vnl = 0).

*****
H : le (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (Init.Nat.sub n (length vnl)) O
+++++
omega.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].

*****
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
+++++
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).

*****
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.

*****
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
le (Init.Nat.add n O) (length (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
rewrite app_length.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
rewrite app_length.

*****
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
le (Init.Nat.add n O) (Init.Nat.add (length vnl) (length (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
rewrite length_repeat.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
rewrite app_length.
rewrite length_repeat.

*****
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
le (Init.Nat.add n O) (Init.Nat.add (length vnl) (Init.Nat.sub n (length vnl)))
+++++
omega.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.

*****
H0 : le (Init.Nat.add n O)\n (length (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).

*****
H0 : le (Init.Nat.add n O)\n (length (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
forall _ : eq (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) (map (proj (Init.Nat.add n O) O) (seq O n))) (firstn n (skipn O (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))), eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
simpl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.

*****
H0 : le (Init.Nat.add n O)\n (length (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
forall _ : eq (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) (map (proj (Init.Nat.add n O) O) (seq O n))) (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))), eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
rewrite <- plus_n_O.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.

*****
H0 : le (Init.Nat.add n O)\n (length (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
forall _ : eq (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) (map (proj n O) (seq O n))) (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))), eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
intro H1.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.

*****
H1 : eq\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)\n (map (proj n O) (seq O n)))\n (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
H0 : le (Init.Nat.add n O)\n (length (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
rewrite <- H1.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.

*****
H1 : eq\n (map\n (fun f : BC =>\n sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil)\n (map (proj n O) (seq O n)))\n (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
H0 : le (Init.Nat.add n O)\n (length (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) (map (proj n O) (seq O n)))
+++++
clear H H0 H1.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.

*****
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f vnl nil) (map (proj n O) (seq O n))) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) (map (proj n O) (seq O n)))
+++++
rewrite map_sem_repeat with (n:=n) (s:=0).
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).

*****
vnl : list (list bool)
n : nat
*****
eq (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app nil (repeat (Init.Nat.sub O (length nil)) nil))) (map (proj n O) (seq O n))) (map (fun f : BC => sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) nil) (map (proj n O) (seq O n)))
+++++
trivial.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).

*****
vnl : list (list bool)
n : nat
*****
forall (f : BC) (_ : In f (map (proj n O) (seq O n))), eq (arities f) (ok_arities n O)
+++++
intros f H.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.

*****
H : In f (map (proj n O) (seq O n))
f : BC
vnl : list (list bool)
n : nat
*****
eq (arities f) (ok_arities n O)
+++++
rewrite in_map_iff in H.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.

*****
H : ex (fun x : nat => and (eq (proj n O x) f) (In x (seq O n)))
f : BC
vnl : list (list bool)
n : nat
*****
eq (arities f) (ok_arities n O)
+++++
destruct H as [i [H1 H2] ].
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].

*****
H2 : In i (seq O n)
H1 : eq (proj n O i) f
i : nat
f : BC
vnl : list (list bool)
n : nat
*****
eq (arities f) (ok_arities n O)
+++++
rewrite in_seq_iff in H2.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.

*****
H2 : and (le O i) (lt i (Init.Nat.add O n))
H1 : eq (proj n O i) f
i : nat
f : BC
vnl : list (list bool)
n : nat
*****
eq (arities f) (ok_arities n O)
+++++
subst f.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.

*****
H2 : and (le O i) (lt i (Init.Nat.add O n))
i : nat
vnl : list (list bool)
n : nat
*****
eq (arities (proj n O i)) (ok_arities n O)
+++++
simpl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.

*****
H2 : and (le O i) (lt i (Init.Nat.add O n))
i : nat
vnl : list (list bool)
n : nat
*****
eq (if match Init.Nat.add n O with | O => false | S m' => Nat.leb i m' end then ok_arities n O else error_proj n O i) (ok_arities n O)
+++++
rewrite <- plus_n_O.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.

*****
H2 : and (le O i) (lt i (Init.Nat.add O n))
i : nat
vnl : list (list bool)
n : nat
*****
eq (if match n with | O => false | S m' => Nat.leb i m' end then ok_arities n O else error_proj n O i) (ok_arities n O)
+++++
destruct n.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.
destruct n.

*****
H2 : and (le O i) (lt i (Init.Nat.add O O))
i : nat
vnl : list (list bool)
*****
eq (error_proj O O i) (ok_arities O O)
+++++
contradict H2.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.
destruct n.
contradict H2.

*****
i : nat
vnl : list (list bool)
*****
not (and (le O i) (lt i (Init.Nat.add O O)))
+++++
omega.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.
destruct n.

*****
H2 : and (le O i) (lt i (Init.Nat.add O (S n)))
i : nat
vnl : list (list bool)
n : nat
*****
eq (if Nat.leb i n then ok_arities (S n) O else error_proj (S n) O i) (ok_arities (S n) O)
+++++
case_eq (leb i n).
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.
destruct n.
case_eq (leb i n).

*****
H2 : and (le O i) (lt i (Init.Nat.add O (S n)))
i : nat
vnl : list (list bool)
n : nat
*****
forall _ : eq (Nat.leb i n) true, eq (ok_arities (S n) O) (ok_arities (S n) O)
+++++
trivial.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.
destruct n.
case_eq (leb i n).

*****
H2 : and (le O i) (lt i (Init.Nat.add O (S n)))
i : nat
vnl : list (list bool)
n : nat
*****
forall _ : eq (Nat.leb i n) false, eq (error_proj (S n) O i) (ok_arities (S n) O)
+++++
intro H.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.
destruct n.
case_eq (leb i n).
intro H.

*****
H : eq (Nat.leb i n) false
H2 : and (le O i) (lt i (Init.Nat.add O (S n)))
i : nat
vnl : list (list bool)
n : nat
*****
eq (error_proj (S n) O i) (ok_arities (S n) O)
+++++
rewrite leb_iff_conv in H.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.
destruct n.
case_eq (leb i n).
intro H.
rewrite leb_iff_conv in H.

*****
H : lt n i
H2 : and (le O i) (lt i (Init.Nat.add O (S n)))
i : nat
vnl : list (list bool)
n : nat
*****
eq (error_proj (S n) O i) (ok_arities (S n) O)
+++++
contradict H.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
assert (n + 0 <= length (vnl ++ repeat (n - length vnl) nil)) as H0.
generalize (map_proj_seq_normal_gen n 0 (vnl ++ repeat (n - length vnl) nil) H0).
simpl.
rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
rewrite map_sem_repeat with (n:=n) (s:=0).
intros f H.
rewrite in_map_iff in H.
destruct H as [i [H1 H2] ].
rewrite in_seq_iff in H2.
subst f.
simpl.
rewrite <- plus_n_O.
destruct n.
case_eq (leb i n).
intro H.
rewrite leb_iff_conv in H.
contradict H.

*****
H2 : and (le O i) (lt i (Init.Nat.add O (S n)))
i : nat
vnl : list (list bool)
n : nat
*****
not (lt n i)
+++++
omega.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).

*****
H : gt (Init.Nat.add n O) (length vnl)
vnl : list (list bool)
n : nat
*****
eq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))) (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
+++++
clear H.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.

*****
vnl : list (list bool)
n : nat
*****
eq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))) (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
+++++
revert vnl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.

*****
n : nat
*****
forall vnl : list (list bool), eq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil))) (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
+++++
induction n as [ | n IH].
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].

*****

*****
forall vnl : list (list bool), eq (firstn O (app vnl (repeat (Init.Nat.sub O (length vnl)) nil))) (app (firstn O vnl) (repeat (Init.Nat.sub O (length vnl)) nil))
+++++
simpl in *.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.

*****

*****
forall _ : list (list bool), eq nil nil
+++++
intro vnl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.

*****
vnl : list (list bool)
*****
eq nil nil
+++++
trivial.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].

*****
IH : forall vnl : list (list bool),\neq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))\n (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
n : nat
*****
forall vnl : list (list bool), eq (firstn (S n) (app vnl (repeat (Init.Nat.sub (S n) (length vnl)) nil))) (app (firstn (S n) vnl) (repeat (Init.Nat.sub (S n) (length vnl)) nil))
+++++
simpl in *.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.

*****
IH : forall vnl : list (list bool),\neq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))\n (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
n : nat
*****
forall vnl : list (list bool), eq match app vnl (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil) with | nil => nil | cons a l => cons a (firstn n l) end (app match vnl with | nil => nil | cons a l => cons a (firstn n l) end (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil))
+++++
intro vnl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.

*****
vnl : list (list bool)
IH : forall vnl : list (list bool),\neq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))\n (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
n : nat
*****
eq match app vnl (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil) with | nil => nil | cons a l => cons a (firstn n l) end (app match vnl with | nil => nil | cons a l => cons a (firstn n l) end (repeat match length vnl with | O => S n | S l => Init.Nat.sub n l end nil))
+++++
destruct vnl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.
destruct vnl.

*****
IH : forall vnl : list (list bool),\neq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))\n (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
n : nat
*****
eq match app nil (repeat match length nil with | O => S n | S l => Init.Nat.sub n l end nil) with | nil => nil | cons a l => cons a (firstn n l) end (app nil (repeat match length nil with | O => S n | S l => Init.Nat.sub n l end nil))
+++++
simpl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.
destruct vnl.
simpl.

*****
IH : forall vnl : list (list bool),\neq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))\n (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
n : nat
*****
eq (cons nil (firstn n (repeat n nil))) (cons nil (repeat n nil))
+++++
clear IH.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.
destruct vnl.
simpl.
clear IH.

*****
n : nat
*****
eq (cons nil (firstn n (repeat n nil))) (cons nil (repeat n nil))
+++++
f_equal.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.
destruct vnl.
simpl.
clear IH.
f_equal.

*****
n : nat
*****
eq (firstn n (repeat n nil)) (repeat n nil)
+++++
apply firstn_repeat_le.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.
destruct vnl.
simpl.
clear IH.
f_equal.
apply firstn_repeat_le.

*****
n : nat
*****
le n n
+++++
trivial.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.
destruct vnl.

*****
vnl : list (list bool)
l : list bool
IH : forall vnl : list (list bool),\neq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))\n (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
n : nat
*****
eq match app (cons l vnl) (repeat match length (cons l vnl) with | O => S n | S l => Init.Nat.sub n l end nil) with | nil => nil | cons a l => cons a (firstn n l) end (app (cons l (firstn n vnl)) (repeat match length (cons l vnl) with | O => S n | S l => Init.Nat.sub n l end nil))
+++++
simpl.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].
transitivity (firstn n (vnl ++ repeat (n - length vnl) nil)).
clear H.
revert vnl.
induction n as [ | n IH].
simpl in *.
intro vnl.
destruct vnl.
simpl.

*****
vnl : list (list bool)
l : list bool
IH : forall vnl : list (list bool),\neq (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))\n (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil))
n : nat
*****
eq (cons l (firstn n (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)))) (cons l (app (firstn n vnl) (repeat (Init.Nat.sub n (length vnl)) nil)))
+++++
congruence.
-----
Lemma map_proj_seq_normal : forall n vnl, map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) = firstn n vnl ++ repeat (n - length vnl) nil.
Proof.
intros n vnl.
destruct (le_gt_dec (n+0) (length vnl)) as [H | H].

*****

*****

+++++
Qed.
-----
Lemma map_proj_seq_safe_gen :\n  forall n s i vnl vsl,\n  s+i <= length vsl ->\n  map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) =\n  firstn s (skipn i vsl).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).

*****

*****
forall (n s i : nat) (vnl vsl : list (list bool)) (_ : le (Init.Nat.add s i) (length vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s))) (firstn s (skipn i vsl))
+++++
Proof.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.

*****

*****
forall (n s i : nat) (vnl vsl : list (list bool)) (_ : le (Init.Nat.add s i) (length vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s))) (firstn s (skipn i vsl))
+++++
intros n s.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.

*****
n,s : nat
*****
forall (i : nat) (vnl vsl : list (list bool)) (_ : le (Init.Nat.add s i) (length vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s))) (firstn s (skipn i vsl))
+++++
revert n.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.

*****
s : nat
*****
forall (n i : nat) (vnl vsl : list (list bool)) (_ : le (Init.Nat.add s i) (length vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s))) (firstn s (skipn i vsl))
+++++
induction s as [ | s IH].
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].

*****

*****
forall (n i : nat) (vnl vsl : list (list bool)) (_ : le (Init.Nat.add O i) (length vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n (Init.Nat.add O i)) (seq (Init.Nat.add n i) O))) (firstn O (skipn i vsl))
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.

*****

*****
forall (_ : nat) (i : nat) (_ : list (list bool)) (vsl : list (list bool)) (_ : le i (length vsl)), eq nil nil
+++++
intros n i vnl vsl Hs.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.

*****
Hs : le i (length vsl)
vnl,vsl : list (list bool)
n,i : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].

*****
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
forall (n i : nat) (vnl vsl : list (list bool)) (_ : le (Init.Nat.add (S s) i) (length vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n (Init.Nat.add (S s) i)) (seq (Init.Nat.add n i) (S s)))) (firstn (S s) (skipn i vsl))
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.

*****
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
forall (n i : nat) (vnl vsl : list (list bool)) (_ : le (S (Init.Nat.add s i)) (length vsl)), eq (cons (if match n with | O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then nth (Init.Nat.add n i) vnl nil else nth (Init.Nat.sub (Init.Nat.add n i) n) vsl nil) (map (fun f : BC => sem f vnl vsl) (map (proj n (S (Init.Nat.add s i))) (seq (S (Init.Nat.add n i)) s)))) match skipn i vsl with | nil => nil | cons a l => cons a (firstn s l) end
+++++
intros n i vnl vsl Hs.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.

*****
Hs : le (S (Init.Nat.add s i)) (length vsl)
vnl,vsl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (if match n with | O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then nth (Init.Nat.add n i) vnl nil else nth (Init.Nat.sub (Init.Nat.add n i) n) vsl nil) (map (fun f : BC => sem f vnl vsl) (map (proj n (S (Init.Nat.add s i))) (seq (S (Init.Nat.add n i)) s)))) match skipn i vsl with | nil => nil | cons a l => cons a (firstn s l) end
+++++
destruct vsl as [ | v vsl].
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].

*****
Hs : le (S (Init.Nat.add s i)) (length nil)
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (if match n with | O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then nth (Init.Nat.add n i) vnl nil else nth (Init.Nat.sub (Init.Nat.add n i) n) nil nil) (map (fun f : BC => sem f vnl nil) (map (proj n (S (Init.Nat.add s i))) (seq (S (Init.Nat.add n i)) s)))) match skipn i nil with | nil => nil | cons a l => cons a (firstn s l) end
+++++
simpl in *.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.

*****
Hs : le (S (Init.Nat.add s i)) O
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (if match n with | O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then nth (Init.Nat.add n i) vnl nil else match Init.Nat.sub (Init.Nat.add n i) n with | O | _ => nil end) (map (fun f : BC => sem f vnl nil) (map (proj n (S (Init.Nat.add s i))) (seq (S (Init.Nat.add n i)) s)))) match skipn i nil with | nil => nil | cons a l => cons a (firstn s l) end
+++++
contradict Hs.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
contradict Hs.

*****
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
not (le (S (Init.Nat.add s i)) O)
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].

*****
Hs : le (S (Init.Nat.add s i)) (length (cons v vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (if match n with | O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then nth (Init.Nat.add n i) vnl nil else nth (Init.Nat.sub (Init.Nat.add n i) n) (cons v vsl) nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj n (S (Init.Nat.add s i))) (seq (S (Init.Nat.add n i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
simpl in *.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.

*****
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (if match n with | O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then nth (Init.Nat.add n i) vnl nil else match Init.Nat.sub (Init.Nat.add n i) n with | O => v | S m => nth m vsl nil end) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj n (S (Init.Nat.add s i))) (seq (S (Init.Nat.add n i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
destruct n as [ | n].
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].

*****
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons match Init.Nat.sub (Init.Nat.add O i) O with | O => v | S m => nth m vsl nil end (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s i))) (seq (S (Init.Nat.add O i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
cutrewrite (0+i-0 = i).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).

*****
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons match i with | O => v | S m => nth m vsl nil end (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s i))) (seq (S (Init.Nat.add O i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
destruct i as [ |i].
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].

*****
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons v (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s O))) (seq (S (Init.Nat.add O O)) s)))) match skipn O (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.

*****
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons v (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s O))) (seq (S O) s)))) (cons v (firstn s vsl))
+++++
f_equal.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
f_equal.

*****
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s O))) (seq (S O) s))) (firstn s vsl)
+++++
cutrewrite (S (s+0) = s+1).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).

*****
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (Init.Nat.add s (S O))) (seq (S O) s))) (firstn s vsl)
+++++
apply IH.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).
apply IH.

*****
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
le (Init.Nat.add s (S O)) (length (cons v vsl))
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).
apply IH.
simpl.

*****
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
le (Init.Nat.add s (S O)) (S (length vsl))
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).

*****
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (S (Init.Nat.add s O)) (Init.Nat.add s (S O))
+++++
trivial.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (nth i vsl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s (S i)))) (seq (S (Init.Nat.add O (S i))) s)))) match skipn (S i) (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (nth i vsl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s (S i)))) (seq (S (S i)) s)))) match skipn i vsl with | nil => nil | cons a l => cons a (firstn s l) end
+++++
rewrite <- cons_skipn with (d:=nil).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
rewrite <- cons_skipn with (d:=nil).

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (nth i vsl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s (S i)))) (seq (S (S i)) s)))) (cons (nth i vsl nil) (firstn s (skipn (S i) vsl)))
+++++
f_equal.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (S (Init.Nat.add s (S i)))) (seq (S (S i)) s))) (firstn s (skipn (S i) vsl))
+++++
cutrewrite (S (s + S i) = s + S (S i)).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj O (Init.Nat.add s (S (S i)))) (seq (S (S i)) s))) (firstn s (skipn (S i) vsl))
+++++
rewrite IH.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).
rewrite IH.

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (firstn s (skipn (S (S i)) (cons v vsl))) (firstn s (skipn (S i) vsl))
+++++
f_equal.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).
rewrite IH.

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
le (Init.Nat.add s (S (S i))) (length (cons v vsl))
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).
rewrite IH.
simpl.

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
le (Init.Nat.add s (S (S i))) (S (length vsl))
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (S (Init.Nat.add s (S i))) (Init.Nat.add s (S (S i)))
+++++
trivial.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).
destruct i as [ |i].
simpl.
rewrite <- cons_skipn with (d:=nil).

*****
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
lt i (length vsl)
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
cutrewrite (0+i-0 = i).

*****
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (Init.Nat.sub (Init.Nat.add O i) O) i
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].

*****
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (if Nat.leb (Init.Nat.add (S n) i) n then nth (Init.Nat.add (S n) i) vnl nil else match Init.Nat.sub (Init.Nat.add (S n) i) (S n) with | O => v | S m => nth m vsl nil end) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s i))) (seq (S (Init.Nat.add (S n) i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
case_eq (leb (S n + i) n).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).

*****
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
forall _ : eq (Nat.leb (Init.Nat.add (S n) i) n) true, eq (cons (nth (Init.Nat.add (S n) i) vnl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s i))) (seq (S (Init.Nat.add (S n) i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
intro H.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.

*****
H : eq (Nat.leb (Init.Nat.add (S n) i) n) true
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (nth (Init.Nat.add (S n) i) vnl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s i))) (seq (S (Init.Nat.add (S n) i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
apply leb_complete in H.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
apply leb_complete in H.

*****
H : le (Init.Nat.add (S n) i) n
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (nth (Init.Nat.add (S n) i) vnl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s i))) (seq (S (Init.Nat.add (S n) i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
contradict H.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
apply leb_complete in H.
contradict H.

*****
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
not (le (Init.Nat.add (S n) i) n)
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).

*****
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
forall _ : eq (Nat.leb (Init.Nat.add (S n) i) n) false, eq (cons match Init.Nat.sub (Init.Nat.add (S n) i) (S n) with | O => v | S m => nth m vsl nil end (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s i))) (seq (S (Init.Nat.add (S n) i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
intro H.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.

*****
H : eq (Nat.leb (Init.Nat.add (S n) i) n) false
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons match Init.Nat.sub (Init.Nat.add (S n) i) (S n) with | O => v | S m => nth m vsl nil end (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s i))) (seq (S (Init.Nat.add (S n) i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
cutrewrite (S n + i - S n = i).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).

*****
H : eq (Nat.leb (Init.Nat.add (S n) i) n) false
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons match i with | O => v | S m => nth m vsl nil end (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s i))) (seq (S (Init.Nat.add (S n) i)) s)))) match skipn i (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
destruct i as [ | i].
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons v (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s O))) (seq (S (Init.Nat.add (S n) O)) s)))) match skipn O (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons v (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s O))) (seq (S (S (Init.Nat.add n O))) s)))) (cons v (firstn s vsl))
+++++
f_equal.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
f_equal.

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s O))) (seq (S (S (Init.Nat.add n O))) s))) (firstn s vsl)
+++++
cutrewrite (S (s+0) = s+1).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (Init.Nat.add s (S O))) (seq (S (S (Init.Nat.add n O))) s))) (firstn s vsl)
+++++
cutrewrite (S (S (n+0)) = S n + 1).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).
cutrewrite (S (S (n+0)) = S n + 1).

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (Init.Nat.add s (S O))) (seq (Init.Nat.add (S n) (S O)) s))) (firstn s vsl)
+++++
apply IH.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).
cutrewrite (S (S (n+0)) = S n + 1).
apply IH.

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
le (Init.Nat.add s (S O)) (length (cons v vsl))
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).
cutrewrite (S (S (n+0)) = S n + 1).
apply IH.
simpl.

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
le (Init.Nat.add s (S O)) (S (length vsl))
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).
cutrewrite (S (S (n+0)) = S n + 1).

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (S (S (Init.Nat.add n O))) (Init.Nat.add (S n) (S O))
+++++
ring.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
f_equal.
cutrewrite (S (s+0) = s+1).

*****
H : eq (Nat.leb (Init.Nat.add (S n) O) n) false
Hs : le (S (Init.Nat.add s O)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (S (Init.Nat.add s O)) (Init.Nat.add s (S O))
+++++
trivial.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (nth i vsl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s (S i)))) (seq (S (Init.Nat.add (S n) (S i))) s)))) match skipn (S i) (cons v vsl) with | nil => nil | cons a l => cons a (firstn s l) end
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (nth i vsl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s (S i)))) (seq (S (S (Init.Nat.add n (S i)))) s)))) match skipn i vsl with | nil => nil | cons a l => cons a (firstn s l) end
+++++
rewrite <- cons_skipn with (d:=nil).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (cons (nth i vsl nil) (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s (S i)))) (seq (S (S (Init.Nat.add n (S i)))) s)))) (cons (nth i vsl nil) (firstn s (skipn (S i) vsl)))
+++++
f_equal.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (S (Init.Nat.add s (S i)))) (seq (S (S (Init.Nat.add n (S i)))) s))) (firstn s (skipn (S i) vsl))
+++++
cutrewrite (S (s + S i) = s + S (S i)).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (Init.Nat.add s (S (S i)))) (seq (S (S (Init.Nat.add n (S i)))) s))) (firstn s (skipn (S i) vsl))
+++++
cutrewrite (S (S (n + S i)) = (S n + S (S i))).
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).
cutrewrite (S (S (n + S i)) = (S n + S (S i))).

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (map (fun f : BC => sem f vnl (cons v vsl)) (map (proj (S n) (Init.Nat.add s (S (S i)))) (seq (Init.Nat.add (S n) (S (S i))) s))) (firstn s (skipn (S i) vsl))
+++++
rewrite IH.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).
cutrewrite (S (S (n + S i)) = (S n + S (S i))).
rewrite IH.

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (firstn s (skipn (S (S i)) (cons v vsl))) (firstn s (skipn (S i) vsl))
+++++
trivial.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).
cutrewrite (S (S (n + S i)) = (S n + S (S i))).
rewrite IH.

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
le (Init.Nat.add s (S (S i))) (length (cons v vsl))
+++++
simpl.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).
cutrewrite (S (S (n + S i)) = (S n + S (S i))).
rewrite IH.
simpl.

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
le (Init.Nat.add s (S (S i))) (S (length vsl))
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).
cutrewrite (S (S (n + S i)) = (S n + S (S i))).

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (S (S (Init.Nat.add n (S i)))) (Init.Nat.add (S n) (S (S i)))
+++++
ring.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).
f_equal.
cutrewrite (S (s + S i) = s + S (S i)).

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (S (Init.Nat.add s (S i))) (Init.Nat.add s (S (S i)))
+++++
trivial.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).
destruct i as [ | i].
simpl.
rewrite <- cons_skipn with (d:=nil).

*****
H : eq (Nat.leb (Init.Nat.add (S n) (S i)) n) false
Hs : le (S (Init.Nat.add s (S i))) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
lt i (length vsl)
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].
simpl.
intros n i vnl vsl Hs.
destruct vsl as [ | v vsl].
simpl in *.
destruct n as [ | n].
case_eq (leb (S n + i) n).
intro H.
cutrewrite (S n + i - S n = i).

*****
H : eq (Nat.leb (Init.Nat.add (S n) i) n) false
Hs : le (S (Init.Nat.add s i)) (S (length vsl))
vsl : list (list bool)
v : list bool
vnl : list (list bool)
n,i : nat
IH : forall (n i : nat) (vnl vsl : list (list bool))\n (_ : le (Init.Nat.add s i) (length vsl)),\neq\n (map (fun f : BC => sem f vnl vsl)\n (map (proj n (Init.Nat.add s i)) (seq (Init.Nat.add n i) s)))\n (firstn s (skipn i vsl))
s : nat
*****
eq (Init.Nat.sub (Init.Nat.add (S n) i) (S n)) i
+++++
omega.
-----
Lemma map_proj_seq_safe_gen : forall n s i vnl vsl, s+i <= length vsl -> map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) = firstn s (skipn i vsl).
Proof.
intros n s.
revert n.
induction s as [ | s IH].

*****

*****

+++++
Qed.
-----
Lemma map_proj_seq_safe :\n  forall n s vnl vsl,\n  map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) =\n  firstn s vsl ++ repeat (s - length vsl) nil.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.

*****

*****
forall (n s : nat) (vnl vsl : list (list bool)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
Proof.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.

*****

*****
forall (n s : nat) (vnl vsl : list (list bool)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
intros n s vnl vsl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.

*****
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].

*****
H : le (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
cutrewrite (s - length vsl = 0).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
cutrewrite (s - length vsl = 0).

*****
H : le (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (app (firstn s vsl) (repeat O nil))
+++++
generalize (map_proj_seq_safe_gen n s 0 vnl vsl H).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
cutrewrite (s - length vsl = 0).
generalize (map_proj_seq_safe_gen n s 0 vnl vsl H).

*****
H : le (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl vsl) (map (proj n (Init.Nat.add s O)) (seq (Init.Nat.add n O) s))) (firstn s (skipn O vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (app (firstn s vsl) (repeat O nil))
+++++
simpl_list.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
cutrewrite (s - length vsl = 0).
generalize (map_proj_seq_safe_gen n s 0 vnl vsl H).
simpl_list.

*****
H : le (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl vsl) (map (proj n (Init.Nat.add s O)) (seq (Init.Nat.add n O) s))) (firstn s (skipn O vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s vsl)
+++++
do 2 rewrite <- plus_n_O.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
cutrewrite (s - length vsl = 0).
generalize (map_proj_seq_safe_gen n s 0 vnl vsl H).
simpl_list.
do 2 rewrite <- plus_n_O.

*****
H : le (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s (skipn O vsl)), eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s vsl)
+++++
trivial.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
cutrewrite (s - length vsl = 0).

*****
H : le (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (Init.Nat.sub s (length vsl)) O
+++++
omega.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].

*****
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).

*****
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.

*****
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
le (Init.Nat.add s O) (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
rewrite app_length.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
rewrite app_length.

*****
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
le (Init.Nat.add s O) (Init.Nat.add (length vsl) (length (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
rewrite length_repeat.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
rewrite app_length.
rewrite length_repeat.

*****
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
le (Init.Nat.add s O) (Init.Nat.add (length vsl) (Init.Nat.sub s (length vsl)))
+++++
omega.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.

*****
H0 : le (Init.Nat.add s O)\n (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).

*****
H0 : le (Init.Nat.add s O)\n (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (map (proj n (Init.Nat.add s O)) (seq (Init.Nat.add n O) s))) (firstn s (skipn O (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))), eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
simpl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.

*****
H0 : le (Init.Nat.add s O)\n (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (map (proj n (Init.Nat.add s O)) (seq (Init.Nat.add n O) s))) (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))), eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
do 2 rewrite <- plus_n_O.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.

*****
H0 : le (Init.Nat.add s O)\n (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (map (fun f : BC => sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (map (proj n s) (seq n s))) (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))), eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
intro H1.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.

*****
H1 : eq\n (map\n (fun f : BC =>\n sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (map (proj n s) (seq n s)))\n (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H0 : le (Init.Nat.add s O)\n (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
rewrite <- H1.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.

*****
H1 : eq\n (map\n (fun f : BC =>\n sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (map (proj n s) (seq n s)))\n (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H0 : le (Init.Nat.add s O)\n (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (map (fun f : BC => sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (map (proj n s) (seq n s)))
+++++
clear H H0 H1.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.

*****
vnl,vsl : list (list bool)
n,s : nat
*****
eq (map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s))) (map (fun f : BC => sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (map (proj n s) (seq n s)))
+++++
apply map_ext2.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.

*****
vnl,vsl : list (list bool)
n,s : nat
*****
forall (a : BC) (_ : In a (map (proj n s) (seq n s))), eq (sem a vnl vsl) (sem a vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
intros f Hf.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.

*****
Hf : In f (map (proj n s) (seq n s))
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (sem f vnl vsl) (sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
rewrite in_map_iff in Hf.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.

*****
Hf : ex (fun x : nat => and (eq (proj n s x) f) (In x (seq n s)))
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (sem f vnl vsl) (sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
destruct Hf as [i [H1 H2] ].
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].

*****
H2 : In i (seq n s)
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (sem f vnl vsl) (sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
rewrite in_seq_iff in H2.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (sem f vnl vsl) (sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
rewrite sem_repeat with (n:=n) (s:=s).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
symmetry.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (sem f vnl (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
rewrite sem_repeat with (n:=n) (s:=s).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) (repeat (Init.Nat.sub s (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))) nil))) (sem f (app vnl (repeat (Init.Nat.sub n (length vnl)) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
f_equal.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (app (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)) (repeat (Init.Nat.sub s (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))) nil)) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
rewrite <- app_assoc.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (app vsl (app (repeat (Init.Nat.sub s (length vsl)) nil) (repeat (Init.Nat.sub s (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))) nil))) (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
f_equal.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (app (repeat (Init.Nat.sub s (length vsl)) nil) (repeat (Init.Nat.sub s (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))) nil)) (repeat (Init.Nat.sub s (length vsl)) nil)
+++++
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (app (repeat (Init.Nat.sub s (length vsl)) nil) (repeat (Init.Nat.sub s (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))) nil)) (app (repeat (Init.Nat.sub s (length vsl)) nil) nil)
+++++
f_equal.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).
f_equal.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (repeat (Init.Nat.sub s (length (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))) nil) nil
+++++
rewrite app_length.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).
f_equal.
rewrite app_length.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (repeat (Init.Nat.sub s (Init.Nat.add (length vsl) (length (repeat (Init.Nat.sub s (length vsl)) nil)))) nil) nil
+++++
rewrite length_repeat.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).
f_equal.
rewrite app_length.
rewrite length_repeat.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (repeat (Init.Nat.sub s (Init.Nat.add (length vsl) (Init.Nat.sub s (length vsl)))) nil) nil
+++++
cutrewrite (s - (length vsl + (s - length vsl)) = 0).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).
f_equal.
rewrite app_length.
rewrite length_repeat.
cutrewrite (s - (length vsl + (s - length vsl)) = 0).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (repeat O nil) nil
+++++
trivial.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).
f_equal.
rewrite app_length.
rewrite length_repeat.
cutrewrite (s - (length vsl + (s - length vsl)) = 0).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (Init.Nat.sub s (Init.Nat.add (length vsl) (Init.Nat.sub s (length vsl)))) O
+++++
omega.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (app (repeat (Init.Nat.sub s (length vsl)) nil) nil) (repeat (Init.Nat.sub s (length vsl)) nil)
+++++
simpl_list.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
f_equal.
rewrite <- app_assoc.
f_equal.
transitivity (repeat (s - length vsl) nil (A:=list bool) ++ nil).
simpl_list.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (repeat (Init.Nat.sub s (length vsl)) nil) (repeat (Init.Nat.sub s (length vsl)) nil)
+++++
trivial.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (arities f) (ok_arities n s)
+++++
subst f.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (arities (proj n s i)) (ok_arities n s)
+++++
simpl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (if match Init.Nat.add n s with | O => false | S m' => Nat.leb i m' end then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
case_eq (n+s).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (Init.Nat.add n s) O, eq (error_proj n s i) (ok_arities n s)
+++++
intro H.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intro H.

*****
H : eq (Init.Nat.add n s) O
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
contradict H.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intro H.
contradict H.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
not (eq (Init.Nat.add n s) O)
+++++
omega.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n s) (S n0)), eq (if Nat.leb i n0 then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
intros p H.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.

*****
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (if Nat.leb i p then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
case_eq (leb i p).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).

*****
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (Nat.leb i p) true, eq (ok_arities n s) (ok_arities n s)
+++++
trivial.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).

*****
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (Nat.leb i p) false, eq (error_proj n s i) (ok_arities n s)
+++++
intro Hleb.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).
intro Hleb.

*****
Hleb : eq (Nat.leb i p) false
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
rewrite leb_iff_conv in Hleb.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).
intro Hleb.
rewrite leb_iff_conv in Hleb.

*****
Hleb : lt p i
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
contradict Hleb.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
symmetry.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).
intro Hleb.
rewrite leb_iff_conv in Hleb.
contradict Hleb.

*****
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
not (lt p i)
+++++
omega.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
H1 : eq (proj n s i) f
i : nat
f : BC
vnl,vsl : list (list bool)
n,s : nat
*****
eq (arities f) (ok_arities n s)
+++++
subst f.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (arities (proj n s i)) (ok_arities n s)
+++++
simpl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (if match Init.Nat.add n s with | O => false | S m' => Nat.leb i m' end then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
case_eq (n+s).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (Init.Nat.add n s) O, eq (error_proj n s i) (ok_arities n s)
+++++
intro H.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intro H.

*****
H : eq (Init.Nat.add n s) O
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
contradict H.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intro H.
contradict H.

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
not (eq (Init.Nat.add n s) O)
+++++
omega.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).

*****
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.add n s) (S n0)), eq (if Nat.leb i n0 then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
intros p H.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.

*****
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (if Nat.leb i p then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
case_eq (leb i p).
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).

*****
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (Nat.leb i p) true, eq (ok_arities n s) (ok_arities n s)
+++++
trivial.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).

*****
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
forall _ : eq (Nat.leb i p) false, eq (error_proj n s i) (ok_arities n s)
+++++
intro Hleb.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).
intro Hleb.

*****
Hleb : eq (Nat.leb i p) false
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
rewrite leb_iff_conv in Hleb.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).
intro Hleb.
rewrite leb_iff_conv in Hleb.

*****
Hleb : lt p i
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
contradict Hleb.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
assert (s + 0 <= length (vsl ++ repeat (s - length vsl) nil)) as H0.
generalize (map_proj_seq_safe_gen n s 0 vnl (vsl ++ repeat (s - length vsl) nil) H0).
simpl.
do 2 rewrite <- plus_n_O.
intro H1.
rewrite <- H1.
clear H H0 H1.
apply map_ext2.
intros f Hf.
rewrite in_map_iff in Hf.
destruct Hf as [i [H1 H2] ].
rewrite in_seq_iff in H2.
rewrite sem_repeat with (n:=n) (s:=s).
subst f.
simpl.
case_eq (n+s).
intros p H.
case_eq (leb i p).
intro Hleb.
rewrite leb_iff_conv in Hleb.
contradict Hleb.

*****
H : eq (Init.Nat.add n s) (S p)
p : nat
H2 : and (le n i) (lt i (Init.Nat.add n s))
i : nat
vnl,vsl : list (list bool)
n,s : nat
*****
not (lt p i)
+++++
omega.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).

*****
H : gt (Init.Nat.add s O) (length vsl)
vnl,vsl : list (list bool)
n,s : nat
*****
eq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
clear H.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.

*****
vnl,vsl : list (list bool)
n,s : nat
*****
eq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
revert vsl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.

*****
vnl : list (list bool)
n,s : nat
*****
forall vsl : list (list bool), eq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil))) (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
+++++
induction s as [ | s IH].
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].

*****
vnl : list (list bool)
n : nat
*****
forall vsl : list (list bool), eq (firstn O (app vsl (repeat (Init.Nat.sub O (length vsl)) nil))) (app (firstn O vsl) (repeat (Init.Nat.sub O (length vsl)) nil))
+++++
simpl in *.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.

*****
vnl : list (list bool)
n : nat
*****
forall _ : list (list bool), eq nil nil
+++++
intro vsl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.

*****
vnl,vsl : list (list bool)
n : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].

*****
IH : forall vsl : list (list bool),\neq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
vnl : list (list bool)
n,s : nat
*****
forall vsl : list (list bool), eq (firstn (S s) (app vsl (repeat (Init.Nat.sub (S s) (length vsl)) nil))) (app (firstn (S s) vsl) (repeat (Init.Nat.sub (S s) (length vsl)) nil))
+++++
simpl in *.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.

*****
IH : forall vsl : list (list bool),\neq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
vnl : list (list bool)
n,s : nat
*****
forall vsl : list (list bool), eq match app vsl (repeat match length vsl with | O => S s | S l => Init.Nat.sub s l end nil) with | nil => nil | cons a l => cons a (firstn s l) end (app match vsl with | nil => nil | cons a l => cons a (firstn s l) end (repeat match length vsl with | O => S s | S l => Init.Nat.sub s l end nil))
+++++
intro vsl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.

*****
vsl : list (list bool)
IH : forall vsl : list (list bool),\neq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
vnl : list (list bool)
n,s : nat
*****
eq match app vsl (repeat match length vsl with | O => S s | S l => Init.Nat.sub s l end nil) with | nil => nil | cons a l => cons a (firstn s l) end (app match vsl with | nil => nil | cons a l => cons a (firstn s l) end (repeat match length vsl with | O => S s | S l => Init.Nat.sub s l end nil))
+++++
destruct vsl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.
destruct vsl.

*****
IH : forall vsl : list (list bool),\neq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
vnl : list (list bool)
n,s : nat
*****
eq match app nil (repeat match length nil with | O => S s | S l => Init.Nat.sub s l end nil) with | nil => nil | cons a l => cons a (firstn s l) end (app nil (repeat match length nil with | O => S s | S l => Init.Nat.sub s l end nil))
+++++
simpl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.
destruct vsl.
simpl.

*****
IH : forall vsl : list (list bool),\neq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
vnl : list (list bool)
n,s : nat
*****
eq (cons nil (firstn s (repeat s nil))) (cons nil (repeat s nil))
+++++
clear IH.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.
destruct vsl.
simpl.
clear IH.

*****
vnl : list (list bool)
n,s : nat
*****
eq (cons nil (firstn s (repeat s nil))) (cons nil (repeat s nil))
+++++
f_equal.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.
destruct vsl.
simpl.
clear IH.
f_equal.

*****
vnl : list (list bool)
n,s : nat
*****
eq (firstn s (repeat s nil)) (repeat s nil)
+++++
apply firstn_repeat_le.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.
destruct vsl.
simpl.
clear IH.
f_equal.
apply firstn_repeat_le.

*****
vnl : list (list bool)
n,s : nat
*****
le s s
+++++
trivial.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.
destruct vsl.

*****
vsl : list (list bool)
l : list bool
IH : forall vsl : list (list bool),\neq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
vnl : list (list bool)
n,s : nat
*****
eq match app (cons l vsl) (repeat match length (cons l vsl) with | O => S s | S l => Init.Nat.sub s l end nil) with | nil => nil | cons a l => cons a (firstn s l) end (app (cons l (firstn s vsl)) (repeat match length (cons l vsl) with | O => S s | S l => Init.Nat.sub s l end nil))
+++++
simpl.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].
transitivity (firstn s (vsl ++ repeat (s - length vsl) nil)).
clear H.
revert vsl.
induction s as [ | s IH].
simpl in *.
intro vsl.
destruct vsl.
simpl.

*****
vsl : list (list bool)
l : list bool
IH : forall vsl : list (list bool),\neq (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))\n (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil))
vnl : list (list bool)
n,s : nat
*****
eq (cons l (firstn s (app vsl (repeat (Init.Nat.sub s (length vsl)) nil)))) (cons l (app (firstn s vsl) (repeat (Init.Nat.sub s (length vsl)) nil)))
+++++
congruence.
-----
Lemma map_proj_seq_safe : forall n s vnl vsl, map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) = firstn s vsl ++ repeat (s - length vsl) nil.
Proof.
intros n s vnl vsl.
destruct (le_gt_dec (s+0) (length vsl)) as [H | H].

*****

*****

+++++
Qed.
-----
Definition zero_e (n s:nat) : BC :=\n  comp n s zero nil nil.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i,\nn2 <> 0 -> i < n2 ->\nsem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil =\nsem (nth i f1 (zero_e n1 0)) vnl nil.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.

*****

*****
forall (n1 n2 : nat) (f1 : list BC) (vnl : list (list bool)) (i : nat) (_ : not (eq n2 O)) (_ : lt i n2), eq (sem (comp n1 O (proj n2 O i) f1 nil) vnl nil) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
Proof.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.

*****

*****
forall (n1 n2 : nat) (f1 : list BC) (vnl : list (list bool)) (i : nat) (_ : not (eq n2 O)) (_ : lt i n2), eq (sem (comp n1 O (proj n2 O i) f1 nil) vnl nil) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
intros.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.

*****
H0 : lt i n2
H : not (eq n2 O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq (sem (comp n1 O (proj n2 O i) f1 nil) vnl nil) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
simpl.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.

*****
H0 : lt i n2
H : not (eq n2 O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq (if match n2 with | O => false | S m' => Nat.leb i m' end then nth i (map (fun ne : BC => sem ne vnl nil) f1) nil else match Init.Nat.sub i n2 with | O | _ => nil end) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
destruct n2.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.

*****
H0 : lt i O
H : not (eq O O)
i : nat
vnl : list (list bool)
f1 : list BC
n1 : nat
*****
eq match Init.Nat.sub i O with | O | _ => nil end (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
simpl.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.

*****
H0 : lt i O
H : not (eq O O)
i : nat
vnl : list (list bool)
f1 : list BC
n1 : nat
*****
eq match Init.Nat.sub i O with | O | _ => nil end (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
elim H.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.
elim H.

*****
H0 : lt i O
H : not (eq O O)
i : nat
vnl : list (list bool)
f1 : list BC
n1 : nat
*****
eq O O
+++++
auto.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.

*****
H0 : lt i (S n2)
H : not (eq (S n2) O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq (if Nat.leb i n2 then nth i (map (fun ne : BC => sem ne vnl nil) f1) nil else match Init.Nat.sub i (S n2) with | O | _ => nil end) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
simpl.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.

*****
H0 : lt i (S n2)
H : not (eq (S n2) O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq (if Nat.leb i n2 then nth i (map (fun ne : BC => sem ne vnl nil) f1) nil else match Init.Nat.sub i (S n2) with | O | _ => nil end) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
rewrite leb_correct.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct.

*****
H0 : lt i (S n2)
H : not (eq (S n2) O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq (nth i (map (fun ne : BC => sem ne vnl nil) f1) nil) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
idtac.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct.
idtac.

*****
H0 : lt i (S n2)
H : not (eq (S n2) O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq (nth i (map (fun ne : BC => sem ne vnl nil) f1) nil) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
rewrite map_nth2 with (d := zero_e n1 0).
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct.
idtac.
rewrite map_nth2 with (d := zero_e n1 0).

*****
H0 : lt i (S n2)
H : not (eq (S n2) O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq (sem (nth i f1 (zero_e n1 O)) vnl nil) (sem (nth i f1 (zero_e n1 O)) vnl nil)
+++++
auto.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct.
idtac.
rewrite map_nth2 with (d := zero_e n1 0).

*****
H0 : lt i (S n2)
H : not (eq (S n2) O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq (sem (zero_e n1 O) vnl nil) nil
+++++
simpl.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct.
idtac.
rewrite map_nth2 with (d := zero_e n1 0).
simpl.

*****
H0 : lt i (S n2)
H : not (eq (S n2) O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
eq nil nil
+++++
auto.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct.

*****
H0 : lt i (S n2)
H : not (eq (S n2) O)
i : nat
vnl : list (list bool)
f1 : list BC
n1,n2 : nat
*****
le i n2
+++++
omega.
-----
Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i, n2 <> 0 -> i < n2 -> sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil = sem (nth i f1 (zero_e n1 0)) vnl nil.
Proof.
intros.
simpl.
destruct n2.

*****

*****

+++++
Qed.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i,\nn2 <= i ->\nsem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl =\nsem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.

*****

*****
forall (n1 s1 n2 s2 : nat) (f1 f2 : list BC) (vnl vsl : list (list bool)) (i : nat) (_ : le n2 i), eq (sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl) (sem (nth (Init.Nat.sub i n2) f2 (zero_e n1 s1)) vnl vsl)
+++++
Proof.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.

*****

*****
forall (n1 s1 n2 s2 : nat) (f1 f2 : list BC) (vnl vsl : list (list bool)) (i : nat) (_ : le n2 i), eq (sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl) (sem (nth (Init.Nat.sub i n2) f2 (zero_e n1 s1)) vnl vsl)
+++++
intros.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.

*****
H : le n2 i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
eq (sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl) (sem (nth (Init.Nat.sub i n2) f2 (zero_e n1 s1)) vnl vsl)
+++++
simpl.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.

*****
H : le n2 i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
eq (if match n2 with | O => false | S m' => Nat.leb i m' end then nth i (map (fun ne : BC => sem ne vnl nil) f1) nil else nth (Init.Nat.sub i n2) (map (fun se : BC => sem se vnl vsl) f2) nil) (sem (nth (Init.Nat.sub i n2) f2 (zero_e n1 s1)) vnl vsl)
+++++
destruct n2.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.

*****
H : le O i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,s2 : nat
*****
eq (nth (Init.Nat.sub i O) (map (fun se : BC => sem se vnl vsl) f2) nil) (sem (nth (Init.Nat.sub i O) f2 (zero_e n1 s1)) vnl vsl)
+++++
simpl.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.

*****
H : le O i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,s2 : nat
*****
eq (nth (Init.Nat.sub i O) (map (fun se : BC => sem se vnl vsl) f2) nil) (sem (nth (Init.Nat.sub i O) f2 (zero_e n1 s1)) vnl vsl)
+++++
rewrite map_nth2 with (d := (zero_e n1 s1)).
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite map_nth2 with (d := (zero_e n1 s1)).

*****
H : le O i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,s2 : nat
*****
eq (sem (nth (Init.Nat.sub i O) f2 (zero_e n1 s1)) vnl vsl) (sem (nth (Init.Nat.sub i O) f2 (zero_e n1 s1)) vnl vsl)
+++++
auto.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite map_nth2 with (d := (zero_e n1 s1)).

*****
H : le O i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,s2 : nat
*****
eq (sem (zero_e n1 s1) vnl vsl) nil
+++++
simpl.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite map_nth2 with (d := (zero_e n1 s1)).
simpl.

*****
H : le O i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,s2 : nat
*****
eq nil nil
+++++
auto.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.

*****
H : le (S n2) i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
eq (if Nat.leb i n2 then nth i (map (fun ne : BC => sem ne vnl nil) f1) nil else nth (Init.Nat.sub i (S n2)) (map (fun se : BC => sem se vnl vsl) f2) nil) (sem (nth (Init.Nat.sub i (S n2)) f2 (zero_e n1 s1)) vnl vsl)
+++++
simpl.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.

*****
H : le (S n2) i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
eq (if Nat.leb i n2 then nth i (map (fun ne : BC => sem ne vnl nil) f1) nil else nth (Init.Nat.sub i (S n2)) (map (fun se : BC => sem se vnl vsl) f2) nil) (sem (nth (Init.Nat.sub i (S n2)) f2 (zero_e n1 s1)) vnl vsl)
+++++
rewrite leb_correct_conv.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct_conv.

*****
H : le (S n2) i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
eq (nth (Init.Nat.sub i (S n2)) (map (fun se : BC => sem se vnl vsl) f2) nil) (sem (nth (Init.Nat.sub i (S n2)) f2 (zero_e n1 s1)) vnl vsl)
+++++
idtac.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct_conv.
idtac.

*****
H : le (S n2) i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
eq (nth (Init.Nat.sub i (S n2)) (map (fun se : BC => sem se vnl vsl) f2) nil) (sem (nth (Init.Nat.sub i (S n2)) f2 (zero_e n1 s1)) vnl vsl)
+++++
rewrite map_nth2 with (d := zero_e n1 s1).
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct_conv.
idtac.
rewrite map_nth2 with (d := zero_e n1 s1).

*****
H : le (S n2) i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
eq (sem (nth (Init.Nat.sub i (S n2)) f2 (zero_e n1 s1)) vnl vsl) (sem (nth (Init.Nat.sub i (S n2)) f2 (zero_e n1 s1)) vnl vsl)
+++++
auto.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct_conv.
idtac.
rewrite map_nth2 with (d := zero_e n1 s1).

*****
H : le (S n2) i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
eq (sem (zero_e n1 s1) vnl vsl) nil
+++++
auto.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.
simpl.
rewrite leb_correct_conv.

*****
H : le (S n2) i
i : nat
vnl,vsl : list (list bool)
f1,f2 : list BC
n1,s1,n2,s2 : nat
*****
lt n2 i
+++++
omega.
-----
Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i, n2 <= i -> sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl = sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.
Proof.
intros.
simpl.
destruct n2.

*****

*****

+++++
Qed.
-----
Fixpoint poly_BC n (e : BC) : pol :=\n  match e with \n    | zero => pcst 0 0\n    | proj n s i => if (leb (S i) n) then pproj n i else (pcst n 0)\n    | succ b => pcst 0 1\n    | pred => pcst 0 0\n    | cond => pcst 0 0\n    | rec g h0 h1 =>\n        pplus (pshift (poly_BC (n - 1) g)) \n        (pmult (pproj n 0) (pplus (poly_BC n h0) (poly_BC n h1)))\n    | comp n s h rl tl =>\n      (pplus (pcst n 0)\n        (pplus (pcomp (poly_BC (length rl) h) (map (poly_BC n) rl ))\n          (pplusl (map (poly_BC n) tl))))\n  end.
-----
Lemma arity_poly_BC : forall e n s,\n  arities e = ok_arities n s ->\n  parity (poly_BC n e) = n.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), eq (fst (poly_BC n e)) n
+++++
Proof.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), eq (fst (poly_BC n e)) n
+++++
apply BC_ind_inf.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.

*****

*****
eq (fst (poly_BC O zero)) O
+++++
simpl.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****

*****
eq O O
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****

*****
eq O O
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), eq (fst (poly_BC n (proj n s i))) n
+++++
simpl.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), eq (fst (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O)) n
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (fst (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O)) n
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
eq (fst (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O)) n
+++++
destruct n.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.

*****
H : lt i (Init.Nat.add O s)
s,i : nat
*****
eq (fst (pcst O O)) O
+++++
rewrite parity_pcst.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.
rewrite parity_pcst.

*****
H : lt i (Init.Nat.add O s)
s,i : nat
*****
eq O O
+++++
trivial.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.

*****
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (fst (if Nat.leb i n then pproj (S n) i else pcst (S n) O)) (S n)
+++++
case_eq (leb i n).
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.
case_eq (leb i n).

*****
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) true, eq (fst (pproj (S n) i)) (S n)
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.
case_eq (leb i n).
intros.

*****
H0 : eq (Nat.leb i n) true
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (fst (pproj (S n) i)) (S n)
+++++
rewrite parity_pproj.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.
case_eq (leb i n).
intros.
rewrite parity_pproj.

*****
H0 : eq (Nat.leb i n) true
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (S n) (S n)
+++++
trivial.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.
case_eq (leb i n).

*****
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) false, eq (fst (pcst (S n) O)) (S n)
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.
case_eq (leb i n).
intros.

*****
H0 : eq (Nat.leb i n) false
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (fst (pcst (S n) O)) (S n)
+++++
rewrite parity_pcst.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
destruct n.
case_eq (leb i n).
intros.
rewrite parity_pcst.

*****
H0 : eq (Nat.leb i n) false
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
eq (S n) (S n)
+++++
trivial.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.

*****

*****
forall b : bool, eq (fst (poly_BC O (succ b))) O
+++++
simpl.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****

*****
forall _ : bool, eq O O
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
b : bool
*****
eq O O
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.

*****

*****
eq (fst (poly_BC O pred)) O
+++++
simpl.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****

*****
eq O O
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****

*****
eq O O
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.

*****

*****
eq (fst (poly_BC O cond)) O
+++++
simpl.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****

*****
eq O O
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****

*****
eq O O
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : eq (fst (poly_BC n g)) n) (_ : eq (fst (poly_BC (S n) h0)) (S n)) (_ : eq (fst (poly_BC (S n) h1)) (S n)), eq (fst (poly_BC (S n) (rec g h0 h1))) (S n)
+++++
simpl.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : eq (fst (poly_BC n g)) n) (_ : eq (fst (poly_BC (S n) h0)) (S n)) (_ : eq (fst (poly_BC (S n) h1)) (S n)), eq match match Init.Nat.max (fst (poly_BC (S n) h0)) (fst (poly_BC (S n) h1)) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_BC (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_BC (Init.Nat.sub n O) g)) m') end (S n)
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H4 : eq (fst (poly_BC (S n) h1)) (S n)
H3 : eq (fst (poly_BC (S n) h0)) (S n)
H2 : eq (fst (poly_BC n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq match match Init.Nat.max (fst (poly_BC (S n) h0)) (fst (poly_BC (S n) h1)) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_BC (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_BC (Init.Nat.sub n O) g)) m') end (S n)
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
H4 : eq (fst (poly_BC (S n) h1)) (S n)
H3 : eq (fst (poly_BC (S n) h0)) (S n)
H2 : eq (fst (poly_BC n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq match match Init.Nat.max (fst (poly_BC (S n) h0)) (fst (poly_BC (S n) h1)) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_BC (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_BC (Init.Nat.sub n O) g)) m') end (S n)
+++++
rewrite H3.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.

*****
H4 : eq (fst (poly_BC (S n) h1)) (S n)
H3 : eq (fst (poly_BC (S n) h0)) (S n)
H2 : eq (fst (poly_BC n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq match match Init.Nat.max (S n) (fst (poly_BC (S n) h1)) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_BC (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_BC (Init.Nat.sub n O) g)) m') end (S n)
+++++
rewrite H4.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.
rewrite H4.

*****
H4 : eq (fst (poly_BC (S n) h1)) (S n)
H3 : eq (fst (poly_BC (S n) h0)) (S n)
H2 : eq (fst (poly_BC n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq match match Init.Nat.max (S n) (S n) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_BC (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_BC (Init.Nat.sub n O) g)) m') end (S n)
+++++
rewrite <- minus_n_O.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.
rewrite H4.
rewrite <- minus_n_O.

*****
H4 : eq (fst (poly_BC (S n) h1)) (S n)
H3 : eq (fst (poly_BC (S n) h0)) (S n)
H2 : eq (fst (poly_BC n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq match match Init.Nat.max (S n) (S n) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_BC n g)) | S m' => S (Init.Nat.max (fst (poly_BC n g)) m') end (S n)
+++++
rewrite H2.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.
rewrite H4.
rewrite <- minus_n_O.
rewrite H2.

*****
H4 : eq (fst (poly_BC (S n) h1)) (S n)
H3 : eq (fst (poly_BC (S n) h0)) (S n)
H2 : eq (fst (poly_BC n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq match match Init.Nat.max (S n) (S n) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S n | S m' => S (Init.Nat.max n m') end (S n)
+++++
repeat rewrite Nat.max_idempotent.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.
rewrite H4.
rewrite <- minus_n_O.
rewrite H2.
repeat rewrite Nat.max_idempotent.

*****
H4 : eq (fst (poly_BC (S n) h1)) (S n)
H3 : eq (fst (poly_BC (S n) h0)) (S n)
H2 : eq (fst (poly_BC n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
eq (S n) (S n)
+++++
trivial.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : eq (fst (poly_BC (length rl) h)) (length rl)) (_ : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n) (_ : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n), eq (fst (poly_BC n (comp n s h rl tl))) n
+++++
simpl.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : eq (fst (poly_BC (length rl) h)) (length rl)) (_ : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n) (_ : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n), eq (Init.Nat.max n (Init.Nat.max (maxl (map fst (map (poly_BC n) rl))) (fst (pplusl (map (poly_BC n) tl))))) n
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (Init.Nat.max n (Init.Nat.max (maxl (map fst (map (poly_BC n) rl))) (fst (pplusl (map (poly_BC n) tl))))) n
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (Init.Nat.max n (Init.Nat.max (maxl (map fst (map (poly_BC n) rl))) (fst (pplusl (map (poly_BC n) tl))))) n
+++++
apply max_l.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (Init.Nat.max (maxl (map fst (map (poly_BC n) rl))) (fst (pplusl (map (poly_BC n) tl)))) n
+++++
apply Nat.max_lub.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map fst (map (poly_BC n) rl))) n
+++++
apply maxl_map.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
apply maxl_map.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall (x : prod nat (list mon)) (_ : In x (map (poly_BC n) rl)), eq (fst x) n
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
apply maxl_map.
intros.

*****
H5 : In x (map (poly_BC n) rl)
x : prod nat (list mon)
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (fst x) n
+++++
rewrite in_map_iff in H5.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
apply maxl_map.
intros.
rewrite in_map_iff in H5.

*****
H5 : ex (fun x0 : BC => and (eq (poly_BC n x0) x) (In x0 rl))
x : prod nat (list mon)
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (fst x) n
+++++
destruct H5 as [p [Hp1 Hp2]].
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
apply maxl_map.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].

*****
Hp2 : In p rl
Hp1 : eq (poly_BC n p) x
p : BC
x : prod nat (list mon)
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (fst x) n
+++++
subst.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
apply maxl_map.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].
subst.

*****
Hp2 : In p rl
p : BC
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (fst (poly_BC n p)) n
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (fst (pplusl (map (poly_BC n) tl))) n
+++++
rewrite parity_pplusl.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
rewrite parity_pplusl.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map fst (map (poly_BC n) tl))) n
+++++
apply maxl_map.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
rewrite parity_pplusl.
apply maxl_map.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall (x : prod nat (list mon)) (_ : In x (map (poly_BC n) tl)), eq (fst x) n
+++++
intros.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
rewrite parity_pplusl.
apply maxl_map.
intros.

*****
H5 : In x (map (poly_BC n) tl)
x : prod nat (list mon)
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (fst x) n
+++++
rewrite in_map_iff in H5.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
rewrite parity_pplusl.
apply maxl_map.
intros.
rewrite in_map_iff in H5.

*****
H5 : ex (fun x0 : BC => and (eq (poly_BC n x0) x) (In x0 tl))
x : prod nat (list mon)
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (fst x) n
+++++
destruct H5 as [p [Hp1 Hp2]].
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
rewrite parity_pplusl.
apply maxl_map.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].

*****
Hp2 : In p tl
Hp1 : eq (poly_BC n p) x
p : BC
x : prod nat (list mon)
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (fst x) n
+++++
subst.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
apply max_l.
apply Nat.max_lub.
rewrite parity_pplusl.
apply maxl_map.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].
subst.

*****
Hp2 : In p tl
p : BC
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_BC n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_BC n r)) n
H2 : eq (fst (poly_BC (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (fst (poly_BC n p)) n
+++++
auto.
-----
Lemma arity_poly_BC : forall e n s, arities e = ok_arities n s -> parity (poly_BC n e) = n.
Proof.
apply BC_ind_inf.

*****

*****

+++++
Qed.
-----
Lemma pWF_poly_BC : forall e n s,\n  arities e = ok_arities n s -> pWF (poly_BC n e).
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), pWF (poly_BC n e)
+++++
Proof.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), pWF (poly_BC n e)
+++++
apply BC_ind_inf.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.

*****

*****
pWF (poly_BC O zero)
+++++
simpl.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.

*****

*****
pWF (pcst O O)
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.

*****

*****
pWF (pcst O O)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****

*****
pWF (pcst O O)
+++++
try pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), pWF (poly_BC n (proj n s i))
+++++
simpl.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.

*****

*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), pWF (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O)
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
pWF (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
pWF (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O)
+++++
try pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.

*****
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
pWF (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.

*****
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
pWF (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O)
+++++
destruct n.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.

*****
H : lt i (Init.Nat.add O s)
s,i : nat
*****
pWF (pcst O O)
+++++
pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.

*****
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
pWF (if Nat.leb i n then pproj (S n) i else pcst (S n) O)
+++++
idtac.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.
idtac.

*****
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
pWF (if Nat.leb i n then pproj (S n) i else pcst (S n) O)
+++++
case_eq (leb i n).
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.
idtac.
case_eq (leb i n).

*****
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) true, pWF (pproj (S n) i)
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.
idtac.
case_eq (leb i n).
intros.

*****
H0 : eq (Nat.leb i n) true
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
pWF (pproj (S n) i)
+++++
pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.
idtac.
case_eq (leb i n).
intros.
pWF.

*****
H0 : eq (Nat.leb i n) true
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
lt i (S n)
+++++
apply leb_complete in H0.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.
idtac.
case_eq (leb i n).
intros.
pWF.
apply leb_complete in H0.

*****
H0 : le i n
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
lt i (S n)
+++++
omega.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.
idtac.
case_eq (leb i n).

*****
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
forall _ : eq (Nat.leb i n) false, pWF (pcst (S n) O)
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
destruct n.
idtac.
case_eq (leb i n).
intros.

*****
H0 : eq (Nat.leb i n) false
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
pWF (pcst (S n) O)
+++++
pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.

*****

*****
forall b : bool, pWF (poly_BC O (succ b))
+++++
simpl.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.

*****

*****
forall _ : bool, pWF (pcst O (S O))
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
b : bool
*****
pWF (pcst O (S O))
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
b : bool
*****
pWF (pcst O (S O))
+++++
try pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.

*****

*****
pWF (poly_BC O pred)
+++++
simpl.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.

*****

*****
pWF (pcst O O)
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.

*****

*****
pWF (pcst O O)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****

*****
pWF (pcst O O)
+++++
try pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.

*****

*****
pWF (poly_BC O cond)
+++++
simpl.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.

*****

*****
pWF (pcst O O)
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.

*****

*****
pWF (pcst O O)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****

*****
pWF (pcst O O)
+++++
try pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : pWF (poly_BC n g)) (_ : pWF (poly_BC (S n) h0)) (_ : pWF (poly_BC (S n) h1)), pWF (poly_BC (S n) (rec g h0 h1))
+++++
simpl.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.

*****

*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : pWF (poly_BC n g)) (_ : pWF (poly_BC (S n) h0)) (_ : pWF (poly_BC (S n) h1)), pWF (pplus (pshift (poly_BC (Init.Nat.sub n O) g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H4 : pWF (poly_BC (S n) h1)
H3 : pWF (poly_BC (S n) h0)
H2 : pWF (poly_BC n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
pWF (pplus (pshift (poly_BC (Init.Nat.sub n O) g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
H4 : pWF (poly_BC (S n) h1)
H3 : pWF (poly_BC (S n) h0)
H2 : pWF (poly_BC n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
pWF (pplus (pshift (poly_BC (Init.Nat.sub n O) g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))
+++++
try pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.

*****
H4 : pWF (poly_BC (S n) h1)
H3 : pWF (poly_BC (S n) h0)
H2 : pWF (poly_BC n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
pWF (poly_BC (Init.Nat.sub n O) g)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.

*****
H4 : pWF (poly_BC (S n) h1)
H3 : pWF (poly_BC (S n) h0)
H2 : pWF (poly_BC n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
pWF (poly_BC (Init.Nat.sub n O) g)
+++++
rewrite <- minus_n_O.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
rewrite <- minus_n_O.

*****
H4 : pWF (poly_BC (S n) h1)
H3 : pWF (poly_BC (S n) h0)
H2 : pWF (poly_BC n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
pWF (poly_BC n g)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.

*****
H4 : pWF (poly_BC (S n) h1)
H3 : pWF (poly_BC (S n) h0)
H2 : pWF (poly_BC n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
pWF (poly_BC (S n) h0)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.

*****
H4 : pWF (poly_BC (S n) h1)
H3 : pWF (poly_BC (S n) h0)
H2 : pWF (poly_BC n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
pWF (poly_BC (S n) h1)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : pWF (poly_BC (length rl) h)) (_ : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)) (_ : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)), pWF (poly_BC n (comp n s h rl tl))
+++++
simpl.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.

*****

*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : pWF (poly_BC (length rl) h)) (_ : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)) (_ : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)), pWF (pplus (pcst n O) (pplus (pcomp (poly_BC (length rl) h) (map (poly_BC n) rl)) (pplusl (map (poly_BC n) tl))))
+++++
intros.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF (pplus (pcst n O) (pplus (pcomp (poly_BC (length rl) h) (map (poly_BC n) rl)) (pplusl (map (poly_BC n) tl))))
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF (pplus (pcst n O) (pplus (pcomp (poly_BC (length rl) h) (map (poly_BC n) rl)) (pplusl (map (poly_BC n) tl))))
+++++
try pWF.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.

*****
H5 : In x (map (poly_BC n) rl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF x
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.

*****
H5 : In x (map (poly_BC n) rl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF x
+++++
rewrite in_map_iff in H5.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
rewrite in_map_iff in H5.

*****
H5 : ex (fun x0 : BC => and (eq (poly_BC n x0) x) (In x0 rl))
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF x
+++++
destruct H5 as [p [Hp1 Hp2]].
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].

*****
Hp2 : In p rl
Hp1 : eq (poly_BC n p) x
p : BC
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF x
+++++
subst.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].
subst.

*****
Hp2 : In p rl
p : BC
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF (poly_BC n p)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.

*****
H5 : In x (map (poly_BC n) tl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF x
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.

*****
H5 : In x (map (poly_BC n) tl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF x
+++++
rewrite in_map_iff in H5.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
rewrite in_map_iff in H5.

*****
H5 : ex (fun x0 : BC => and (eq (poly_BC n x0) x) (In x0 tl))
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF x
+++++
destruct H5 as [p [Hp1 Hp2]].
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].

*****
Hp2 : In p tl
Hp1 : eq (poly_BC n p) x
p : BC
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF x
+++++
subst.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
try pWF.
auto.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].
subst.

*****
Hp2 : In p tl
p : BC
H4 : forall (r : BC) (_ : In r tl), pWF (poly_BC n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_BC n r)
H2 : pWF (poly_BC (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
pWF (poly_BC n p)
+++++
auto.
-----
Lemma pWF_poly_BC : forall e n s, arities e = ok_arities n s -> pWF (poly_BC n e).
Proof.
apply BC_ind_inf.

*****

*****

+++++
Qed.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s,\n  arities e = ok_arities n s ->\n  length (sem e xl yl) <= \n  peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).

*****

*****
forall (e : BC) (xl yl : list (list bool)) (n s : nat) (_ : eq (arities e) (ok_arities n s)), le (length (sem e xl yl)) (Init.Nat.add (peval (poly_BC n e) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
Proof.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.

*****

*****
forall (e : BC) (xl yl : list (list bool)) (n s : nat) (_ : eq (arities e) (ok_arities n s)), le (length (sem e xl yl)) (Init.Nat.add (peval (poly_BC n e) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
intros.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.

*****
H : eq (arities e) (ok_arities n s)
n,s : nat
xl,yl : list (list bool)
e : BC
*****
le (length (sem e xl yl)) (Init.Nat.add (peval (poly_BC n e) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
revert e n s H xl yl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.

*****

*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)) (xl yl : list (list bool)), le (length (sem e xl yl)) (Init.Nat.add (peval (poly_BC n e) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.

*****
xl,yl : list (list bool)
*****
le O (maxl (map (length (A:=bool)) yl))
+++++
omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.

*****
xl,yl : list (list bool)
H : lt i (Init.Nat.add n s)
n,s,i : nat
*****
le (length (if match n with | O => false | S m' => Nat.leb i m' end then nth i xl nil else nth (Init.Nat.sub i n) yl nil)) (Init.Nat.add (peval (if match n with | O => false | S m' => Nat.leb i m' end then pproj n i else pcst n O) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
destruct n.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.

*****
xl,yl : list (list bool)
H : lt i (Init.Nat.add O s)
s,i : nat
*****
le (length (nth (Init.Nat.sub i O) yl nil)) (Init.Nat.add (peval (pcst O O) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.

*****
xl,yl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
le (length (if Nat.leb i n then nth i xl nil else nth (Init.Nat.sub i (S n)) yl nil)) (Init.Nat.add (peval (if Nat.leb i n then pproj (S n) i else pcst (S n) O) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
case_eq (leb i n); intros.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.

*****
H0 : eq (Nat.leb i n) true
xl,yl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
le (length (nth i xl nil)) (Init.Nat.add (peval (pproj (S n) i) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
apply leb_complete in H0.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.

*****
H0 : le i n
xl,yl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
le (length (nth i xl nil)) (Init.Nat.add (peval (pproj (S n) i) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
revert i H H0.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.

*****
xl,yl : list (list bool)
n,s : nat
*****
forall (i : nat) (_ : lt i (Init.Nat.add (S n) s)) (_ : le i n), le (length (nth i xl nil)) (Init.Nat.add (peval (pproj (S n) i) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.

*****
H0 : le O n
H : lt O (S (Init.Nat.add n s))
IHxl : forall (i : nat) (_ : lt i (Init.Nat.add (S n) s)) (_ : le i n),\nle (length (nth i xl nil))\n (Init.Nat.add (peval (pproj (S n) i) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
a : list bool
n,s : nat
*****
le (length a) (Init.Nat.add (peval (pproj (S n) O) (cons (length a) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite pproj_correct; simpl; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.

*****
H0 : le (S i) n
H : lt (S i) (S (Init.Nat.add n s))
i : nat
IHxl : forall (i : nat) (_ : lt i (Init.Nat.add (S n) s)) (_ : le i n),\nle (length (nth i xl nil))\n (Init.Nat.add (peval (pproj (S n) i) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
a : list bool
n,s : nat
*****
le (length (nth i xl nil)) (Init.Nat.add (peval (pproj (S n) (S i)) (cons (length a) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans;[ apply IHxl | ]; trivial; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.

*****
H0 : eq (Nat.leb i n) false
xl,yl : list (list bool)
H : lt i (Init.Nat.add (S n) s)
n,s,i : nat
*****
le (length (nth (Init.Nat.sub i (S n)) yl nil)) (Init.Nat.add (peval (pcst (S n) O) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.

*****
xl,yl : list (list bool)
b : bool
*****
le (S (length (hd nil yl))) (S (maxl (map (length (A:=bool)) yl)))
+++++
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.

*****
xl,yl : list (list bool)
*****
le (length (tl (hd nil yl))) (maxl (map (length (A:=bool)) yl))
+++++
eapply le_trans;[ | apply nth_maxl_bound].
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].

*****
xl,yl : list (list bool)
*****
le (length (tl (hd nil yl))) (length (nth ?i yl ?d))
+++++
instantiate (1:=nil).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).

*****
xl,yl : list (list bool)
*****
le (length (tl (hd nil yl))) (length (nth ?i yl nil))
+++++
rewrite hd_nth_0.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.

*****
xl,yl : list (list bool)
*****
le (length (tl (nth O yl nil))) (length (nth ?i yl nil))
+++++
instantiate (1:= 0).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).

*****
xl,yl : list (list bool)
*****
le (length (tl (nth O yl nil))) (length (nth O yl nil))
+++++
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.

*****
xl,yl : list (list bool)
*****
eq (length nil) O
+++++
trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.

*****
xl,yl : list (list bool)
*****
le (length match yl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end) (maxl (map (length (A:=bool)) yl))
+++++
do 3 (destruct yl; simpl; try omega).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).

*****
l,l0 : list bool
xl : list (list bool)
*****
le (length match l with | nil => l0 | cons _ _ => nil end) (Init.Nat.max (length l) (Init.Nat.max (length l0) O))
+++++
destruct l; simpl; auto with arith.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.

*****
yl : list (list bool)
l,l0,l1 : list bool
xl : list (list bool)
*****
le (length match yl with | nil => match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end | cons d _ => match l with | nil => l0 | cons true _ => l1 | cons false _ => d end end) (Init.Nat.max (length l) (Init.Nat.max (length l0) (Init.Nat.max (length l1) (maxl (map (length (A:=bool)) yl)))))
+++++
destruct yl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.

*****
l,l0,l1 : list bool
xl : list (list bool)
*****
le (length match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end) (Init.Nat.max (length l) (Init.Nat.max (length l0) (Init.Nat.max (length l1) (maxl (map (length (A:=bool)) nil)))))
+++++
destruct l; simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.

*****
l0,l1 : list bool
xl : list (list bool)
*****
le (length l0) (Init.Nat.max (length l0) (Init.Nat.max (length l1) O))
+++++
auto with arith.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.

*****
l,l0,l1 : list bool
b : bool
xl : list (list bool)
*****
le (length (if b then l1 else nil)) match Init.Nat.max (length l0) (Init.Nat.max (length l1) O) with | O => S (length l) | S m' => S (Init.Nat.max (length l) m') end
+++++
destruct b; simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.

*****
l,l0,l1 : list bool
xl : list (list bool)
*****
le (length l1) match Init.Nat.max (length l0) (Init.Nat.max (length l1) O) with | O => S (length l) | S m' => S (Init.Nat.max (length l) m') end
+++++
rewrite Nat.max_0_r.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.

*****
l,l0,l1 : list bool
xl : list (list bool)
*****
le (length l1) match Init.Nat.max (length l0) (length l1) with | O => S (length l) | S m' => S (Init.Nat.max (length l) m') end
+++++
case_eq (max (length l0) (length l1)); intros.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.

*****
H : eq (Init.Nat.max (length l0) (length l1)) O
l,l0,l1 : list bool
xl : list (list bool)
*****
le (length l1) (S (length l))
+++++
apply Nat.max_lub_r with (n := length l0).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).

*****
H : eq (Init.Nat.max (length l0) (length l1)) O
l,l0,l1 : list bool
xl : list (list bool)
*****
le (Nat.max (length l0) (length l1)) (S (length l))
+++++
rewrite H; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.

*****
H : eq (Init.Nat.max (length l0) (length l1)) (S n)
n : nat
l,l0,l1 : list bool
xl : list (list bool)
*****
le (length l1) (S (Init.Nat.max (length l) n))
+++++
rewrite Nat.succ_max_distr, <- H.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.

*****
H : eq (Init.Nat.max (length l0) (length l1)) (S n)
n : nat
l,l0,l1 : list bool
xl : list (list bool)
*****
le (length l1) (Nat.max (S (length l)) (Init.Nat.max (length l0) (length l1)))
+++++
eapply le_trans;[ | apply Nat.le_max_r].
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].

*****
H : eq (Init.Nat.max (length l0) (length l1)) (S n)
n : nat
l,l0,l1 : list bool
xl : list (list bool)
*****
le (length l1) (Init.Nat.max (length l0) (length l1))
+++++
apply Nat.le_max_r.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.

*****
l,l0,l1 : list bool
xl : list (list bool)
*****
le O match Init.Nat.max (length l0) (Init.Nat.max (length l1) O) with | O => S (length l) | S m' => S (Init.Nat.max (length l) m') end
+++++
omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.

*****
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length match l with | nil => l0 | cons true _ => l1 | cons false _ => l2 end) (Init.Nat.max (length l) (Init.Nat.max (length l0) (Init.Nat.max (length l1) (maxl (map (length (A:=bool)) (cons l2 yl))))))
+++++
destruct l; simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.

*****
yl : list (list bool)
l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l0) (Init.Nat.max (length l0) (Init.Nat.max (length l1) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))
+++++
apply Nat.le_max_l.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.

*****
yl : list (list bool)
l,l0,l1,l2 : list bool
b : bool
xl : list (list bool)
*****
le (length (if b then l1 else l2)) match Init.Nat.max (length l0) (Init.Nat.max (length l1) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))) with | O => S (length l) | S m' => S (Init.Nat.max (length l) m') end
+++++
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n O
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l1) (S (length l))
+++++
apply Nat.max_lub_l with (m := length l2).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n O
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (Nat.max (length l1) (length l2)) (S (length l))
+++++
apply Nat.max_lub_r with (n := length l0).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n O
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (Nat.max (length l0) (Nat.max (length l1) (length l2))) (S (length l))
+++++
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n O
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (Nat.max (Nat.max (length l0) (Nat.max (length l1) (length l2))) (maxl (map (length (A:=bool)) yl))) (S (length l))
+++++
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l1) (S (Init.Nat.max (length l) n))
+++++
rewrite Nat.succ_max_distr, <- H.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l1) (Nat.max (S (length l)) (Init.Nat.max (length l0) (Init.Nat.max (length l1) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl))))))
+++++
eapply le_trans;[ | apply Nat.le_max_r].
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l1) (Init.Nat.max (length l0) (Init.Nat.max (length l1) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))
+++++
eapply le_trans;[ | apply Nat.le_max_r].
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l1) (Init.Nat.max (length l1) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl))))
+++++
eapply le_trans;[ | apply Nat.le_max_l]; auto.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n O
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l2) (S (length l))
+++++
apply Nat.max_lub_r with (n := length l1).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n O
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (Nat.max (length l1) (length l2)) (S (length l))
+++++
apply Nat.max_lub_r with (n := length l0).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n O
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (Nat.max (length l0) (Nat.max (length l1) (length l2))) (S (length l))
+++++
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n O
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (Nat.max (Nat.max (length l0) (Nat.max (length l1) (length l2))) (maxl (map (length (A:=bool)) yl))) (S (length l))
+++++
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l2) (S (Init.Nat.max (length l) n))
+++++
rewrite Nat.succ_max_distr, <- H.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l2) (Nat.max (S (length l)) (Init.Nat.max (length l0) (Init.Nat.max (length l1) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl))))))
+++++
eapply le_trans;[ | apply Nat.le_max_r].
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l2) (Init.Nat.max (length l0) (Init.Nat.max (length l1) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))
+++++
eapply le_trans;[ | apply Nat.le_max_r].
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l2) (Init.Nat.max (length l1) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl))))
+++++
eapply le_trans;[ | apply Nat.le_max_r].
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].

*****
H : eq\n (Init.Nat.max (length l0)\n (Init.Nat.max (length l1)\n (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))))\n (S n)
n : nat
yl : list (list bool)
l,l0,l1,l2 : list bool
xl : list (list bool)
*****
le (length l2) (Init.Nat.max (length l2) (maxl (map (length (A:=bool)) yl)))
+++++
apply Nat.le_max_l.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.

*****
xl,yl : list (list bool)
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem_rec (sem g) (sem h0) (sem h1) (hd nil xl) (tl xl) yl)) (Init.Nat.add (peval (pplus (pshift (poly_BC (Init.Nat.sub n O) g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
simpl; rewrite <- minus_n_O.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.

*****
xl,yl : list (list bool)
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem_rec (sem g) (sem h0) (sem h1) (hd nil xl) (tl xl) yl)) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
destruct xl as [ | z xl]; simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.

*****
yl : list (list bool)
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem g nil yl)) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) nil) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans;[ apply H2 |]; simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.

*****
yl : list (list bool)
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC n g) nil) (maxl (map (length (A:=bool)) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) nil) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.

*****
xl,yl : list (list bool)
z : list bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (length z) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
induction z as [ | i z IHz ]; simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.

*****
xl,yl : list (list bool)
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem g xl yl)) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons O (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans; [apply H2 |].
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].

*****
xl,yl : list (list bool)
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons O (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.

*****
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).

*****
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).

*****
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
set (qg := peval (poly_BC n g) (map (@length _) xl)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).

*****
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).

*****
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).

*****
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
assert (qh1 <= qh1S).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).

*****
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le qh1 qh1S
+++++
apply peval_monotonic; simpl; intros.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.

*****
i0 : nat
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le match i0 with | O => length z | S m => nth m (map (length (A:=bool)) xl) O end match i0 with | O => S (length z) | S m => nth m (map (length (A:=bool)) xl) O end
+++++
case i0; trivial; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.

*****
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
assert (qh0 <= qh0S).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).

*****
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le qh0 qh0S
+++++
apply peval_monotonic; simpl; intros.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.

*****
i0 : nat
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le match i0 with | O => length z | S m => nth m (map (length (A:=bool)) xl) O end match i0 with | O => S (length z) | S m => nth m (map (length (A:=bool)) xl) O end
+++++
case i0; trivial; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.

*****
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).

*****
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1)) (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
+++++
apply mult_le_compat_l.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.

*****
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add qh0 qh1) (Init.Nat.add qh0S qh1S)
+++++
omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (if i then sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl) else sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
case i.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem h1 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) ?m
+++++
eapply H4; eauto.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) (cons z xl))) (maxl (map (length (A:=bool)) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl)))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h1) (cons (length z) (map (length (A:=bool)) xl))) (Init.Nat.max (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) (maxl (map (length (A:=bool)) yl)))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h1) (cons (length z) (map (length (A:=bool)) xl))) (Init.Nat.max (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) (maxl (map (length (A:=bool)) yl)))) ?m
+++++
apply plus_le_compat_l.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.max (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) (maxl (map (length (A:=bool)) yl))) ?m
+++++
apply Nat.max_le_compat_r.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) ?m
+++++
apply IHz.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h1) (cons (length z) (map (length (A:=bool)) xl))) (Nat.max (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (length z) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl))) (maxl (map (length (A:=bool)) yl)))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite max_l; auto with arith.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h1) (cons (length z) (map (length (A:=bool)) xl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (length z) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem h0 (cons z xl) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl))) ?m
+++++
eapply H3; eauto.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) (cons z xl))) (maxl (map (length (A:=bool)) (cons (sem_rec (sem g) (sem h0) (sem h1) z xl yl) yl)))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h0) (cons (length z) (map (length (A:=bool)) xl))) (Init.Nat.max (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) (maxl (map (length (A:=bool)) yl)))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h0) (cons (length z) (map (length (A:=bool)) xl))) (Init.Nat.max (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) (maxl (map (length (A:=bool)) yl)))) ?m
+++++
apply plus_le_compat_l.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.max (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) (maxl (map (length (A:=bool)) yl))) ?m
+++++
apply Nat.max_le_compat_r.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl)) ?m
+++++
apply IHz.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h0) (cons (length z) (map (length (A:=bool)) xl))) (Nat.max (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (length z) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl))) (maxl (map (length (A:=bool)) yl)))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite max_l; auto with arith.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.

*****
H7 : le (Init.Nat.mul (length z) (Init.Nat.add qh0 qh1))\n (Init.Nat.mul (length z) (Init.Nat.add qh0S qh1S))
H6 : le qh0 qh0S
H5 : le qh1 qh1S
qh0S : nat
qh1S : nat
qg : nat
qh0 : nat
qh1 : nat
IHz : le (length (sem_rec (sem g) (sem h0) (sem h1) z xl yl))\n (Init.Nat.add\n (peval\n (pplus (pshift (poly_BC n g))\n (pmult (pproj (S n) O)\n (pplus (poly_BC (S n) h0) (poly_BC (S n) h1))))\n (cons (length z) (map (length (A:=bool)) xl)))\n (maxl (map (length (A:=bool)) yl)))
xl,yl : list (list bool)
z : list bool
i : bool
H4 : forall xl yl : list (list bool),\nle (length (sem h1 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h1) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall xl yl : list (list bool),\nle (length (sem h0 xl yl))\n (Init.Nat.add (peval (poly_BC (S n) h0) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem g xl yl))\n (Init.Nat.add (peval (poly_BC n g) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (S n) h0) (cons (length z) (map (length (A:=bool)) xl))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (length z) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))) (Init.Nat.add (peval (pplus (pshift (poly_BC n g)) (pmult (pproj (S n) O) (pplus (poly_BC (S n) h0) (poly_BC (S n) h1)))) (cons (S (length z)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (sem h (map (fun ne : BC => sem ne xl nil) rl) (map (fun se : BC => sem se xl yl) tl))) (Init.Nat.add (peval (pplus (pcst n O) (pplus (pcomp (poly_BC (length rl) h) (map (poly_BC n) rl)) (pplusl (map (poly_BC n) tl)))) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (sem h (map (fun ne : BC => sem ne xl nil) rl) (map (fun se : BC => sem se xl yl) tl))) (Init.Nat.add (Init.Nat.add (peval (poly_BC (length rl) h) (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl)) (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (sem h (map (fun ne : BC => sem ne xl nil) rl) (map (fun se : BC => sem se xl yl) tl))) ?m
+++++
apply H2.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (length rl) h) (map (length (A:=bool)) (map (fun ne : BC => sem ne xl nil) rl))) (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))) (Init.Nat.add (Init.Nat.add (peval (poly_BC (length rl) h) (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl)) (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl))) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite <- plus_assoc.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC (length rl) h) (map (length (A:=bool)) (map (fun ne : BC => sem ne xl nil) rl))) (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))) (Nat.add (peval (poly_BC (length rl) h) (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl)) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl))))
+++++
apply plus_le_compat.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (peval (poly_BC (length rl) h) (map (length (A:=bool)) (map (fun ne : BC => sem ne xl nil) rl))) (peval (poly_BC (length rl) h) (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl))
+++++
rewrite map_map.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (peval (poly_BC (length rl) h) (map (fun x : BC => length (sem x xl nil)) rl)) (peval (poly_BC (length rl) h) (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl))
+++++
apply peval_monotonic.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
forall i : nat, le (nth i (map (fun x : BC => length (sem x xl nil)) rl) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl) O)
+++++
intros.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.

*****
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (nth i (map (fun x : BC => length (sem x xl nil)) rl) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl) O)
+++++
destruct (lt_dec i (length rl)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (nth i (map (fun x : BC => length (sem x xl nil)) rl) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl) O)
+++++
erewrite map_nth2.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (sem (nth i rl ?d) xl nil)) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl) O)
+++++
eapply le_trans.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (sem (nth i rl ?d) xl nil)) ?m
+++++
eapply H3.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
In (nth i rl ?d) rl
+++++
apply nth_In; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC n (nth i rl ?d)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) nil))) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl) O)
+++++
simpl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC n (nth i rl ?d)) (map (length (A:=bool)) xl)) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl) O)
+++++
rewrite plus_0_r.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (peval (poly_BC n (nth i rl ?d)) (map (length (A:=bool)) xl)) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl) O)
+++++
erewrite (@map_nth2 _ _ _ _ 0 _ i).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (peval (poly_BC n (nth i rl ?d)) (map (length (A:=bool)) xl)) (peval (poly_BC n (nth i rl ?d0)) (map (length (A:=bool)) xl))
+++++
apply le_refl.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (peval (poly_BC n ?d) (map (length (A:=bool)) xl)) O
+++++
instantiate (1 := zero).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (peval (poly_BC n zero) (map (length (A:=bool)) xl)) O
+++++
simpl; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.

*****
l : lt i (length rl)
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (length (sem zero xl nil)) O
+++++
simpl; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.

*****
n0 : not (lt i (length rl))
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (nth i (map (fun x : BC => length (sem x xl nil)) rl) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl) O)
+++++
rewrite nth_overflow, nth_overflow; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.

*****
n0 : not (lt i (length rl))
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) xl)) rl)) i
+++++
rewrite map_length; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.

*****
n0 : not (lt i (length rl))
i : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (map (fun x : BC => length (sem x xl nil)) rl)) i
+++++
rewrite map_length; omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.

*****
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl))) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
edestruct maxl_nth.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.

*****
H5 : eq (maxl ?l) (nth x ?l O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl))) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
destruct (lt_dec x (length tl)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).

*****
l : lt x (length tl)
H5 : eq (maxl ?l) (nth x ?l O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl))) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite H5.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.

*****
l : lt x (length tl)
H5 : eq (maxl ?l) (nth x ?l O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (nth x (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
erewrite map_nth2.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (nth x (map (fun se : BC => sem se xl yl) tl) ?d)) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
eapply le_trans.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (nth x (map (fun se : BC => sem se xl yl) tl) ?d)) ?m
+++++
erewrite map_nth2.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (sem (nth x tl ?d0) xl yl)) ?m
+++++
eapply H4.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
In (nth x tl ?d0) tl
+++++
apply nth_In; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem ?d0 xl yl) ?d
+++++
instantiate (2 := zero).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (sem zero xl yl) ?d
+++++
simpl; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (Init.Nat.add (peval (poly_BC n (nth x tl zero)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl))) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
apply plus_le_compat_r.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (peval (poly_BC n (nth x tl zero)) (map (length (A:=bool)) xl)) (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl))
+++++
erewrite <- (@map_nth2 _ _ (poly_BC n)).
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (peval (nth x (map (poly_BC n) tl) ?b) (map (length (A:=bool)) xl)) (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl))
+++++
apply peval_nth_pplus.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).
apply peval_nth_pplus.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (poly_BC n zero) (pcst ?n O)
+++++
simpl; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).
apply peval_nth_pplus.
simpl; trivial.

*****
l : lt x (length tl)
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
eq (length nil) O
+++++
simpl; trivial.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).
apply peval_nth_pplus.
simpl; trivial.
simpl; trivial.

*****
n0 : not (lt x (length tl))
H5 : eq (maxl ?l) (nth x ?l O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl))) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite nth_overflow in H5.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).
apply peval_nth_pplus.
simpl; trivial.
simpl; trivial.
rewrite nth_overflow in H5.

*****
n0 : not (lt x (length tl))
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n O
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl))) (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
rewrite H5.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).
apply peval_nth_pplus.
simpl; trivial.
simpl; trivial.
rewrite nth_overflow in H5.
rewrite H5.

*****
n0 : not (lt x (length tl))
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n O
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le O (Nat.add (peval (pplusl (map (poly_BC n) tl)) (map (length (A:=bool)) xl)) (maxl (map (length (A:=bool)) yl)))
+++++
omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).
apply peval_nth_pplus.
simpl; trivial.
simpl; trivial.
rewrite nth_overflow in H5.
rewrite H5.
omega.

*****
n0 : not (lt x (length tl))
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl))) x
+++++
rewrite map_length, map_length.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).
apply peval_nth_pplus.
simpl; trivial.
simpl; trivial.
rewrite nth_overflow in H5.
rewrite H5.
omega.
rewrite map_length, map_length.

*****
n0 : not (lt x (length tl))
H5 : eq\n (maxl (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)))\n (nth x\n (map (length (A:=bool)) (map (fun se : BC => sem se xl yl) tl)) O)
x : nat
xl,yl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H3 : forall (r : BC) (_ : In r rl) (xl yl : list (list bool)),\nle (length (sem r xl yl))\n (Init.Nat.add (peval (poly_BC n r) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H2 : forall xl yl : list (list bool),\nle (length (sem h xl yl))\n (Init.Nat.add\n (peval (poly_BC (length rl) h) (map (length (A:=bool)) xl))\n (maxl (map (length (A:=bool)) yl)))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
*****
le (length tl) x
+++++
omega.
-----
Lemma polymax_bounding : forall (e : BC) xl yl n s, arities e = ok_arities n s -> length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).
Proof.
intros.
revert e n s H xl yl.
refine (BC_ind_inf ((fun n s e => forall xl yl : list bs, length (sem e xl yl) <= peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl))) _ _ _ _ _ _ _); simpl; intros.
omega.
destruct n.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
case_eq (leb i n); intros.
apply leb_complete in H0.
revert i H H0.
induction xl; simpl; intros; simpl; destruct i; simpl; try omega.
rewrite pproj_correct; simpl; omega.
eapply le_trans;[ apply IHxl | ]; trivial; omega.
eapply le_trans;[ apply nth_maxl_bound | ]; trivial.
rewrite hd_nth_0; apply le_n_S; apply nth_maxl_bound; trivial.
eapply le_trans;[ | apply nth_maxl_bound].
instantiate (1:=nil).
rewrite hd_nth_0.
instantiate (1:= 0).
destruct (@nth (list bool) Datatypes.O yl (@nil bool)); simpl; omega.
trivial.
do 3 (destruct yl; simpl; try omega).
destruct l; simpl; auto with arith.
destruct yl.
destruct l; simpl.
auto with arith.
destruct b; simpl.
rewrite Nat.max_0_r.
case_eq (max (length l0) (length l1)); intros.
apply Nat.max_lub_r with (n := length l0).
rewrite H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_r.
omega.
destruct l; simpl.
apply Nat.le_max_l.
destruct b; simpl; case_eq ( max (length l0) (max (length l1) (max (length l2) (maxl (map (@length _) yl))))); intros.
apply Nat.max_lub_l with (m := length l2).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_l]; auto.
apply Nat.max_lub_r with (n := length l1).
apply Nat.max_lub_r with (n := length l0).
apply Nat.max_lub_l with (m := (maxl (map (@length _) yl))).
rewrite <- Nat.max_assoc, <- Nat.max_assoc, H; omega.
rewrite Nat.succ_max_distr, <- H.
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
eapply le_trans;[ | apply Nat.le_max_r].
apply Nat.le_max_l.
simpl; rewrite <- minus_n_O.
destruct xl as [ | z xl]; simpl.
eapply le_trans;[ apply H2 |]; simpl.
rewrite pplus_correct, pmult_correct, pshift_correct; simpl; omega.
induction z as [ | i z IHz ]; simpl.
eapply le_trans; [apply H2 |].
rewrite pplus_correct, pshift_correct; simpl; auto with arith.
set (qh1 := peval (poly_BC (S n) h1) (length z :: map (@length _) xl)).
set (qh0 := peval (poly_BC (S n) h0) (length z :: map (@length _) xl)).
set (qg := peval (poly_BC n g) (map (@length _) xl)).
set (qh1S := peval (poly_BC (S n) h1) (S (length z) :: map (@length _) xl)).
set (qh0S := peval (poly_BC (S n) h0) (S (length z) :: map (@length _) xl)).
assert (qh1 <= qh1S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert (qh0 <= qh0S).
apply peval_monotonic; simpl; intros.
case i0; trivial; omega.
assert ( length z * (qh0 + qh1) <= length z * (qh0S + qh1S)).
apply mult_le_compat_l.
omega.
case i.
eapply le_trans.
eapply H4; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
eapply le_trans.
eapply H3; eauto.
simpl.
eapply le_trans.
apply plus_le_compat_l.
apply Nat.max_le_compat_r.
apply IHz.
rewrite max_l; auto with arith.
rewrite pplus_correct, pplus_correct, pmult_correct, pmult_correct, pplus_correct, pplus_correct, pshift_correct, pshift_correct, pproj_correct, pproj_correct; simpl; unfold qh0, qh1, qh0S, qh1S in *; omega.
rewrite pplus_correct, pcst_correct, pplus_correct, pcomp_correct, map_map; simpl.
eapply le_trans.
apply H2.
rewrite <- plus_assoc.
apply plus_le_compat.
rewrite map_map.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
eapply H3.
apply nth_In; trivial.
simpl.
rewrite plus_0_r.
erewrite (@map_nth2 _ _ _ _ 0 _ i).
apply le_refl.
instantiate (1 := zero).
simpl; trivial.
simpl; trivial.
rewrite nth_overflow, nth_overflow; trivial.
rewrite map_length; omega.
rewrite map_length; omega.
edestruct maxl_nth.
destruct (lt_dec x (length tl)).
rewrite H5.
erewrite map_nth2.
eapply le_trans.
erewrite map_nth2.
eapply H4.
apply nth_In; trivial.
instantiate (2 := zero).
simpl; trivial.
apply plus_le_compat_r.
erewrite <- (@map_nth2 _ _ (poly_BC n)).
apply peval_nth_pplus.
simpl; trivial.
simpl; trivial.
rewrite nth_overflow in H5.
rewrite H5.
omega.
rewrite map_length, map_length.
omega.

*****

*****

+++++
Qed.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d,\n map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) =\n map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).

*****

*****
forall (n m : nat) (ln ls : list (list bool)) (d : list bool), eq (map (fun x : BC => sem x ln (cons d ls)) (map (proj n (S m)) (seq (S n) m))) (map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)))
+++++
Proof.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.

*****

*****
forall (n m : nat) (ln ls : list (list bool)) (d : list bool), eq (map (fun x : BC => sem x ln (cons d ls)) (map (proj n (S m)) (seq (S n) m))) (map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)))
+++++
intros.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.

*****
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (map (fun x : BC => sem x ln (cons d ls)) (map (proj n (S m)) (seq (S n) m))) (map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)))
+++++
rewrite <- seq_shift.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.

*****
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (map (fun x : BC => sem x ln (cons d ls)) (map (proj n (S m)) (map S (seq n m)))) (map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)))
+++++
rewrite map_map with (f := S).
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).

*****
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (map (fun x : BC => sem x ln (cons d ls)) (map (fun x : nat => proj n (S m) (S x)) (seq n m))) (map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)))
+++++
rewrite map_map with (f := (proj n m)).
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).

*****
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (map (fun x : BC => sem x ln (cons d ls)) (map (fun x : nat => proj n (S m) (S x)) (seq n m))) (map (fun x : nat => sem (proj n m x) ln ls) (seq n m))
+++++
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).

*****
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (map (fun x : nat => sem (proj n (S m) (S x)) ln (cons d ls)) (seq n m)) (map (fun x : nat => sem (proj n m x) ln ls) (seq n m))
+++++
apply map_ext2.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.

*****
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
forall (a : nat) (_ : In a (seq n m)), eq (sem (proj n (S m) (S a)) ln (cons d ls)) (sem (proj n m a) ln ls)
+++++
intros.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.

*****
H : In a (seq n m)
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (sem (proj n (S m) (S a)) ln (cons d ls)) (sem (proj n m a) ln ls)
+++++
simpl.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.

*****
H : In a (seq n m)
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (if match n with | S (S m'0) => Nat.leb a m'0 | _ => false end then nth (S a) ln nil else match match n with | O => S a | S l => Init.Nat.sub a l end with | O => d | S m => nth m ls nil end) (if match n with | O => false | S m' => Nat.leb a m' end then nth a ln nil else nth (Init.Nat.sub a n) ls nil)
+++++
rewrite in_seq_iff in H.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.

*****
H : and (le n a) (lt a (Init.Nat.add n m))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (if match n with | S (S m'0) => Nat.leb a m'0 | _ => false end then nth (S a) ln nil else match match n with | O => S a | S l => Init.Nat.sub a l end with | O => d | S m => nth m ls nil end) (if match n with | O => false | S m' => Nat.leb a m' end then nth a ln nil else nth (Init.Nat.sub a n) ls nil)
+++++
destruct n.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.

*****
H : and (le O a) (lt a (Init.Nat.add O m))
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq (nth a ls nil) (nth (Init.Nat.sub a O) ls nil)
+++++
simpl in *.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.

*****
H : and (le O a) (lt a m)
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq (nth a ls nil) (nth (Init.Nat.sub a O) ls nil)
+++++
rewrite <- minus_n_O.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
rewrite <- minus_n_O.

*****
H : and (le O a) (lt a m)
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq (nth a ls nil) (nth a ls nil)
+++++
trivial.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.

*****
H : and (le (S n) a) (lt a (Init.Nat.add (S n) m))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (if match n with | O => false | S m' => Nat.leb a m' end then nth (S a) ln nil else match Init.Nat.sub a n with | O => d | S m => nth m ls nil end) (if Nat.leb a n then nth a ln nil else nth (Init.Nat.sub a (S n)) ls nil)
+++++
simpl in *.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.

*****
H : and (le (S n) a) (lt a (S (Init.Nat.add n m)))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (if match n with | O => false | S m' => Nat.leb a m' end then nth (S a) ln nil else match Init.Nat.sub a n with | O => d | S m => nth m ls nil end) (if Nat.leb a n then nth a ln nil else nth (Init.Nat.sub a (S n)) ls nil)
+++++
destruct n.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.

*****
H : and (le (S O) a) (lt a (S (Init.Nat.add O m)))
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq match Init.Nat.sub a O with | O => d | S m => nth m ls nil end (if Nat.leb a O then nth a ln nil else nth (Init.Nat.sub a (S O)) ls nil)
+++++
simpl in *.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.

*****
H : and (le (S O) a) (lt a (S m))
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq match Init.Nat.sub a O with | O => d | S m => nth m ls nil end (if Nat.leb a O then nth a ln nil else nth (Init.Nat.sub a (S O)) ls nil)
+++++
rewrite <- minus_n_O.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite <- minus_n_O.

*****
H : and (le (S O) a) (lt a (S m))
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq match a with | O => d | S m => nth m ls nil end (if Nat.leb a O then nth a ln nil else nth (Init.Nat.sub a (S O)) ls nil)
+++++
trivial.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite <- minus_n_O.
trivial.

*****
H : and (le (S O) a) (lt a (S m))
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq match a with | O => d | S m => nth m ls nil end (if Nat.leb a O then nth a ln nil else nth (Init.Nat.sub a (S O)) ls nil)
+++++
destruct a.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite <- minus_n_O.
trivial.
destruct a.

*****
H : and (le (S O) O) (lt O (S m))
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq d (if Nat.leb O O then nth O ln nil else nth (Init.Nat.sub O (S O)) ls nil)
+++++
simpl in *.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite <- minus_n_O.
trivial.
destruct a.
simpl in *.

*****
H : and (le (S O) O) (lt O (S m))
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq d (nth O ln nil)
+++++
elimtype False.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite <- minus_n_O.
trivial.
destruct a.
simpl in *.
elimtype False.

*****
H : and (le (S O) O) (lt O (S m))
d : list bool
ln,ls : list (list bool)
m : nat
*****
False
+++++
omega.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite <- minus_n_O.
trivial.
destruct a.

*****
H : and (le (S O) (S a)) (lt (S a) (S m))
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq (nth a ls nil) (if Nat.leb (S a) O then nth (S a) ln nil else nth (Init.Nat.sub (S a) (S O)) ls nil)
+++++
simpl in *.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite <- minus_n_O.
trivial.
destruct a.
simpl in *.

*****
H : and (le (S O) (S a)) (lt (S a) (S m))
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq (nth a ls nil) (nth (Init.Nat.sub a O) ls nil)
+++++
rewrite <- minus_n_O.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite <- minus_n_O.
trivial.
destruct a.
simpl in *.
rewrite <- minus_n_O.

*****
H : and (le (S O) (S a)) (lt (S a) (S m))
a : nat
d : list bool
ln,ls : list (list bool)
m : nat
*****
eq (nth a ls nil) (nth a ls nil)
+++++
trivial.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.

*****
H : and (le (S (S n)) a) (lt a (S (Init.Nat.add (S n) m)))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (if Nat.leb a n then nth (S a) ln nil else match Init.Nat.sub a (S n) with | O => d | S m => nth m ls nil end) (if Nat.leb a (S n) then nth a ln nil else nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
simpl in *.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.

*****
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (if Nat.leb a n then nth (S a) ln nil else match Init.Nat.sub a (S n) with | O => d | S m => nth m ls nil end) (if Nat.leb a (S n) then nth a ln nil else nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
rewrite leb_correct_conv.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.

*****
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq match Init.Nat.sub a (S n) with | O => d | S m => nth m ls nil end (if Nat.leb a (S n) then nth a ln nil else nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
idtac.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.

*****
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq match Init.Nat.sub a (S n) with | O => d | S m => nth m ls nil end (if Nat.leb a (S n) then nth a ln nil else nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
case_eq (a - S n).
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).

*****
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
forall _ : eq (Init.Nat.sub a (S n)) O, eq d (if Nat.leb a (S n) then nth a ln nil else nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
intros.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).
intros.

*****
H0 : eq (Init.Nat.sub a (S n)) O
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq d (if Nat.leb a (S n) then nth a ln nil else nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
elimtype False.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).
intros.
elimtype False.

*****
H0 : eq (Init.Nat.sub a (S n)) O
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
False
+++++
omega.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).

*****
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
forall (n0 : nat) (_ : eq (Init.Nat.sub a (S n)) (S n0)), eq (nth n0 ls nil) (if Nat.leb a (S n) then nth a ln nil else nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
intros.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).
intros.

*****
H0 : eq (Init.Nat.sub a (S n)) (S n0)
n0 : nat
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (nth n0 ls nil) (if Nat.leb a (S n) then nth a ln nil else nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
rewrite leb_correct_conv.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).
intros.
rewrite leb_correct_conv.

*****
H0 : eq (Init.Nat.sub a (S n)) (S n0)
n0 : nat
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (nth n0 ls nil) (nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
idtac.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).
intros.
rewrite leb_correct_conv.
idtac.

*****
H0 : eq (Init.Nat.sub a (S n)) (S n0)
n0 : nat
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq (nth n0 ls nil) (nth (Init.Nat.sub a (S (S n))) ls nil)
+++++
f_equal.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).
intros.
rewrite leb_correct_conv.
idtac.
f_equal.

*****
H0 : eq (Init.Nat.sub a (S n)) (S n0)
n0 : nat
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
eq n0 (Init.Nat.sub a (S (S n)))
+++++
omega.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.
idtac.
case_eq (a - S n).
intros.
rewrite leb_correct_conv.

*****
H0 : eq (Init.Nat.sub a (S n)) (S n0)
n0 : nat
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
lt (S n) a
+++++
omega.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
destruct n.
simpl in *.
rewrite leb_correct_conv.

*****
H : and (le (S (S n)) a) (lt a (S (S (Init.Nat.add n m))))
a : nat
d : list bool
ln,ls : list (list bool)
n,m : nat
*****
lt n a
+++++
omega.
-----
Lemma proj_seq_shift_safe : forall n m ln ls d, map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) = map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n m)).
rewrite map_map with (f := (fun x : nat => proj n (S m) (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.

*****

*****

+++++
Qed.
-----
Lemma proj_seq_shift_normal : forall n ln ls d,\n map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) =\n map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).

*****

*****
forall (n : nat) (ln ls : list (list bool)) (d : list bool), eq (map (fun x : BC => sem x (cons d ln) ls) (map (proj (S n) O) (seq (S O) n))) (map (fun x : BC => sem x ln ls) (map (proj n O) (seq O n)))
+++++
Proof.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.

*****

*****
forall (n : nat) (ln ls : list (list bool)) (d : list bool), eq (map (fun x : BC => sem x (cons d ln) ls) (map (proj (S n) O) (seq (S O) n))) (map (fun x : BC => sem x ln ls) (map (proj n O) (seq O n)))
+++++
intros.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.

*****
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (map (fun x : BC => sem x (cons d ln) ls) (map (proj (S n) O) (seq (S O) n))) (map (fun x : BC => sem x ln ls) (map (proj n O) (seq O n)))
+++++
rewrite <- seq_shift.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.

*****
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (map (fun x : BC => sem x (cons d ln) ls) (map (proj (S n) O) (map S (seq O n)))) (map (fun x : BC => sem x ln ls) (map (proj n O) (seq O n)))
+++++
rewrite map_map with (f := S).
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).

*****
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (map (fun x : BC => sem x (cons d ln) ls) (map (fun x : nat => proj (S n) O (S x)) (seq O n))) (map (fun x : BC => sem x ln ls) (map (proj n O) (seq O n)))
+++++
rewrite map_map with (f := (proj n 0)).
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).

*****
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (map (fun x : BC => sem x (cons d ln) ls) (map (fun x : nat => proj (S n) O (S x)) (seq O n))) (map (fun x : nat => sem (proj n O x) ln ls) (seq O n))
+++++
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).

*****
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (map (fun x : nat => sem (proj (S n) O (S x)) (cons d ln) ls) (seq O n)) (map (fun x : nat => sem (proj n O x) ln ls) (seq O n))
+++++
apply map_ext2.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.

*****
d : list bool
ln,ls : list (list bool)
n : nat
*****
forall (a : nat) (_ : In a (seq O n)), eq (sem (proj (S n) O (S a)) (cons d ln) ls) (sem (proj n O a) ln ls)
+++++
intros.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.

*****
H : In a (seq O n)
a : nat
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (sem (proj (S n) O (S a)) (cons d ln) ls) (sem (proj n O a) ln ls)
+++++
simpl.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.
simpl.

*****
H : In a (seq O n)
a : nat
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (if match n with | O => false | S m' => Nat.leb a m' end then nth a ln nil else nth (Init.Nat.sub a n) ls nil) (if match n with | O => false | S m' => Nat.leb a m' end then nth a ln nil else nth (Init.Nat.sub a n) ls nil)
+++++
rewrite in_seq_iff in H.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.

*****
H : and (le O a) (lt a (Init.Nat.add O n))
a : nat
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (if match n with | O => false | S m' => Nat.leb a m' end then nth a ln nil else nth (Init.Nat.sub a n) ls nil) (if match n with | O => false | S m' => Nat.leb a m' end then nth a ln nil else nth (Init.Nat.sub a n) ls nil)
+++++
destruct n.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.

*****
H : and (le O a) (lt a (Init.Nat.add O O))
a : nat
d : list bool
ln,ls : list (list bool)
*****
eq (nth (Init.Nat.sub a O) ls nil) (nth (Init.Nat.sub a O) ls nil)
+++++
simpl in *.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.

*****
H : and (le O a) (lt a O)
a : nat
d : list bool
ln,ls : list (list bool)
*****
eq (nth (Init.Nat.sub a O) ls nil) (nth (Init.Nat.sub a O) ls nil)
+++++
rewrite <- minus_n_O.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.
rewrite <- minus_n_O.

*****
H : and (le O a) (lt a O)
a : nat
d : list bool
ln,ls : list (list bool)
*****
eq (nth a ls nil) (nth a ls nil)
+++++
trivial.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.

*****
H : and (le O a) (lt a (Init.Nat.add O (S n)))
a : nat
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (if Nat.leb a n then nth a ln nil else nth (Init.Nat.sub a (S n)) ls nil) (if Nat.leb a n then nth a ln nil else nth (Init.Nat.sub a (S n)) ls nil)
+++++
simpl in *.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.
simpl in *.

*****
H : and (le O a) (lt a (S n))
a : nat
d : list bool
ln,ls : list (list bool)
n : nat
*****
eq (if Nat.leb a n then nth a ln nil else nth (Init.Nat.sub a (S n)) ls nil) (if Nat.leb a n then nth a ln nil else nth (Init.Nat.sub a (S n)) ls nil)
+++++
trivial.
-----
Lemma proj_seq_shift_normal : forall n ln ls d, map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) = map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).
Proof.
intros.
rewrite <- seq_shift.
rewrite map_map with (f := S).
rewrite map_map with (f := (proj n 0)).
rewrite map_map with (f := (fun x : nat => proj (S n) 0 (S x))).
apply map_ext2.
intros.
simpl.
rewrite in_seq_iff in H.
destruct n.

*****

*****

+++++
Qed.
-----
Section TIME.
-----
Variable ptime_zero_cost ptime_succ_cost ptime_pred_cost ptime_cond_cost: nat.
-----
Variable ptime_proj_cost : nat -> nat -> nat -> nat.
-----
Fixpoint sem_cost_rec (sem_g sem_h0 sem_h1:list bs->list bs->bs*nat)(v:bs)(vnl vsl:list bs) :\n    bs * nat :=\n    match v with\n      | nil => sem_g vnl vsl\n      | b::v' =>\n        if b\n          then\n            let sem_cost := sem_cost_rec sem_g sem_h0 sem_h1 v' vnl vsl in\n              let sem_cost_h := sem_h1 (v'::vnl) (fst sem_cost :: vsl) in\n                (fst sem_cost_h, snd sem_cost + snd sem_cost_h)\n          else\n            let sem_cost := sem_cost_rec sem_g sem_h0 sem_h1 v' vnl vsl in\n              let sem_cost_h := sem_h0 (v'::vnl) (fst sem_cost :: vsl) in\n                (fst sem_cost_h, snd sem_cost + snd sem_cost_h)\n    end.
-----
Fixpoint sem_cost (e:BC)(vnl vsl:list bs) : bs*nat :=\n match e with\n | zero => (nil, ptime_zero_cost)\n | proj n s j => (\n   if leb (S j) n then\n     nth j vnl nil\n     else nth (j-n) vsl nil, ptime_proj_cost n s j\n   )\n | succ b => (b :: hd nil vsl, ptime_succ_cost)\n | pred => (tail (hd nil vsl), ptime_pred_cost)\n | cond => (\n     match vsl with\n     | a :: b :: c :: d :: _ =>\n       match a with\n         | nil => b\n         | true :: _ => c\n         | false :: _ => d\n       end\n     | a :: b :: c :: _ =>\n       match a with\n         | nil => b\n         | true :: _ => c\n         | false :: _ => nil\n       end\n     | a :: b :: _ =>\n       match a with\n         | nil => b\n         | _ => nil\n       end\n     | _ => nil\n     end, ptime_cond_cost\n   )\n | rec g h0 h1 =>\n     sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) (hd nil vnl) (tail vnl) vsl\n | comp _ _ h nl sl =>\n   let sem_cost_nl := List.map (fun ne => sem_cost ne vnl nil) nl in\n   let sem_cost_sl := List.map (fun se => sem_cost se vnl vsl) sl in\n   let sem_nl := List.map (@fst _ _) sem_cost_nl in\n   let sem_sl := List.map (@fst _ _) sem_cost_sl in\n   let cost_nl := List.map (@snd _ _) sem_cost_nl in\n   let cost_sl := List.map (@snd _ _) sem_cost_sl in\n   let sem_cost_h := sem_cost h sem_nl sem_sl in\n   (fst sem_cost_h, snd sem_cost_h + plusl cost_nl + plusl cost_sl)\n end.
-----
Lemma sem_cost_correct :\n forall e n s,\n arities e = ok_arities n s ->\n forall vnl vsl,\n fst (sem_cost e vnl vsl) = sem e vnl vsl.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.

*****
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)) (vnl vsl : list (list bool)), eq (fst (sem_cost e vnl vsl)) (sem e vnl vsl)
+++++
Proof.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.

*****
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)) (vnl vsl : list (list bool)), eq (fst (sem_cost e vnl vsl)) (sem e vnl vsl)
+++++
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.

*****
vnl,vsl : list (list bool)
H4 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h1 vnl vsl)) (sem h1 vnl vsl)
H3 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h0 vnl vsl)) (sem h0 vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost g vnl vsl)) (sem g vnl vsl)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) (hd nil vnl) (tl vnl) vsl)) (sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tl vnl) vsl)
+++++
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h vnl vsl)) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst (sem_cost h (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)) (map fst (map (fun se : BC => sem_cost se vnl vsl) tl)))) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
rewrite H2.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
rewrite H2.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h vnl vsl)) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (sem h (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)) (map fst (map (fun se : BC => sem_cost se vnl vsl) tl))) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
do 2 rewrite map_map.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
rewrite H2.
do 2 rewrite map_map.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h vnl vsl)) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (sem h (map (fun x : BC => fst (sem_cost x vnl nil)) rl) (map (fun x : BC => fst (sem_cost x vnl vsl)) tl)) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
clear H.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
rewrite H2.
do 2 rewrite map_map.
clear H.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h vnl vsl)) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (sem h (map (fun x : BC => fst (sem_cost x vnl nil)) rl) (map (fun x : BC => fst (sem_cost x vnl vsl)) tl)) (sem h (map (fun ne : BC => sem ne vnl nil) rl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
f_equal.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
rewrite H2.
do 2 rewrite map_map.
clear H.
f_equal.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h vnl vsl)) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (map (fun x : BC => fst (sem_cost x vnl nil)) rl) (map (fun ne : BC => sem ne vnl nil) rl)
+++++
induction rl; simpl; intros; trivial.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
rewrite H2.
do 2 rewrite map_map.
clear H.
f_equal.
induction rl; simpl; intros; trivial.

*****
IHrl : forall\n (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O))\n (_ : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\n eq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)),\neq (map (fun x : BC => fst (sem_cost x vnl nil)) rl)\n (map (fun ne : BC => sem ne vnl nil) rl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r (cons a rl)) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h vnl vsl)) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e (cons a rl)), eq (arities e) (ok_arities n O)
rl,tl : list BC
h,a : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (cons (fst (sem_cost a vnl nil)) (map (fun x : BC => fst (sem_cost x vnl nil)) rl)) (cons (sem a vnl nil) (map (fun ne : BC => sem ne vnl nil) rl))
+++++
rewrite H3, IHrl; auto with *.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
rewrite H2.
do 2 rewrite map_map.
clear H.
f_equal.
induction rl; simpl; intros; trivial.
rewrite H3, IHrl; auto with *.

*****
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h vnl vsl)) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
rl,tl : list BC
h : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (map (fun x : BC => fst (sem_cost x vnl vsl)) tl) (map (fun se : BC => sem se vnl vsl) tl)
+++++
induction tl; simpl; intros; trivial.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
rewrite H2.
do 2 rewrite map_map.
clear H.
f_equal.
induction rl; simpl; intros; trivial.
rewrite H3, IHrl; auto with *.
induction tl; simpl; intros; trivial.

*****
IHtl : forall\n (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s))\n (_ : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool)),\n eq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)),\neq (map (fun x : BC => fst (sem_cost x vnl vsl)) tl)\n (map (fun se : BC => sem se vnl vsl) tl)
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r (cons a tl)) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool)),\neq (fst (sem_cost r vnl vsl)) (sem r vnl vsl)
H2 : forall vnl vsl : list (list bool),\neq (fst (sem_cost h vnl vsl)) (sem h vnl vsl)
H1 : forall (e : BC) (_ : In e (cons a tl)), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
tl : list BC
a : BC
rl : list BC
h : BC
n,s : nat
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (cons (fst (sem_cost a vnl vsl)) (map (fun x : BC => fst (sem_cost x vnl vsl)) tl)) (cons (sem a vnl vsl) (map (fun se : BC => sem se vnl vsl) tl))
+++++
rewrite H4, IHtl; auto with *.
-----
Lemma sem_cost_correct : forall e n s, arities e = ok_arities n s -> forall vnl vsl, fst (sem_cost e vnl vsl) = sem e vnl vsl.
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; trivial; intros.
induction (hd nil vnl) as [ | [ | ] ]; simpl; trivial; congruence.
rewrite H2.
do 2 rewrite map_map.
clear H.
f_equal.
induction rl; simpl; intros; trivial.
rewrite H3, IHrl; auto with *.
induction tl; simpl; intros; trivial.
rewrite H4, IHtl; auto with *.

*****

*****

+++++
Qed.
-----
Variable ptime_zero ptime_succ ptime_pred ptime_cond: pol.
-----
Variable ptime_proj : nat -> nat -> nat -> pol.
-----
Hypothesis ptime_zero_spec : \n    snd (sem_cost zero nil nil) <= peval ptime_zero nil.
-----
Hypothesis ptime_zero_wf : pWF ptime_zero.
-----
Hypothesis ptime_zero_arity : parity ptime_zero = 0.
-----
Hypothesis ptime_succ_spec : forall b,\n    snd (sem_cost (succ b) nil nil) <= peval ptime_succ nil.
-----
Hypothesis ptime_succ_wf : pWF ptime_succ.
-----
Hypothesis ptime_succ_arity : parity ptime_succ = 0.
-----
Hypothesis ptime_proj_spec : forall n s i l,\n    length l = n ->\n    snd (sem_cost (proj n s i) l nil) <= peval (ptime_proj n s i) (map (@length _) l).
-----
Hypothesis ptime_proj_wf : forall n s i, pWF (ptime_proj n s i).
-----
Hypothesis ptime_proj_arity : forall n s i, parity (ptime_proj n s i) = n.
-----
Hypothesis ptime_cond_spec : \n    snd (sem_cost cond nil nil) <= peval ptime_cond nil.
-----
Hypothesis ptime_cond_wf : pWF ptime_cond.
-----
Hypothesis ptime_cond_arity : parity ptime_cond = 0.
-----
Hypothesis ptime_pred_spec : \n    snd (sem_cost pred nil nil) <= peval ptime_pred nil.
-----
Hypothesis ptime_pred_wf : pWF ptime_pred.
-----
Hypothesis ptime_pred_arity : parity ptime_pred = 0.
-----
Fixpoint poly_time n (e:BC) : pol :=\n  match e with\n    | zero => ptime_zero\n    | succ _ => ptime_succ\n    | pred => ptime_pred\n    | cond  => ptime_cond\n    | proj n s i => ptime_proj n s i\n    | rec g h0 h1 => \n      pplus (pshift (poly_time (n - 1) g))\n      (pmult (pproj n 0) (pplus (poly_time n h0) (poly_time n h1)))\n    | comp n0 s h rl tl =>\n      pplus (pplus (pcst n0 0) (pcomp (poly_time (length rl) h) (map (poly_BC n0) rl)))\n      (pplus (pplusl (map (poly_time n0) rl)) (pplusl (map (poly_time n0) tl)))\n  end.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), pWF (poly_time n e)
+++++
Proof.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), pWF (poly_time n e)
+++++
refine (BC_ind_inf _ _ _ _ _ _ _ _).
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time O zero)
+++++
simpl.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF ptime_zero
+++++
trivial.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), pWF (poly_time n (proj n s i))
+++++
simpl.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), pWF (ptime_proj n s i)
+++++
trivial.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall b : bool, pWF (poly_time O (succ b))
+++++
simpl.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall _ : bool, pWF ptime_succ
+++++
trivial.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time O pred)
+++++
simpl.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF ptime_pred
+++++
trivial.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time O cond)
+++++
simpl.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF ptime_cond
+++++
trivial.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : pWF (poly_time n g)) (_ : pWF (poly_time (S n) h0)) (_ : pWF (poly_time (S n) h1)), pWF (poly_time (S n) (rec g h0 h1))
+++++
simpl.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : pWF (poly_time n g)) (_ : pWF (poly_time (S n) h0)) (_ : pWF (poly_time (S n) h1)), pWF (pplus (pshift (poly_time (Init.Nat.sub n O) g)) (pmult (pproj (S n) O) (pplus (poly_time (S n) h0) (poly_time (S n) h1))))
+++++
trivial.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : pWF (poly_time n g)) (_ : pWF (poly_time (S n) h0)) (_ : pWF (poly_time (S n) h1)), pWF (pplus (pshift (poly_time (Init.Nat.sub n O) g)) (pmult (pproj (S n) O) (pplus (poly_time (S n) h0) (poly_time (S n) h1))))
+++++
intros.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.

*****
H4 : pWF (poly_time (S n) h1)
H3 : pWF (poly_time (S n) h0)
H2 : pWF (poly_time n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (pplus (pshift (poly_time (Init.Nat.sub n O) g)) (pmult (pproj (S n) O) (pplus (poly_time (S n) h0) (poly_time (S n) h1))))
+++++
try pWF.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.

*****
H4 : pWF (poly_time (S n) h1)
H3 : pWF (poly_time (S n) h0)
H2 : pWF (poly_time n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time (Init.Nat.sub n O) g)
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.

*****
H4 : pWF (poly_time (S n) h1)
H3 : pWF (poly_time (S n) h0)
H2 : pWF (poly_time n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time (Init.Nat.sub n O) g)
+++++
rewrite <- minus_n_O.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
rewrite <- minus_n_O.

*****
H4 : pWF (poly_time (S n) h1)
H3 : pWF (poly_time (S n) h0)
H2 : pWF (poly_time n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time n g)
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.

*****
H4 : pWF (poly_time (S n) h1)
H3 : pWF (poly_time (S n) h0)
H2 : pWF (poly_time n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time (S n) h0)
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.

*****
H4 : pWF (poly_time (S n) h1)
H3 : pWF (poly_time (S n) h0)
H2 : pWF (poly_time n g)
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time (S n) h1)
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : pWF (poly_time (length rl) h)) (_ : forall (r : BC) (_ : In r rl), pWF (poly_time n r)) (_ : forall (r : BC) (_ : In r tl), pWF (poly_time n r)), pWF (poly_time n (comp n s h rl tl))
+++++
simpl.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : pWF (poly_time (length rl) h)) (_ : forall (r : BC) (_ : In r rl), pWF (poly_time n r)) (_ : forall (r : BC) (_ : In r tl), pWF (poly_time n r)), pWF (pplus (pplus (pcst n O) (pcomp (poly_time (length rl) h) (map (poly_BC n) rl))) (pplus (pplusl (map (poly_time n) rl)) (pplusl (map (poly_time n) tl))))
+++++
trivial.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : pWF (poly_time (length rl) h)) (_ : forall (r : BC) (_ : In r rl), pWF (poly_time n r)) (_ : forall (r : BC) (_ : In r tl), pWF (poly_time n r)), pWF (pplus (pplus (pcst n O) (pcomp (poly_time (length rl) h) (map (poly_BC n) rl))) (pplus (pplusl (map (poly_time n) rl)) (pplusl (map (poly_time n) tl))))
+++++
intros.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.

*****
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (pplus (pplus (pcst n O) (pcomp (poly_time (length rl) h) (map (poly_BC n) rl))) (pplus (pplusl (map (poly_time n) rl)) (pplusl (map (poly_time n) tl))))
+++++
try pWF.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.

*****
H5 : In x (map (poly_BC n) rl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.

*****
H5 : In x (map (poly_BC n) rl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
apply in_map_iff in H5.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.

*****
H5 : ex (fun x0 : BC => and (eq (poly_BC n x0) x) (In x0 rl))
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
destruct H5 as [e2 [H5 H7] ].
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.
destruct H5 as [e2 [H5 H7] ].

*****
H7 : In e2 rl
H5 : eq (poly_BC n e2) x
e2 : BC
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
subst.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.
destruct H5 as [e2 [H5 H7] ].
subst.

*****
H7 : In e2 rl
e2 : BC
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_BC n e2)
+++++
eapply pWF_poly_BC.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.
destruct H5 as [e2 [H5 H7] ].
subst.
eapply pWF_poly_BC.

*****
H7 : In e2 rl
e2 : BC
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (arities e2) (ok_arities n ?s)
+++++
eauto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.

*****
H5 : In x (map (poly_time n) rl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.

*****
H5 : In x (map (poly_time n) rl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
apply in_map_iff in H5.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.

*****
H5 : ex (fun x0 : BC => and (eq (poly_time n x0) x) (In x0 rl))
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
destruct H5 as [e2 [H5 H7] ].
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.
destruct H5 as [e2 [H5 H7] ].

*****
H7 : In e2 rl
H5 : eq (poly_time n e2) x
e2 : BC
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
subst.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.
destruct H5 as [e2 [H5 H7] ].
subst.

*****
H7 : In e2 rl
e2 : BC
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time n e2)
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.

*****
H5 : In x (map (poly_time n) tl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.

*****
H5 : In x (map (poly_time n) tl)
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
apply in_map_iff in H5.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.

*****
H5 : ex (fun x0 : BC => and (eq (poly_time n x0) x) (In x0 tl))
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
destruct H5 as [e2 [H5 H7] ].
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.
destruct H5 as [e2 [H5 H7] ].

*****
H7 : In e2 tl
H5 : eq (poly_time n e2) x
e2 : BC
x : pol
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF x
+++++
subst.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).
simpl.
trivial.
intros.
try pWF.
auto.
apply in_map_iff in H5.
destruct H5 as [e2 [H5 H7] ].
subst.

*****
H7 : In e2 tl
e2 : BC
H4 : forall (r : BC) (_ : In r tl), pWF (poly_time n r)
H3 : forall (r : BC) (_ : In r rl), pWF (poly_time n r)
H2 : pWF (poly_time (length rl) h)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
pWF (poly_time n e2)
+++++
auto.
-----
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _).

*****

*****

+++++
Qed.
-----
Lemma arity_poly_time : forall e n s,\n  arities e = ok_arities n s ->\n  parity (poly_time n e) = n.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), eq (fst (poly_time n e)) n
+++++
Proof.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)), eq (fst (poly_time n e)) n
+++++
apply BC_ind_inf.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst (poly_time O zero)) O
+++++
simpl.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst ptime_zero) O
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst ptime_zero) O
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), eq (fst (poly_time n (proj n s i))) n
+++++
simpl.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s i : nat) (_ : lt i (Init.Nat.add n s)), eq (fst (ptime_proj n s i)) n
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H : lt i (Init.Nat.add n s)
n,s,i : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst (ptime_proj n s i)) n
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall b : bool, eq (fst (poly_time O (succ b))) O
+++++
simpl.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall _ : bool, eq (fst ptime_succ) O
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
b : bool
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst ptime_succ) O
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst (poly_time O pred)) O
+++++
simpl.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst ptime_pred) O
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst ptime_pred) O
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst (poly_time O cond)) O
+++++
simpl.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst ptime_cond) O
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst ptime_cond) O
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : eq (fst (poly_time n g)) n) (_ : eq (fst (poly_time (S n) h0)) (S n)) (_ : eq (fst (poly_time (S n) h1)) (S n)), eq (fst (poly_time (S n) (rec g h0 h1))) (S n)
+++++
simpl.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (g h0 h1 : BC) (_ : eq (arities g) (ok_arities n s)) (_ : eq (arities h0) (ok_arities (S n) (S s))) (_ : eq (arities h1) (ok_arities (S n) (S s))) (_ : eq (fst (poly_time n g)) n) (_ : eq (fst (poly_time (S n) h0)) (S n)) (_ : eq (fst (poly_time (S n) h1)) (S n)), eq match match Init.Nat.max (fst (poly_time (S n) h0)) (fst (poly_time (S n) h1)) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_time (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_time (Init.Nat.sub n O) g)) m') end (S n)
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H4 : eq (fst (poly_time (S n) h1)) (S n)
H3 : eq (fst (poly_time (S n) h0)) (S n)
H2 : eq (fst (poly_time n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq match match Init.Nat.max (fst (poly_time (S n) h0)) (fst (poly_time (S n) h1)) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_time (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_time (Init.Nat.sub n O) g)) m') end (S n)
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
H4 : eq (fst (poly_time (S n) h1)) (S n)
H3 : eq (fst (poly_time (S n) h0)) (S n)
H2 : eq (fst (poly_time n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq match match Init.Nat.max (fst (poly_time (S n) h0)) (fst (poly_time (S n) h1)) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_time (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_time (Init.Nat.sub n O) g)) m') end (S n)
+++++
rewrite H3.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.

*****
H4 : eq (fst (poly_time (S n) h1)) (S n)
H3 : eq (fst (poly_time (S n) h0)) (S n)
H2 : eq (fst (poly_time n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq match match Init.Nat.max (S n) (fst (poly_time (S n) h1)) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_time (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_time (Init.Nat.sub n O) g)) m') end (S n)
+++++
rewrite H4.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.
rewrite H4.

*****
H4 : eq (fst (poly_time (S n) h1)) (S n)
H3 : eq (fst (poly_time (S n) h0)) (S n)
H2 : eq (fst (poly_time n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq match match Init.Nat.max (S n) (S n) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_time (Init.Nat.sub n O) g)) | S m' => S (Init.Nat.max (fst (poly_time (Init.Nat.sub n O) g)) m') end (S n)
+++++
rewrite <- minus_n_O.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.
rewrite H4.
rewrite <- minus_n_O.

*****
H4 : eq (fst (poly_time (S n) h1)) (S n)
H3 : eq (fst (poly_time (S n) h0)) (S n)
H2 : eq (fst (poly_time n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq match match Init.Nat.max (S n) (S n) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S (fst (poly_time n g)) | S m' => S (Init.Nat.max (fst (poly_time n g)) m') end (S n)
+++++
rewrite H2.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.
rewrite H4.
rewrite <- minus_n_O.
rewrite H2.

*****
H4 : eq (fst (poly_time (S n) h1)) (S n)
H3 : eq (fst (poly_time (S n) h0)) (S n)
H2 : eq (fst (poly_time n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq match match Init.Nat.max (S n) (S n) with | O => S n | S m' => S (Init.Nat.max n m') end with | O => S n | S m' => S (Init.Nat.max n m') end (S n)
+++++
rewrite !Nat.max_idempotent.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite H3.
rewrite H4.
rewrite <- minus_n_O.
rewrite H2.
rewrite !Nat.max_idempotent.

*****
H4 : eq (fst (poly_time (S n) h1)) (S n)
H3 : eq (fst (poly_time (S n) h0)) (S n)
H2 : eq (fst (poly_time n g)) n
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (S n) (S n)
+++++
trivial.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : eq (fst (poly_time (length rl) h)) (length rl)) (_ : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n) (_ : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n), eq (fst (poly_time n (comp n s h rl tl))) n
+++++
simpl.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (n s : nat) (h : BC) (rl tl : list BC) (_ : eq (arities h) (ok_arities (length rl) (length tl))) (_ : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)) (_ : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)) (_ : eq (fst (poly_time (length rl) h)) (length rl)) (_ : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n) (_ : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n), eq (Init.Nat.max (Init.Nat.max n (maxl (map fst (map (poly_BC n) rl)))) (Init.Nat.max (fst (pplusl (map (poly_time n) rl))) (fst (pplusl (map (poly_time n) tl))))) n
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (Init.Nat.max (Init.Nat.max n (maxl (map fst (map (poly_BC n) rl)))) (Init.Nat.max (fst (pplusl (map (poly_time n) rl))) (fst (pplusl (map (poly_time n) tl))))) n
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (Init.Nat.max (Init.Nat.max n (maxl (map fst (map (poly_BC n) rl)))) (Init.Nat.max (fst (pplusl (map (poly_time n) rl))) (fst (pplusl (map (poly_time n) tl))))) n
+++++
rewrite !parity_pplusl.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (Init.Nat.max (Init.Nat.max n (maxl (map fst (map (poly_BC n) rl)))) (Init.Nat.max (maxl (map fst (map (poly_time n) rl))) (maxl (map fst (map (poly_time n) tl))))) n
+++++
rewrite !map_map.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (Init.Nat.max (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl))) (Init.Nat.max (maxl (map (fun x : BC => fst (poly_time n x)) rl)) (maxl (map (fun x : BC => fst (poly_time n x)) tl)))) n
+++++
rewrite max_l.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl))) n
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl))) n
+++++
rewrite max_l.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
rewrite max_l.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq n n
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
rewrite max_l.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (maxl (map (fun x : BC => fst (poly_BC n x)) rl)) n
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
rewrite max_l.
auto.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (maxl (map (fun x : BC => fst (poly_BC n x)) rl)) n
+++++
apply maxl_map.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
rewrite max_l.
auto.
apply maxl_map.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (x : BC) (_ : In x rl), eq (fst (poly_BC n x)) n
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
rewrite max_l.
auto.
apply maxl_map.
intros.

*****
H5 : In x rl
x : BC
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst (poly_BC n x)) n
+++++
eapply arity_poly_BC.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
rewrite max_l.
auto.
apply maxl_map.
intros.
eapply arity_poly_BC.

*****
H5 : In x rl
x : BC
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (arities x) (ok_arities n ?s)
+++++
eauto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.max (maxl (map (fun x : BC => fst (poly_time n x)) rl)) (maxl (map (fun x : BC => fst (poly_time n x)) tl))) (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.max (maxl (map (fun x : BC => fst (poly_time n x)) rl)) (maxl (map (fun x : BC => fst (poly_time n x)) tl))) (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
apply Nat.max_lub.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (maxl (map (fun x : BC => fst (poly_time n x)) rl)) (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
apply maxl_bound_in.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply maxl_bound_in.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e' : nat) (_ : In e' (map (fun x : BC => fst (poly_time n x)) rl)), le e' (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply maxl_bound_in.
intros.

*****
H5 : In e' (map (fun x : BC => fst (poly_time n x)) rl)
e' : nat
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le e' (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
rewrite in_map_iff in H5.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply maxl_bound_in.
intros.
rewrite in_map_iff in H5.

*****
H5 : ex (fun x : BC => and (eq (fst (poly_time n x)) e') (In x rl))
e' : nat
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le e' (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
destruct H5 as [p [Hp1 Hp2]].
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply maxl_bound_in.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].

*****
Hp2 : In p rl
Hp1 : eq (fst (poly_time n p)) e'
p : BC
e' : nat
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le e' (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
rewrite <- Hp1.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply maxl_bound_in.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].
rewrite <- Hp1.

*****
Hp2 : In p rl
Hp1 : eq (fst (poly_time n p)) e'
p : BC
e' : nat
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (fst (poly_time n p)) (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
rewrite H3.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply maxl_bound_in.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].
rewrite <- Hp1.
rewrite H3.

*****
Hp2 : In p rl
Hp1 : eq (fst (poly_time n p)) e'
p : BC
e' : nat
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le n (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
trivial.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply maxl_bound_in.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].
rewrite <- Hp1.
rewrite H3.
trivial.

*****
Hp2 : In p rl
Hp1 : eq (fst (poly_time n p)) e'
p : BC
e' : nat
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le n (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
apply Nat.le_max_l.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply maxl_bound_in.
intros.
rewrite in_map_iff in H5.
destruct H5 as [p [Hp1 Hp2]].
rewrite <- Hp1.
rewrite H3.

*****
Hp2 : In p rl
Hp1 : eq (fst (poly_time n p)) e'
p : BC
e' : nat
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
In p rl
+++++
trivial.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (maxl (map (fun x : BC => fst (poly_time n x)) tl)) (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
apply le_trans with n.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply le_trans with n.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (maxl (map (fun x : BC => fst (poly_time n x)) tl)) n
+++++
apply maxl_map.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply le_trans with n.
apply maxl_map.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (x : BC) (_ : In x tl), eq (fst (poly_time n x)) n
+++++
intros.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply le_trans with n.
apply maxl_map.
intros.

*****
H5 : In x tl
x : BC
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (fst (poly_time n x)) n
+++++
apply H4.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply le_trans with n.
apply maxl_map.
intros.
apply H4.

*****
H5 : In x tl
x : BC
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
In x tl
+++++
auto.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.
simpl.
intros.
auto.
rewrite !parity_pplusl.
rewrite !map_map.
rewrite max_l.
auto.
apply Nat.max_lub.
apply le_trans with n.

*****
H4 : forall (r : BC) (_ : In r tl), eq (fst (poly_time n r)) n
H3 : forall (r : BC) (_ : In r rl), eq (fst (poly_time n r)) n
H2 : eq (fst (poly_time (length rl) h)) (length rl)
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le n (Init.Nat.max n (maxl (map (fun x : BC => fst (poly_BC n x)) rl)))
+++++
apply Nat.le_max_l.
-----
Lemma arity_poly_time : forall e n s, arities e = ok_arities n s -> parity (poly_time n e) = n.
Proof.
apply BC_ind_inf.

*****

*****

+++++
Qed.
-----
Lemma sem_cost_bounded : forall e n s,\n arities e = ok_arities n s ->\n (forall vnl vsl,\n   length vnl = n -> \n   length vsl = s -> \n   snd (sem_cost e vnl vsl) <=\n   peval (poly_time n e) (List.map (@length _) vnl)).
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)) (vnl vsl : list (list bool)) (_ : eq (length vnl) n) (_ : eq (length vsl) s), le (snd (sem_cost e vnl vsl)) (peval (poly_time n e) (map (length (A:=bool)) vnl))
+++++
Proof.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.

*****
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (e : BC) (n s : nat) (_ : eq (arities e) (ok_arities n s)) (vnl vsl : list (list bool)) (_ : eq (length vnl) n) (_ : eq (length vsl) s), le (snd (sem_cost e vnl vsl)) (peval (poly_time n e) (map (length (A:=bool)) vnl))
+++++
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.

*****
H0 : eq (length vsl) O
H : eq (length vnl) O
vnl,vsl : list (list bool)
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le ptime_zero_cost (peval ptime_zero (map (length (A:=bool)) vnl))
+++++
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.

*****
H1 : eq (length vsl) s
H0 : eq (length vnl) n
vnl,vsl : list (list bool)
H : lt i (Init.Nat.add n s)
n,s,i : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (ptime_proj_cost n s i) (peval (ptime_proj n s i) (map (length (A:=bool)) vnl))
+++++
apply (ptime_proj_spec n s i vnl); trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.

*****
H0 : eq (length vsl) (S O)
H : eq (length vnl) O
vnl,vsl : list (list bool)
b : bool
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le ptime_succ_cost (peval ptime_succ (map (length (A:=bool)) vnl))
+++++
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).

*****
H0 : eq (length vsl) (S O)
H : eq (length vnl) O
vnl,vsl : list (list bool)
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le ptime_pred_cost (peval ptime_pred (map (length (A:=bool)) vnl))
+++++
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.

*****
H0 : eq (length vsl) (S (S (S (S O))))
H : eq (length vnl) O
vnl,vsl : list (list bool)
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le ptime_cond_cost (peval ptime_cond (map (length (A:=bool)) vnl))
+++++
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) (S n)
vnl,vsl : list (list bool)
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) (hd nil vnl) (tl vnl) vsl)) (peval (pplus (pshift (poly_time (Init.Nat.sub n O) g)) (pmult (pproj (S n) O) (pplus (poly_time (S n) h0) (poly_time (S n) h1)))) (map (length (A:=bool)) vnl))
+++++
rewrite !pplus_correct, pshift_correct.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) (S n)
vnl,vsl : list (list bool)
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) (hd nil vnl) (tl vnl) vsl)) (Init.Nat.add (peval (poly_time (Init.Nat.sub n O) g) (tl (map (length (A:=bool)) vnl))) (peval (pmult (pproj (S n) O) (pplus (poly_time (S n) h0) (poly_time (S n) h1))) (map (length (A:=bool)) vnl)))
+++++
rewrite pmult_correct, pplus_correct, pproj_correct.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) (S n)
vnl,vsl : list (list bool)
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) (hd nil vnl) (tl vnl) vsl)) (Init.Nat.add (peval (poly_time (Init.Nat.sub n O) g) (tl (map (length (A:=bool)) vnl))) (Init.Nat.mul (nth O (map (length (A:=bool)) vnl) O) (Init.Nat.add (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl)) (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl)))))
+++++
rewrite <- minus_n_O.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) (S n)
vnl,vsl : list (list bool)
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) (hd nil vnl) (tl vnl) vsl)) (Init.Nat.add (peval (poly_time n g) (tl (map (length (A:=bool)) vnl))) (Init.Nat.mul (nth O (map (length (A:=bool)) vnl) O) (Init.Nat.add (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl)) (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl)))))
+++++
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].

*****
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))))
+++++
induction x; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.

*****
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost g vnl vsl)) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) O)
+++++
rewrite <- plus_n_O; auto.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
a : bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (if a then pair (fst (sem_cost h1 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl))) (Init.Nat.add (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) (snd (sem_cost h1 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl)))) else pair (fst (sem_cost h0 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl))) (Init.Nat.add (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) (snd (sem_cost h0 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl)))))) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Init.Nat.add (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))))
+++++
destruct a; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) (snd (sem_cost h1 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl)))) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Init.Nat.add (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))))
+++++
eapply le_trans.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) (snd (sem_cost h1 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl)))) ?m
+++++
apply plus_le_compat.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) ?m
+++++
apply IHx.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost h1 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl))) ?q
+++++
apply H4; simpl; omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl)))))) (peval (poly_time (S n) h1) (map (length (A:=bool)) (cons x vnl)))) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Init.Nat.add (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))))
+++++
rewrite <- !plus_assoc; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Nat.add (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (Nat.add (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))))))))
+++++
apply plus_le_compat; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Nat.add (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl)))) (Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (Nat.add (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))))
+++++
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Nat.add (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl)))) (Init.Nat.add (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))))
+++++
apply plus_le_compat; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))
+++++
apply mult_le_compat; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl)))) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))))
+++++
apply plus_le_compat; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl)))
+++++
apply peval_monotonic; intros; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.

*****
i : nat
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le match i with | O => length x | S m => nth m (map (length (A:=bool)) vnl) O end match i with | O => S (length x) | S m => nth m (map (length (A:=bool)) vnl) O end
+++++
destruct i; simpl; try omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))
+++++
apply peval_monotonic; intros; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.

*****
i : nat
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le match i with | O => length x | S m => nth m (map (length (A:=bool)) vnl) O end match i with | O => S (length x) | S m => nth m (map (length (A:=bool)) vnl) O end
+++++
destruct i; simpl; try omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))
+++++
apply peval_monotonic; intros; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.

*****
i : nat
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le match i with | O => length x | S m => nth m (map (length (A:=bool)) vnl) O end match i with | O => S (length x) | S m => nth m (map (length (A:=bool)) vnl) O end
+++++
destruct i; simpl; try omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) (snd (sem_cost h0 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl)))) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Init.Nat.add (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))))
+++++
eapply le_trans.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) (snd (sem_cost h0 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl)))) ?m
+++++
apply plus_le_compat.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) ?m
+++++
apply IHx.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost h0 (cons x vnl) (cons (fst (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl)) vsl))) ?q
+++++
apply H3; simpl; omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl)))))) (peval (poly_time (S n) h0) (map (length (A:=bool)) (cons x vnl)))) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Init.Nat.add (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))))
+++++
rewrite <- !plus_assoc; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Nat.add (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))))) (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl)) (Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (Nat.add (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))))))))
+++++
apply plus_le_compat; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Nat.add (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl)))) (Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (Nat.add (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))))
+++++
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Nat.add (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl)))) (Init.Nat.add (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))))) (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))))
+++++
apply plus_le_compat; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))))) (Init.Nat.mul (length x) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))))
+++++
apply mult_le_compat; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl)))) (Init.Nat.add (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl))))
+++++
apply plus_le_compat; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl)))
+++++
apply peval_monotonic; intros; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.

*****
i : nat
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le match i with | O => length x | S m => nth m (map (length (A:=bool)) vnl) O end match i with | O => S (length x) | S m => nth m (map (length (A:=bool)) vnl) O end
+++++
destruct i; simpl; try omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (peval (poly_time (S n) h1) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h1) (cons (S (length x)) (map (length (A:=bool)) vnl)))
+++++
apply peval_monotonic; intros; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.

*****
i : nat
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le match i with | O => length x | S m => nth m (map (length (A:=bool)) vnl) O end match i with | O => S (length x) | S m => nth m (map (length (A:=bool)) vnl) O end
+++++
destruct i; simpl; try omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.

*****
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (peval (poly_time (S n) h0) (cons (length x) (map (length (A:=bool)) vnl))) (peval (poly_time (S n) h0) (cons (S (length x)) (map (length (A:=bool)) vnl)))
+++++
apply peval_monotonic; intros; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.

*****
i : nat
IHx : le\n (snd\n (sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) x vnl vsl))\n (Init.Nat.add (peval (poly_time n g) (map (length (A:=bool)) vnl))\n (Init.Nat.mul (length x)\n (Init.Nat.add\n (peval (poly_time (S n) h0)\n (cons (length x) (map (length (A:=bool)) vnl)))\n (peval (poly_time (S n) h1)\n (cons (length x) (map (length (A:=bool)) vnl))))))
H6 : eq (length vsl) s
H5 : eq (S (length vnl)) (S n)
vnl,vsl : list (list bool)
x : list bool
H4 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h1 vnl vsl))\n (peval (poly_time (S n) h1) (map (length (A:=bool)) vnl))
H3 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (S n))\n (_ : eq (length vsl) (S s)),\nle (snd (sem_cost h0 vnl vsl))\n (peval (poly_time (S n) h0) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) n)\n (_ : eq (length vsl) s),\nle (snd (sem_cost g vnl vsl))\n (peval (poly_time n g) (map (length (A:=bool)) vnl))
H1 : eq (arities h1) (ok_arities (S n) (S s))
H0 : eq (arities h0) (ok_arities (S n) (S s))
H : eq (arities g) (ok_arities n s)
g,h0,h1 : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le ptime_pred_cost (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le ptime_cond_cost (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (ptime_proj_cost n s i)\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall _ : bool, le ptime_succ_cost (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le ptime_zero_cost (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le match i with | O => length x | S m => nth m (map (length (A:=bool)) vnl) O end match i with | O => S (length x) | S m => nth m (map (length (A:=bool)) vnl) O end
+++++
destruct i; simpl; try omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (Init.Nat.add (snd (sem_cost h (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)) (map fst (map (fun se : BC => sem_cost se vnl vsl) tl)))) (plusl (map snd (map (fun ne : BC => sem_cost ne vnl nil) rl)))) (plusl (map snd (map (fun se : BC => sem_cost se vnl vsl) tl)))) (peval (pplus (pplus (pcst n O) (pcomp (poly_time (length rl) h) (map (poly_BC n) rl))) (pplus (pplusl (map (poly_time n) rl)) (pplusl (map (poly_time n) tl)))) (map (length (A:=bool)) vnl))
+++++
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (Init.Nat.add (snd (sem_cost h (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)) (map fst (map (fun se : BC => sem_cost se vnl vsl) tl)))) (plusl (map snd (map (fun ne : BC => sem_cost ne vnl nil) rl)))) (plusl (map snd (map (fun se : BC => sem_cost se vnl vsl) tl)))) (Init.Nat.add (peval (poly_time (length rl) h) (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_BC n) rl))) (Init.Nat.add (plusl (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_time n) rl))) (plusl (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_time n) tl)))))
+++++
rewrite !plus_assoc.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (Init.Nat.add (snd (sem_cost h (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)) (map fst (map (fun se : BC => sem_cost se vnl vsl) tl)))) (plusl (map snd (map (fun ne : BC => sem_cost ne vnl nil) rl)))) (plusl (map snd (map (fun se : BC => sem_cost se vnl vsl) tl)))) (Nat.add (Nat.add (peval (poly_time (length rl) h) (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_BC n) rl))) (plusl (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_time n) rl)))) (plusl (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_time n) tl))))
+++++
apply plus_le_compat.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (snd (sem_cost h (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)) (map fst (map (fun se : BC => sem_cost se vnl vsl) tl)))) (plusl (map snd (map (fun ne : BC => sem_cost ne vnl nil) rl)))) (Nat.add (peval (poly_time (length rl) h) (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_BC n) rl))) (plusl (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_time n) rl))))
+++++
apply plus_le_compat.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost h (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)) (map fst (map (fun se : BC => sem_cost se vnl vsl) tl)))) (peval (poly_time (length rl) h) (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_BC n) rl)))
+++++
eapply le_trans.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost h (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)) (map fst (map (fun se : BC => sem_cost se vnl vsl) tl)))) ?m
+++++
apply H2.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (length (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl))) (length rl)
+++++
rewrite !map_length; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (length (map fst (map (fun se : BC => sem_cost se vnl vsl) tl))) (length tl)
+++++
rewrite !map_length; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (peval (poly_time (length rl) h) (map (length (A:=bool)) (map fst (map (fun ne : BC => sem_cost ne vnl nil) rl)))) (peval (poly_time (length rl) h) (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_BC n) rl)))
+++++
rewrite !map_map; simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (peval (poly_time (length rl) h) (map (fun x : BC => length (fst (sem_cost x vnl nil))) rl)) (peval (poly_time (length rl) h) (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) vnl)) rl))
+++++
apply peval_monotonic.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall i : nat, le (nth i (map (fun x : BC => length (fst (sem_cost x vnl nil))) rl) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) vnl)) rl) O)
+++++
intros.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.

*****
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (nth i (map (fun x : BC => length (fst (sem_cost x vnl nil))) rl) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) vnl)) rl) O)
+++++
destruct (lt_dec i (length rl)).
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (nth i (map (fun x : BC => length (fst (sem_cost x vnl nil))) rl) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) vnl)) rl) O)
+++++
erewrite map_nth2.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (length (fst (sem_cost (nth i rl ?d) vnl nil))) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) vnl)) rl) O)
+++++
eapply le_trans.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (length (fst (sem_cost (nth i rl ?d) vnl nil))) ?m
+++++
erewrite sem_cost_correct.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (length (sem (nth i rl ?d) vnl nil)) ?m
+++++
eapply polymax_bounding.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (arities (nth i rl ?d)) (ok_arities ?n0 ?s0)
+++++
apply H0; apply nth_In; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (arities (nth i rl ?d)) (ok_arities ?n ?s)
+++++
apply H0; apply nth_In; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (peval (poly_BC n (nth i rl ?d)) (map (length (A:=bool)) vnl)) (maxl (map (length (A:=bool)) nil))) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) vnl)) rl) O)
+++++
erewrite map_nth2.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (peval (poly_BC n (nth i rl ?d)) (map (length (A:=bool)) vnl)) (maxl (map (length (A:=bool)) nil))) (peval (poly_BC n (nth i rl ?d0)) (map (length (A:=bool)) vnl))
+++++
simpl.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (peval (poly_BC n (nth i rl ?d)) (map (length (A:=bool)) vnl)) O) (peval (poly_BC n (nth i rl ?d0)) (map (length (A:=bool)) vnl))
+++++
instantiate (1 := zero).
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (peval (poly_BC n (nth i rl ?d)) (map (length (A:=bool)) vnl)) O) (peval (poly_BC n (nth i rl zero)) (map (length (A:=bool)) vnl))
+++++
instantiate (1 := zero).
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (Init.Nat.add (peval (poly_BC n (nth i rl zero)) (map (length (A:=bool)) vnl)) O) (peval (poly_BC n (nth i rl zero)) (map (length (A:=bool)) vnl))
+++++
omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (peval (poly_BC n zero) (map (length (A:=bool)) vnl)) O
+++++
simpl; rewrite pcst_correct; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.

*****
l : lt i (length rl)
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
eq (length (fst (sem_cost zero vnl nil))) O
+++++
simpl; trivial.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.

*****
n0 : not (lt i (length rl))
i : nat
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (nth i (map (fun x : BC => length (fst (sem_cost x vnl nil))) rl) O) (nth i (map (fun x : BC => peval (poly_BC n x) (map (length (A:=bool)) vnl)) rl) O)
+++++
rewrite !nth_overflow; trivial; rewrite map_length; omega.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (plusl (map snd (map (fun ne : BC => sem_cost ne vnl nil) rl))) (plusl (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_time n) rl)))
+++++
rewrite !map_map.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.
rewrite !map_map.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (plusl (map (fun x : BC => snd (sem_cost x vnl nil)) rl)) (plusl (map (fun x : BC => peval (poly_time n x) (map (length (A:=bool)) vnl)) rl))
+++++
apply plusl_compat.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.
rewrite !map_map.
apply plusl_compat.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (x : BC) (_ : In x rl), le (snd (sem_cost x vnl nil)) (peval (poly_time n x) (map (length (A:=bool)) vnl))
+++++
intros.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.
rewrite !map_map.
apply plusl_compat.
intros.

*****
H7 : In x rl
x : BC
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost x vnl nil)) (peval (poly_time n x) (map (length (A:=bool)) vnl))
+++++
apply H3; auto.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.
rewrite !map_map.
apply plusl_compat.
intros.
apply H3; auto.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (plusl (map snd (map (fun se : BC => sem_cost se vnl vsl) tl))) (plusl (map (fun p : pol => peval p (map (length (A:=bool)) vnl)) (map (poly_time n) tl)))
+++++
rewrite !map_map.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.
rewrite !map_map.
apply plusl_compat.
intros.
apply H3; auto.
rewrite !map_map.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (plusl (map (fun x : BC => snd (sem_cost x vnl vsl)) tl)) (plusl (map (fun x : BC => peval (poly_time n x) (map (length (A:=bool)) vnl)) tl))
+++++
apply plusl_compat.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.
rewrite !map_map.
apply plusl_compat.
intros.
apply H3; auto.
rewrite !map_map.
apply plusl_compat.

*****
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
forall (x : BC) (_ : In x tl), le (snd (sem_cost x vnl vsl)) (peval (poly_time n x) (map (length (A:=bool)) vnl))
+++++
intros.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.
rewrite !map_map.
apply plusl_compat.
intros.
apply H3; auto.
rewrite !map_map.
apply plusl_compat.
intros.

*****
H7 : In x tl
x : BC
H6 : eq (length vsl) s
H5 : eq (length vnl) n
vnl,vsl : list (list bool)
H4 : forall (r : BC) (_ : In r tl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) s),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H3 : forall (r : BC) (_ : In r rl) (vnl vsl : list (list bool))\n (_ : eq (length vnl) n) (_ : eq (length vsl) O),\nle (snd (sem_cost r vnl vsl))\n (peval (poly_time n r) (map (length (A:=bool)) vnl))
H2 : forall (vnl vsl : list (list bool)) (_ : eq (length vnl) (length rl))\n (_ : eq (length vsl) (length tl)),\nle (snd (sem_cost h vnl vsl))\n (peval (poly_time (length rl) h) (map (length (A:=bool)) vnl))
H1 : forall (e : BC) (_ : In e tl), eq (arities e) (ok_arities n s)
H0 : forall (e : BC) (_ : In e rl), eq (arities e) (ok_arities n O)
H : eq (arities h) (ok_arities (length rl) (length tl))
rl,tl : list BC
h : BC
n,s : nat
ptime_pred_arity : eq (fst ptime_pred) O
ptime_pred_wf : pWF ptime_pred
ptime_pred_spec : le (snd (sem_cost pred nil nil)) (peval ptime_pred nil)
ptime_cond_arity : eq (fst ptime_cond) O
ptime_cond_wf : pWF ptime_cond
ptime_cond_spec : le (snd (sem_cost cond nil nil)) (peval ptime_cond nil)
ptime_proj_arity : forall n s i : nat, eq (fst (ptime_proj n s i)) n
ptime_proj_wf : forall n s i : nat, pWF (ptime_proj n s i)
ptime_proj_spec : forall (n s i : nat) (l : list (list bool)) (_ : eq (length l) n),\nle (snd (sem_cost (proj n s i) l nil))\n (peval (ptime_proj n s i) (map (length (A:=bool)) l))
ptime_succ_arity : eq (fst ptime_succ) O
ptime_succ_wf : pWF ptime_succ
ptime_succ_spec : forall b : bool,\nle (snd (sem_cost (succ b) nil nil)) (peval ptime_succ nil)
ptime_zero_arity : eq (fst ptime_zero) O
ptime_zero_wf : pWF ptime_zero
ptime_zero_spec : le (snd (sem_cost zero nil nil)) (peval ptime_zero nil)
ptime_proj : forall (_ : nat) (_ : nat) (_ : nat), pol
ptime_zero,ptime_succ,ptime_pred,ptime_cond : pol
ptime_proj_cost : forall (_ : nat) (_ : nat) (_ : nat), nat
ptime_zero_cost,ptime_succ_cost,ptime_pred_cost,ptime_cond_cost : nat
*****
le (snd (sem_cost x vnl vsl)) (peval (poly_time n x) (map (length (A:=bool)) vnl))
+++++
apply H4; auto.
-----
Lemma sem_cost_bounded : forall e n s, arities e = ok_arities n s -> (forall vnl vsl, length vnl = n -> length vsl = s -> snd (sem_cost e vnl vsl) <= peval (poly_time n e) (List.map (@length _) vnl)).
Proof.
refine (BC_ind_inf _ _ _ _ _ _ _ _); simpl; intros; trivial; try omega.
rewrite (@length_nil _ _ H); apply ptime_zero_spec.
apply (ptime_proj_spec n s i vnl); trivial.
rewrite (@length_nil _ _ H); apply (ptime_succ_spec b).
rewrite (@length_nil _ _ H); apply ptime_pred_spec.
rewrite (@length_nil _ _ H); apply ptime_cond_spec.
rewrite !pplus_correct, pshift_correct.
rewrite pmult_correct, pplus_correct, pproj_correct.
rewrite <- minus_n_O.
destruct vnl as [ | x vnl]; simpl in *;[ discriminate | ].
induction x; simpl.
rewrite <- plus_n_O; auto.
destruct a; simpl.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H4; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + d);[ | omega ] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
eapply le_trans.
apply plus_le_compat.
apply IHx.
apply H3; simpl; omega.
rewrite <- !plus_assoc; simpl.
apply plus_le_compat; trivial.
match goal with [ |- ?a + ?b <= ?c + (?d + ?e) ] => apply le_trans with (e + c);[ | omega] end.
apply plus_le_compat; trivial.
apply mult_le_compat; trivial.
apply plus_le_compat; trivial.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
apply peval_monotonic; intros; simpl.
destruct i; simpl; try omega.
rewrite !pplus_correct, pcst_correct, pcomp_correct, !pplusl_correct; simpl.
rewrite !plus_assoc.
apply plus_le_compat.
apply plus_le_compat.
eapply le_trans.
apply H2.
rewrite !map_length; trivial.
rewrite !map_length; trivial.
rewrite !map_map; simpl.
apply peval_monotonic.
intros.
destruct (lt_dec i (length rl)).
erewrite map_nth2.
eapply le_trans.
erewrite sem_cost_correct.
eapply polymax_bounding.
apply H0; apply nth_In; trivial.
apply H0; apply nth_In; trivial.
erewrite map_nth2.
simpl.
instantiate (1 := zero).
instantiate (1 := zero).
omega.
simpl; rewrite pcst_correct; trivial.
simpl; trivial.
rewrite !nth_overflow; trivial; rewrite map_length; omega.
rewrite !map_map.
apply plusl_compat.
intros.
apply H3; auto.
rewrite !map_map.
apply plusl_compat.
intros.
apply H4; auto.

*****

*****

+++++
Qed.
-----
End TIME.
-----
