Section uip_trans.
-----
Context {A : Type}.
-----
Definition uip_prop_trans (dec : forall x y : A, x = y \/ x <> y)\n    {x : A} :\n    forall {y : A} (pf pf' : x = y), pf = pf' :=\n    let comp :=\n        fun (x y y' : A) (eq1 : x = y) (eq2 : x = y') =>\n          eq_ind x (fun a : A => a = y') eq2 y eq1 in\n    let eq_dec := dec x in\n    let nu :=\n        fun (y : A) (u : x = y) =>\n          match eq_dec y with\n          | or_introl eqxy => eqxy\n          | or_intror neqxy => False_ind (x = y) (neqxy u)\n          end in\n    let nu_constant :=\n        fun (y : A) (u v : x = y) =>\n          let o := eq_dec y in\n          match\n            o as o0\n            return\n            (match o0 with\n             | or_introl eqxy => eqxy\n             | or_intror neqxy => False_ind (x = y) (neqxy u)\n             end =\n             match o0 with\n             | or_introl eqxy => eqxy\n             | or_intror neqxy => False_ind (x = y) (neqxy v)\n             end)\n          with\n          | or_introl Heq => eq_refl\n          | or_intror Hneq =>\n            match\n              Hneq u as f\n              return (False_ind (x = y) f = False_ind (x = y) (Hneq v))\n            with\n            end\n          end in\n    let nu_inv := fun (y : A) (v : x = y) => comp x x y (nu x eq_refl) v\n    in\n    let trans_sym_eq := fun (x y : A) (u : x = y) =>\n        match u as e in (_ = y0) return (comp x y0 y0 e e = eq_refl) with\n        | eq_refl => eq_refl\n        end\n    in\n    let nu_left_inv_on := fun (y : A) (u : x = y) =>\n        match u as e in (_ = y0) return (nu_inv y0 (nu y0 e) = e) with\n        | eq_refl => trans_sym_eq _ _ (nu _ eq_refl)\n        end in\n    fun (y : A) (p1 p2 : x = y) =>\n      eq_ind (nu_inv y (nu y p1)) (fun p3 : x = y => p3 = p2)\n             (eq_ind (nu_inv y (nu y p2)) (fun p3 : x = y => nu_inv y (nu y p1) = p3)\n                     (eq_ind (nu y p1) (fun e : x = y => nu_inv y (nu y p1) = nu_inv y e)\n                             eq_refl (nu y p2) (nu_constant y p1 p2)) p2\n                     (nu_left_inv_on _ p2)) p1 (nu_left_inv_on _ p1).
-----
Definition uip_trans (dec : forall x y : A, {x = y} + {x <> y})\n  := @uip_prop_trans (fun a b => match dec a b with\n                                 | left pf => or_introl pf\n                                 | right pf' => or_intror pf'\n                                 end).
-----
End uip_trans.
-----
