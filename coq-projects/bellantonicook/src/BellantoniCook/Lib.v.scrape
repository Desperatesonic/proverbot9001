From Coq Require Import Bool.
-----
From Coq Require Import Permutation.
-----
From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import   Coq.Arith.Div2 .
-----
From Coq Require Export Omega.
-----
Global Obligation Tactic := idtac.
-----
Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) .. ).
-----
Lemma length_nil : forall A (l : list A),\n  length l = 0 -> l = nil.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.

*****

*****
forall (A : Type) (l : list A) (_ : eq (length l) O), eq l nil
+++++
Proof.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.

*****

*****
forall (A : Type) (l : list A) (_ : eq (length l) O), eq l nil
+++++
intros.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.
intros.

*****
H : eq (length l) O
l : list A
A : Type
*****
eq l nil
+++++
destruct l.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.
intros.
destruct l.

*****
H : eq (length nil) O
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.
intros.
destruct l.

*****
H : eq (length (cons a l)) O
l : list A
a : A
A : Type
*****
eq (cons a l) nil
+++++
trivial.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.
intros.
destruct l.
trivial.

*****
H : eq (length (cons a l)) O
l : list A
a : A
A : Type
*****
eq (cons a l) nil
+++++
intros.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.
intros.
destruct l.
trivial.
intros.

*****
H : eq (length (cons a l)) O
l : list A
a : A
A : Type
*****
eq (cons a l) nil
+++++
simpl in H.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.
intros.
destruct l.
trivial.
intros.
simpl in H.

*****
H : eq (S (length l)) O
l : list A
a : A
A : Type
*****
eq (cons a l) nil
+++++
contradict H.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.
intros.
destruct l.
trivial.
intros.
simpl in H.
contradict H.

*****
l : list A
a : A
A : Type
*****
not (eq (S (length l)) O)
+++++
omega.
-----
Lemma length_nil : forall A (l : list A), length l = 0 -> l = nil.
Proof.
intros.
destruct l.

*****

*****

+++++
Qed.
-----
Lemma length_tail A l : length (@tail A l) = length l - 1.
-----
Lemma length_tail A l : length (@tail A l) = length l - 1.

*****
l : list A
A : Type
*****
eq (length (tl l)) (Init.Nat.sub (length l) (S O))
+++++
Proof.
-----
Lemma length_tail A l : length (@tail A l) = length l - 1.
Proof.

*****
l : list A
A : Type
*****
eq (length (tl l)) (Init.Nat.sub (length l) (S O))
+++++
destruct l.
-----
Lemma length_tail A l : length (@tail A l) = length l - 1.
Proof.
destruct l.

*****
A : Type
*****
eq (length (tl nil)) (Init.Nat.sub (length nil) (S O))
+++++
simpl.
-----
Lemma length_tail A l : length (@tail A l) = length l - 1.
Proof.
destruct l.
simpl.

*****
A : Type
*****
eq O O
+++++
auto with arith.
-----
Lemma length_tail A l : length (@tail A l) = length l - 1.
Proof.
destruct l.

*****
l : list A
a : A
A : Type
*****
eq (length (tl (cons a l))) (Init.Nat.sub (length (cons a l)) (S O))
+++++
simpl.
-----
Lemma length_tail A l : length (@tail A l) = length l - 1.
Proof.
destruct l.
simpl.

*****
l : list A
a : A
A : Type
*****
eq (length l) (Init.Nat.sub (length l) O)
+++++
auto with arith.
-----
Lemma length_tail A l : length (@tail A l) = length l - 1.
Proof.
destruct l.

*****

*****

+++++
Qed.
-----
Lemma hd_nth_0 A (l : list A) d :\n  hd d l = nth 0 l d.
-----
Lemma hd_nth_0 A (l : list A) d : hd d l = nth 0 l d.

*****
d : A
l : list A
A : Type
*****
eq (hd d l) (nth O l d)
+++++
Proof.
-----
Lemma hd_nth_0 A (l : list A) d : hd d l = nth 0 l d.
Proof.

*****
d : A
l : list A
A : Type
*****
eq (hd d l) (nth O l d)
+++++
intros.
-----
Lemma hd_nth_0 A (l : list A) d : hd d l = nth 0 l d.
Proof.
intros.

*****
d : A
l : list A
A : Type
*****
eq (hd d l) (nth O l d)
+++++
case l.
-----
Lemma hd_nth_0 A (l : list A) d : hd d l = nth 0 l d.
Proof.
intros.
case l.

*****
d : A
l : list A
A : Type
*****
eq (hd d nil) (nth O nil d)
+++++
simpl.
-----
Lemma hd_nth_0 A (l : list A) d : hd d l = nth 0 l d.
Proof.
intros.
case l.
simpl.

*****
d : A
l : list A
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma hd_nth_0 A (l : list A) d : hd d l = nth 0 l d.
Proof.
intros.
case l.

*****
d : A
l : list A
A : Type
*****
forall (a : A) (l : list A), eq (hd d (cons a l)) (nth O (cons a l) d)
+++++
simpl.
-----
Lemma hd_nth_0 A (l : list A) d : hd d l = nth 0 l d.
Proof.
intros.
case l.
simpl.

*****
d : A
l : list A
A : Type
*****
forall (a : A) (_ : list A), eq a a
+++++
trivial.
-----
Lemma hd_nth_0 A (l : list A) d : hd d l = nth 0 l d.
Proof.
intros.
case l.

*****

*****

+++++
Qed.
-----
Lemma hd_nth_1 A (l : list A) d :\n  hd d (tl l) = nth 1 l d.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.

*****
d : A
l : list A
A : Type
*****
eq (hd d (tl l)) (nth (S O) l d)
+++++
Proof.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.

*****
d : A
l : list A
A : Type
*****
eq (hd d (tl l)) (nth (S O) l d)
+++++
intros.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.

*****
d : A
l : list A
A : Type
*****
eq (hd d (tl l)) (nth (S O) l d)
+++++
case l.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.
case l.

*****
d : A
l : list A
A : Type
*****
eq (hd d (tl nil)) (nth (S O) nil d)
+++++
simpl.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.
case l.
simpl.

*****
d : A
l : list A
A : Type
*****
eq d d
+++++
intros.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.
case l.
simpl.
intros.

*****
d : A
l : list A
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.
case l.

*****
d : A
l : list A
A : Type
*****
forall (a : A) (l : list A), eq (hd d (tl (cons a l))) (nth (S O) (cons a l) d)
+++++
simpl.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.
case l.
simpl.

*****
d : A
l : list A
A : Type
*****
forall (_ : A) (l : list A), eq (hd d l) (nth O l d)
+++++
intros.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.
case l.
simpl.
intros.

*****
l0 : list A
d,a : A
l : list A
A : Type
*****
eq (hd d l0) (nth O l0 d)
+++++
trivial.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.
case l.
simpl.
intros.
trivial.

*****
l0 : list A
d,a : A
l : list A
A : Type
*****
eq (hd d l0) (nth O l0 d)
+++++
apply hd_nth_0.
-----
Lemma hd_nth_1 A (l : list A) d : hd d (tl l) = nth 1 l d.
Proof.
intros.
case l.

*****

*****

+++++
Qed.
-----
Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) :\n  In (hd d l) l.
-----
Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) : In (hd d l) l.

*****
H : eq (length l) (S n)
n : nat
l : list A
d : A
A : Type
*****
In (hd d l) l
+++++
Proof.
-----
Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) : In (hd d l) l.
Proof.

*****
H : eq (length l) (S n)
n : nat
l : list A
d : A
A : Type
*****
In (hd d l) l
+++++
destruct l.
-----
Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) : In (hd d l) l.
Proof.
destruct l.

*****
H : eq (length nil) (S n)
n : nat
d : A
A : Type
*****
In (hd d nil) nil
+++++
simpl in H.
-----
Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) : In (hd d l) l.
Proof.
destruct l.
simpl in H.

*****
H : eq O (S n)
n : nat
d : A
A : Type
*****
In (hd d nil) nil
+++++
discriminate H.
-----
Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) : In (hd d l) l.
Proof.
destruct l.

*****
H : eq (length (cons a l)) (S n)
n : nat
l : list A
d,a : A
A : Type
*****
In (hd d (cons a l)) (cons a l)
+++++
simpl.
-----
Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) : In (hd d l) l.
Proof.
destruct l.
simpl.

*****
H : eq (length (cons a l)) (S n)
n : nat
l : list A
d,a : A
A : Type
*****
or (eq a a) (In a l)
+++++
tauto.
-----
Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) : In (hd d l) l.
Proof.
destruct l.

*****

*****

+++++
Qed.
-----
Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).
-----
Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).

*****

*****
forall (A B : Type) (f : forall _ : A, B) (d : A) (l : list A), eq (f (hd d l)) (hd (f d) (map f l))
+++++
Proof.
-----
Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).
Proof.

*****

*****
forall (A B : Type) (f : forall _ : A, B) (d : A) (l : list A), eq (f (hd d l)) (hd (f d) (map f l))
+++++
intros A B f d [ | x l].
-----
Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).
Proof.
intros A B f d [ | x l].

*****
d : A
f : forall _ : A, B
B : Type
A : Type
*****
eq (f (hd d nil)) (hd (f d) (map f nil))
+++++
trivial.
-----
Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).
Proof.
intros A B f d [ | x l].

*****
l : list A
d,x : A
f : forall _ : A, B
B : Type
A : Type
*****
eq (f (hd d (cons x l))) (hd (f d) (map f (cons x l)))
+++++
trivial.
-----
Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).
Proof.
intros A B f d [ | x l].

*****

*****

+++++
Qed.
-----
Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).
-----
Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).

*****

*****
forall (A B : Type) (f : forall _ : A, B) (l : list A), eq (map f (tl l)) (tl (map f l))
+++++
Proof.
-----
Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).
Proof.

*****

*****
forall (A B : Type) (f : forall _ : A, B) (l : list A), eq (map f (tl l)) (tl (map f l))
+++++
intros A B f [ | x l].
-----
Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).
Proof.
intros A B f [ | x l].

*****
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f (tl nil)) (tl (map f nil))
+++++
trivial.
-----
Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).
Proof.
intros A B f [ | x l].

*****
l : list A
x : A
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f (tl (cons x l))) (tl (map f (cons x l)))
+++++
trivial.
-----
Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).
Proof.
intros A B f [ | x l].

*****

*****

+++++
Qed.
-----
Lemma map_eq_hd :\n  forall A B (f:A->B) d l1 l2,\n  map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).

*****

*****
forall (A B : Type) (f : forall _ : A, B) (d : A) (l1 l2 : list A) (_ : eq (map f l1) (map f l2)), eq (f (hd d l1)) (f (hd d l2))
+++++
Proof.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.

*****

*****
forall (A B : Type) (f : forall _ : A, B) (d : A) (l1 l2 : list A) (_ : eq (map f l1) (map f l2)), eq (f (hd d l1)) (f (hd d l2))
+++++
intros A B f d [ | a1 l1] [ | a2 l2].
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].

*****
d : A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq (map f nil) (map f nil), eq (f (hd d nil)) (f (hd d nil))
+++++
simpl.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].
simpl.

*****
d : A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq nil nil, eq (f d) (f d)
+++++
congruence.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].

*****
l2 : list A
d,a2 : A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq (map f nil) (map f (cons a2 l2)), eq (f (hd d nil)) (f (hd d (cons a2 l2)))
+++++
simpl.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].
simpl.

*****
l2 : list A
d,a2 : A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq nil (cons (f a2) (map f l2)), eq (f d) (f a2)
+++++
congruence.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].

*****
l1 : list A
d,a1 : A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq (map f (cons a1 l1)) (map f nil), eq (f (hd d (cons a1 l1))) (f (hd d nil))
+++++
simpl.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].
simpl.

*****
l1 : list A
d,a1 : A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq (cons (f a1) (map f l1)) nil, eq (f a1) (f d)
+++++
congruence.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].

*****
l2 : list A
a2 : A
l1 : list A
d,a1 : A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq (map f (cons a1 l1)) (map f (cons a2 l2)), eq (f (hd d (cons a1 l1))) (f (hd d (cons a2 l2)))
+++++
simpl.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].
simpl.

*****
l2 : list A
a2 : A
l1 : list A
d,a1 : A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq (cons (f a1) (map f l1)) (cons (f a2) (map f l2)), eq (f a1) (f a2)
+++++
congruence.
-----
Lemma map_eq_hd : forall A B (f:A->B) d l1 l2, map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).
Proof.
intros A B f d [ | a1 l1] [ | a2 l2].

*****

*****

+++++
Qed.
-----
Lemma firstn_nil {A} n : firstn n (@nil A) = nil.
-----
Lemma firstn_nil {A} n : firstn n (@nil A) = nil.

*****
n : nat
A : Type
*****
eq (firstn n nil) nil
+++++
Proof.
-----
Lemma firstn_nil {A} n : firstn n (@nil A) = nil.
Proof.

*****
n : nat
A : Type
*****
eq (firstn n nil) nil
+++++
case n.
-----
Lemma firstn_nil {A} n : firstn n (@nil A) = nil.
Proof.
case n.

*****
n : nat
A : Type
*****
eq (firstn O nil) nil
+++++
simpl.
-----
Lemma firstn_nil {A} n : firstn n (@nil A) = nil.
Proof.
case n.
simpl.

*****
n : nat
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma firstn_nil {A} n : firstn n (@nil A) = nil.
Proof.
case n.

*****
n : nat
A : Type
*****
forall n : nat, eq (firstn (S n) nil) nil
+++++
simpl.
-----
Lemma firstn_nil {A} n : firstn n (@nil A) = nil.
Proof.
case n.
simpl.

*****
n : nat
A : Type
*****
forall _ : nat, eq nil nil
+++++
trivial.
-----
Lemma firstn_nil {A} n : firstn n (@nil A) = nil.
Proof.
case n.

*****

*****

+++++
Qed.
-----
Lemma skipn_nil : forall {A} n (x : list A),\n  length x <= n -> skipn n x = nil.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.

*****

*****
forall (A : Type) (n : nat) (x : list A) (_ : le (length x) n), eq (skipn n x) nil
+++++
Proof.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.

*****

*****
forall (A : Type) (n : nat) (x : list A) (_ : le (length x) n), eq (skipn n x) nil
+++++
induction n.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.

*****
A : Type
*****
forall (x : list A) (_ : le (length x) O), eq (skipn O x) nil
+++++
simpl in *.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.

*****
A : Type
*****
forall (x : list A) (_ : le (length x) O), eq x nil
+++++
trivial.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.

*****
A : Type
*****
forall (x : list A) (_ : le (length x) O), eq x nil
+++++
intros.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.

*****
H : le (length x) O
x : list A
A : Type
*****
eq x nil
+++++
apply length_nil.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.
apply length_nil.

*****
H : le (length x) O
x : list A
A : Type
*****
eq (length x) O
+++++
auto.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.
apply length_nil.
auto.

*****
H : le (length x) O
x : list A
A : Type
*****
eq (length x) O
+++++
omega.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.

*****
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
forall (x : list A) (_ : le (length x) (S n)), eq (skipn (S n) x) nil
+++++
simpl in *.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.

*****
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
forall (x : list A) (_ : le (length x) (S n)), eq match x with | nil => nil | cons _ l => skipn n l end nil
+++++
trivial.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.

*****
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
forall (x : list A) (_ : le (length x) (S n)), eq match x with | nil => nil | cons _ l => skipn n l end nil
+++++
intros.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.

*****
H : le (length x) (S n)
x : list A
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
eq match x with | nil => nil | cons _ l => skipn n l end nil
+++++
destruct x.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.
destruct x.

*****
H : le (length nil) (S n)
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
eq nil nil
+++++
simpl in *.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.
destruct x.
simpl in *.

*****
H : le O (S n)
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.
destruct x.

*****
H : le (length (cons a x)) (S n)
x : list A
a : A
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
eq (skipn n x) nil
+++++
simpl in *.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.
destruct x.
simpl in *.

*****
H : le (S (length x)) (S n)
x : list A
a : A
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
eq (skipn n x) nil
+++++
trivial.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.
destruct x.
simpl in *.
trivial.

*****
H : le (S (length x)) (S n)
x : list A
a : A
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
eq (skipn n x) nil
+++++
apply IHn.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.
simpl in *.
trivial.
intros.
destruct x.
simpl in *.
trivial.
apply IHn.

*****
H : le (S (length x)) (S n)
x : list A
a : A
IHn : forall (x : list A) (_ : le (length x) n), eq (skipn n x) nil
n : nat
A : Type
*****
le (length x) n
+++++
omega.
-----
Lemma skipn_nil : forall {A} n (x : list A), length x <= n -> skipn n x = nil.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma nth_firstn : forall A i j (l:list A) d,\n  i < j -> nth i (firstn j l) d = nth i l d.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.

*****

*****
forall (A : Type) (i j : nat) (l : list A) (d : A) (_ : lt i j), eq (nth i (firstn j l) d) (nth i l d)
+++++
Proof.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.

*****

*****
forall (A : Type) (i j : nat) (l : list A) (d : A) (_ : lt i j), eq (nth i (firstn j l) d) (nth i l d)
+++++
intros A i j.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.

*****
i,j : nat
A : Type
*****
forall (l : list A) (d : A) (_ : lt i j), eq (nth i (firstn j l) d) (nth i l d)
+++++
revert i.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.

*****
j : nat
A : Type
*****
forall (i : nat) (l : list A) (d : A) (_ : lt i j), eq (nth i (firstn j l) d) (nth i l d)
+++++
induction j.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.

*****
A : Type
*****
forall (i : nat) (l : list A) (d : A) (_ : lt i O), eq (nth i (firstn O l) d) (nth i l d)
+++++
simpl.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.

*****
A : Type
*****
forall (i : nat) (l : list A) (d : A) (_ : lt i O), eq match i with | O | _ => d end (nth i l d)
+++++
intros.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.

*****
H : lt i O
d : A
l : list A
i : nat
A : Type
*****
eq match i with | O | _ => d end (nth i l d)
+++++
contradict H.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
contradict H.

*****
d : A
l : list A
i : nat
A : Type
*****
not (lt i O)
+++++
omega.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.

*****
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (i : nat) (l : list A) (d : A) (_ : lt i (S j)), eq (nth i (firstn (S j) l) d) (nth i l d)
+++++
simpl.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.

*****
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (i : nat) (l : list A) (d : A) (_ : lt i (S j)), eq (nth i match l with | nil => nil | cons a l0 => cons a (firstn j l0) end d) (nth i l d)
+++++
intros.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.

*****
H : lt i (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
eq (nth i match l with | nil => nil | cons a l => cons a (firstn j l) end d) (nth i l d)
+++++
case l.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.

*****
H : lt i (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
eq (nth i nil d) (nth i nil d)
+++++
simpl.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.

*****
H : lt i (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
eq match i with | O | _ => d end match i with | O | _ => d end
+++++
destruct i.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.

*****
H : lt O (S j)
d : A
l : list A
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
eq d d
+++++
simpl.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.
simpl.

*****
H : lt O (S j)
d : A
l : list A
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.

*****
H : lt (S i) (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
eq d d
+++++
simpl.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.
simpl.

*****
H : lt (S i) (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.

*****
H : lt i (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (a : A) (l : list A), eq (nth i (cons a (firstn j l)) d) (nth i (cons a l) d)
+++++
simpl.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.

*****
H : lt i (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (a : A) (l : list A), eq match i with | O => a | S m => nth m (firstn j l) d end match i with | O => a | S m => nth m l d end
+++++
destruct i.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.

*****
H : lt O (S j)
d : A
l : list A
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (a : A) (_ : list A), eq a a
+++++
simpl.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.
simpl.

*****
H : lt O (S j)
d : A
l : list A
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (a : A) (_ : list A), eq a a
+++++
trivial.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.

*****
H : lt (S i) (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (_ : A) (l : list A), eq (nth i (firstn j l) d) (nth i l d)
+++++
simpl.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.
simpl.

*****
H : lt (S i) (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (_ : A) (l : list A), eq (nth i (firstn j l) d) (nth i l d)
+++++
trivial.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.
simpl.
trivial.

*****
H : lt (S i) (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
forall (_ : A) (l : list A), eq (nth i (firstn j l) d) (nth i l d)
+++++
intros.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.
simpl.
trivial.
intros.

*****
l0 : list A
a : A
H : lt (S i) (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
eq (nth i (firstn j l0) d) (nth i l0 d)
+++++
apply IHj.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.
simpl.
intros.
case l.
simpl.
destruct i.
simpl.
trivial.
intros.
apply IHj.

*****
l0 : list A
a : A
H : lt (S i) (S j)
d : A
l : list A
i : nat
IHj : forall (i : nat) (l : list A) (d : A) (_ : lt i j),\neq (nth i (firstn j l) d) (nth i l d)
j : nat
A : Type
*****
lt i j
+++++
omega.
-----
Lemma nth_firstn : forall A i j (l:list A) d, i < j -> nth i (firstn j l) d = nth i l d.
Proof.
intros A i j.
revert i.
induction j.

*****

*****

+++++
Qed.
-----
Lemma nth_skipn A i j (l:list A) d : \n  nth i (skipn j l) d = nth (j+i) l d.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.

*****
d : A
l : list A
i,j : nat
A : Type
*****
eq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
+++++
Proof.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.

*****
d : A
l : list A
i,j : nat
A : Type
*****
eq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
+++++
intros.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.

*****
d : A
l : list A
i,j : nat
A : Type
*****
eq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
+++++
revert i l.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.

*****
d : A
j : nat
A : Type
*****
forall (i : nat) (l : list A), eq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
+++++
induction j.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.

*****
d : A
A : Type
*****
forall (i : nat) (l : list A), eq (nth i (skipn O l) d) (nth (Init.Nat.add O i) l d)
+++++
simpl.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.

*****
d : A
A : Type
*****
forall (i : nat) (l : list A), eq (nth i l d) (nth i l d)
+++++
intros.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.

*****
l : list A
i : nat
d : A
A : Type
*****
eq (nth i l d) (nth i l d)
+++++
trivial.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.

*****
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
forall (i : nat) (l : list A), eq (nth i (skipn (S j) l) d) (nth (Init.Nat.add (S j) i) l d)
+++++
simpl.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.

*****
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
forall (i : nat) (l : list A), eq (nth i match l with | nil => nil | cons _ l0 => skipn j l0 end d) (nth (S (Init.Nat.add j i)) l d)
+++++
intros.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.

*****
l : list A
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
eq (nth i match l with | nil => nil | cons _ l => skipn j l end d) (nth (S (Init.Nat.add j i)) l d)
+++++
trivial.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.
trivial.

*****
l : list A
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
eq (nth i match l with | nil => nil | cons _ l => skipn j l end d) (nth (S (Init.Nat.add j i)) l d)
+++++
destruct l.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.
trivial.
destruct l.

*****
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
eq (nth i nil d) (nth (S (Init.Nat.add j i)) nil d)
+++++
simpl.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.
trivial.
destruct l.
simpl.

*****
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
eq match i with | O | _ => d end d
+++++
trivial.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.
trivial.
destruct l.
simpl.
trivial.

*****
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
eq match i with | O | _ => d end d
+++++
case i.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.
trivial.
destruct l.
simpl.
trivial.
case i.

*****
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.
trivial.
destruct l.
simpl.
trivial.
case i.

*****
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
forall _ : nat, eq d d
+++++
trivial.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.
trivial.
destruct l.

*****
l : list A
a : A
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
eq (nth i (skipn j l) d) (nth (S (Init.Nat.add j i)) (cons a l) d)
+++++
simpl.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.
simpl.
intros.
trivial.
destruct l.
simpl.

*****
l : list A
a : A
i : nat
IHj : forall (i : nat) (l : list A),\neq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
d : A
j : nat
A : Type
*****
eq (nth i (skipn j l) d) (nth (Init.Nat.add j i) l d)
+++++
trivial.
-----
Lemma nth_skipn A i j (l:list A) d : nth i (skipn j l) d = nth (j+i) l d.
Proof.
intros.
revert i l.
induction j.

*****

*****

+++++
Qed.
-----
Lemma length_skipn : forall A n (y : list A),\n  length (skipn n y) = length y - n.
-----
Lemma length_skipn : forall A n (y : list A), length (skipn n y) = length y - n.

*****

*****
forall (A : Type) (n : nat) (y : list A), eq (length (skipn n y)) (Init.Nat.sub (length y) n)
+++++
Proof.
-----
Lemma length_skipn : forall A n (y : list A), length (skipn n y) = length y - n.
Proof.

*****

*****
forall (A : Type) (n : nat) (y : list A), eq (length (skipn n y)) (Init.Nat.sub (length y) n)
+++++
induction n; simpl; intros; [ omega | ].
-----
Lemma length_skipn : forall A n (y : list A), length (skipn n y) = length y - n.
Proof.
induction n; simpl; intros; [ omega | ].

*****
y : list A
IHn : forall y : list A, eq (length (skipn n y)) (Init.Nat.sub (length y) n)
n : nat
A : Type
*****
eq (length match y with | nil => nil | cons _ l => skipn n l end) (Init.Nat.sub (length y) (S n))
+++++
destruct y; simpl; trivial.
-----
Lemma length_skipn : forall A n (y : list A), length (skipn n y) = length y - n.
Proof.
induction n; simpl; intros; [ omega | ].
destruct y; simpl; trivial.

*****

*****

+++++
Qed.
-----
Lemma skipn_length : forall {A} n (l:list A), \n  length (skipn n l) = length l - n.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.

*****

*****
forall (A : Type) (n : nat) (l : list A), eq (length (skipn n l)) (Init.Nat.sub (length l) n)
+++++
Proof.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.

*****

*****
forall (A : Type) (n : nat) (l : list A), eq (length (skipn n l)) (Init.Nat.sub (length l) n)
+++++
induction n.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.

*****
A : Type
*****
forall l : list A, eq (length (skipn O l)) (Init.Nat.sub (length l) O)
+++++
simpl.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.

*****
A : Type
*****
forall l : list A, eq (length l) (Init.Nat.sub (length l) O)
+++++
intros.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.
intros.

*****
l : list A
A : Type
*****
eq (length l) (Init.Nat.sub (length l) O)
+++++
auto with arith.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.

*****
IHn : forall l : list A, eq (length (skipn n l)) (Init.Nat.sub (length l) n)
n : nat
A : Type
*****
forall l : list A, eq (length (skipn (S n) l)) (Init.Nat.sub (length l) (S n))
+++++
simpl.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.

*****
IHn : forall l : list A, eq (length (skipn n l)) (Init.Nat.sub (length l) n)
n : nat
A : Type
*****
forall l : list A, eq (length match l with | nil => nil | cons _ l0 => skipn n l0 end) (Init.Nat.sub (length l) (S n))
+++++
intros.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.
intros.

*****
l : list A
IHn : forall l : list A, eq (length (skipn n l)) (Init.Nat.sub (length l) n)
n : nat
A : Type
*****
eq (length match l with | nil => nil | cons _ l => skipn n l end) (Init.Nat.sub (length l) (S n))
+++++
auto with arith.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.
intros.
auto with arith.

*****
l : list A
IHn : forall l : list A, eq (length (skipn n l)) (Init.Nat.sub (length l) n)
n : nat
A : Type
*****
eq (length match l with | nil => nil | cons _ l => skipn n l end) (Init.Nat.sub (length l) (S n))
+++++
destruct l.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.
intros.
auto with arith.
destruct l.

*****
IHn : forall l : list A, eq (length (skipn n l)) (Init.Nat.sub (length l) n)
n : nat
A : Type
*****
eq (length nil) (Init.Nat.sub (length nil) (S n))
+++++
simpl.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.
intros.
auto with arith.
destruct l.
simpl.

*****
IHn : forall l : list A, eq (length (skipn n l)) (Init.Nat.sub (length l) n)
n : nat
A : Type
*****
eq O O
+++++
auto.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.
intros.
auto with arith.
destruct l.

*****
l : list A
a : A
IHn : forall l : list A, eq (length (skipn n l)) (Init.Nat.sub (length l) n)
n : nat
A : Type
*****
eq (length (skipn n l)) (Init.Nat.sub (length (cons a l)) (S n))
+++++
simpl.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.
simpl.
intros.
auto with arith.
destruct l.
simpl.

*****
l : list A
a : A
IHn : forall l : list A, eq (length (skipn n l)) (Init.Nat.sub (length l) n)
n : nat
A : Type
*****
eq (length (skipn n l)) (Init.Nat.sub (length l) n)
+++++
auto.
-----
Lemma skipn_length : forall {A} n (l:list A), length (skipn n l) = length l - n.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma cons_skipn :\n  forall A d i (l:list A),\n  i < length l ->\n  nth i l d :: skipn (S i) l = skipn i l.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.

*****

*****
forall (A : Type) (d : A) (i : nat) (l : list A) (_ : lt i (length l)), eq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
+++++
Proof.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.

*****

*****
forall (A : Type) (d : A) (i : nat) (l : list A) (_ : lt i (length l)), eq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
+++++
induction i as [ | i IH].
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].

*****
d : A
A : Type
*****
forall (l : list A) (_ : lt O (length l)), eq (cons (nth O l d) (skipn (S O) l)) (skipn O l)
+++++
simpl.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.

*****
d : A
A : Type
*****
forall (l : list A) (_ : lt O (length l)), eq (cons (nth O l d) match l with | nil => nil | cons _ l0 => l0 end) l
+++++
intros.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.

*****
H : lt O (length l)
l : list A
d : A
A : Type
*****
eq (cons (nth O l d) match l with | nil => nil | cons _ l => l end) l
+++++
destruct l as [ | x l].
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].

*****
H : lt O (length nil)
d : A
A : Type
*****
eq (cons (nth O nil d) nil) nil
+++++
trivial.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
trivial.

*****
H : lt O (length nil)
d : A
A : Type
*****
eq (cons (nth O nil d) nil) nil
+++++
contradict H.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
trivial.
contradict H.

*****
d : A
A : Type
*****
not (lt O (length nil))
+++++
simpl.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
trivial.
contradict H.
simpl.

*****
d : A
A : Type
*****
not (lt O O)
+++++
omega.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].

*****
H : lt O (length (cons x l))
l : list A
d,x : A
A : Type
*****
eq (cons (nth O (cons x l) d) l) (cons x l)
+++++
trivial.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].

*****
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
forall (l : list A) (_ : lt (S i) (length l)), eq (cons (nth (S i) l d) (skipn (S (S i)) l)) (skipn (S i) l)
+++++
simpl.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.

*****
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
forall (l : list A) (_ : lt (S i) (length l)), eq (cons (nth (S i) l d) match l with | cons _ (cons _ l1) => skipn i l1 | _ => nil end) match l with | nil => nil | cons _ l0 => skipn i l0 end
+++++
intros.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.

*****
H : lt (S i) (length l)
l : list A
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
eq (cons (nth (S i) l d) match l with | cons _ (cons _ l0) => skipn i l0 | _ => nil end) match l with | nil => nil | cons _ l => skipn i l end
+++++
destruct l as [ | x l].
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].

*****
H : lt (S i) (length nil)
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
eq (cons (nth (S i) nil d) nil) nil
+++++
contradict H.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
contradict H.

*****
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
not (lt (S i) (length nil))
+++++
simpl.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
contradict H.
simpl.

*****
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
not (lt (S i) O)
+++++
omega.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].

*****
H : lt (S i) (length (cons x l))
l : list A
x : A
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
eq (cons (nth (S i) (cons x l) d) match l with | nil => nil | cons _ l => skipn i l end) (skipn i l)
+++++
rewrite <- IH.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
rewrite <- IH.

*****
H : lt (S i) (length (cons x l))
l : list A
x : A
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
eq (cons (nth (S i) (cons x l) d) match l with | nil => nil | cons _ l => skipn i l end) (cons (nth i l d) (skipn (S i) l))
+++++
trivial.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
rewrite <- IH.

*****
H : lt (S i) (length (cons x l))
l : list A
x : A
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
lt i (length l)
+++++
trivial.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
rewrite <- IH.
trivial.

*****
H : lt (S i) (length (cons x l))
l : list A
x : A
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
lt i (length l)
+++++
simpl in H.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].
simpl.
intros.
destruct l as [ | x l].
rewrite <- IH.
trivial.
simpl in H.

*****
H : lt (S i) (S (length l))
l : list A
x : A
IH : forall (l : list A) (_ : lt i (length l)),\neq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
i : nat
d : A
A : Type
*****
lt i (length l)
+++++
omega.
-----
Lemma cons_skipn : forall A d i (l:list A), i < length l -> nth i l d :: skipn (S i) l = skipn i l.
Proof.
induction i as [ | i IH].

*****

*****

+++++
Qed.
-----
Lemma skipn_plus :\n  forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).

*****

*****
forall (A : Type) (j i : nat) (l : list A), eq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
+++++
Proof.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.

*****

*****
forall (A : Type) (j i : nat) (l : list A), eq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
+++++
induction j as [ | j IH].
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].

*****
A : Type
*****
forall (i : nat) (l : list A), eq (skipn (Init.Nat.add i O) l) (skipn i (skipn O l))
+++++
simpl.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.

*****
A : Type
*****
forall (i : nat) (l : list A), eq (skipn (Init.Nat.add i O) l) (skipn i l)
+++++
intros.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.

*****
l : list A
i : nat
A : Type
*****
eq (skipn (Init.Nat.add i O) l) (skipn i l)
+++++
rewrite plus_0_r.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite plus_0_r.

*****
l : list A
i : nat
A : Type
*****
eq (skipn i l) (skipn i l)
+++++
trivial.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].

*****
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
forall (i : nat) (l : list A), eq (skipn (Init.Nat.add i (S j)) l) (skipn i (skipn (S j) l))
+++++
simpl.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.

*****
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
forall (i : nat) (l : list A), eq (skipn (Init.Nat.add i (S j)) l) (skipn i match l with | nil => nil | cons _ l0 => skipn j l0 end)
+++++
intros.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
eq (skipn (Init.Nat.add i (S j)) l) (skipn i match l with | nil => nil | cons _ l => skipn j l end)
+++++
rewrite <- plus_Snm_nSm.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
eq (skipn (Init.Nat.add (S i) j) l) (skipn i match l with | nil => nil | cons _ l => skipn j l end)
+++++
case l.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
eq (skipn (Init.Nat.add (S i) j) nil) (skipn i nil)
+++++
rewrite !skipn_nil.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
rewrite !skipn_nil.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
eq nil nil
+++++
simpl.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
rewrite !skipn_nil.
simpl.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
rewrite !skipn_nil.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
le (length nil) i
+++++
simpl.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
rewrite !skipn_nil.
simpl.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
le O i
+++++
trivial.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
rewrite !skipn_nil.
simpl.
trivial.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
le O i
+++++
omega.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
rewrite !skipn_nil.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
le (length nil) (Init.Nat.add (S i) j)
+++++
simpl.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
rewrite !skipn_nil.
simpl.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
le O (S (Init.Nat.add i j))
+++++
trivial.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
rewrite !skipn_nil.
simpl.
trivial.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
le O (S (Init.Nat.add i j))
+++++
omega.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
forall (a : A) (l : list A), eq (skipn (Init.Nat.add (S i) j) (cons a l)) (skipn i (skipn j l))
+++++
simpl.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].
simpl.
intros.
rewrite <- plus_Snm_nSm.
case l.
simpl.

*****
l : list A
i : nat
IH : forall (i : nat) (l : list A),\neq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
j : nat
A : Type
*****
forall (_ : A) (l : list A), eq (skipn (Init.Nat.add i j) l) (skipn i (skipn j l))
+++++
trivial.
-----
Lemma skipn_plus : forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).
Proof.
induction j as [ | j IH].

*****

*****

+++++
Qed.
-----
Lemma skipn_hd : forall {A} n y (d:A), \n  n < length y -> \n  skipn n y = nth n y d :: skipn (S n) y.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.

*****

*****
forall (A : Type) (n : nat) (y : list A) (d : A) (_ : lt n (length y)), eq (skipn n y) (cons (nth n y d) (skipn (S n) y))
+++++
Proof.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.

*****

*****
forall (A : Type) (n : nat) (y : list A) (d : A) (_ : lt n (length y)), eq (skipn n y) (cons (nth n y d) (skipn (S n) y))
+++++
induction n.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.

*****
A : Type
*****
forall (y : list A) (d : A) (_ : lt O (length y)), eq (skipn O y) (cons (nth O y d) (skipn (S O) y))
+++++
simpl.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.

*****
A : Type
*****
forall (y : list A) (d : A) (_ : lt O (length y)), eq y (cons (nth O y d) match y with | nil => nil | cons _ l => l end)
+++++
intros.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.

*****
H : lt O (length y)
d : A
y : list A
A : Type
*****
eq y (cons (nth O y d) match y with | nil => nil | cons _ l => l end)
+++++
destruct y.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.

*****
H : lt O (length nil)
d : A
A : Type
*****
eq nil (cons (nth O nil d) nil)
+++++
simpl in *.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.
simpl in *.

*****
H : lt O O
d : A
A : Type
*****
eq nil (cons d nil)
+++++
trivial.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.
simpl in *.
trivial.

*****
H : lt O O
d : A
A : Type
*****
eq nil (cons d nil)
+++++
contradict H.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.
simpl in *.
trivial.
contradict H.

*****
d : A
A : Type
*****
not (lt O O)
+++++
omega.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.

*****
H : lt O (length (cons a y))
d : A
y : list A
a : A
A : Type
*****
eq (cons a y) (cons (nth O (cons a y) d) y)
+++++
simpl in *.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.
simpl in *.

*****
H : lt O (S (length y))
d : A
y : list A
a : A
A : Type
*****
eq (cons a y) (cons a y)
+++++
trivial.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.

*****
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y) (cons (nth n y d) (skipn (S n) y))
n : nat
A : Type
*****
forall (y : list A) (d : A) (_ : lt (S n) (length y)), eq (skipn (S n) y) (cons (nth (S n) y d) (skipn (S (S n)) y))
+++++
simpl.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.

*****
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y) (cons (nth n y d) (skipn (S n) y))
n : nat
A : Type
*****
forall (y : list A) (d : A) (_ : lt (S n) (length y)), eq match y with | nil => nil | cons _ l => skipn n l end (cons (nth (S n) y d) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end)
+++++
intros.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.

*****
H : lt (S n) (length y)
d : A
y : list A
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y) (cons (nth n y d) (skipn (S n) y))
n : nat
A : Type
*****
eq match y with | nil => nil | cons _ l => skipn n l end (cons (nth (S n) y d) match y with | cons _ (cons _ l0) => skipn n l0 | _ => nil end)
+++++
destruct y.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.

*****
H : lt (S n) (length nil)
d : A
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y) (cons (nth n y d) (skipn (S n) y))
n : nat
A : Type
*****
eq nil (cons (nth (S n) nil d) nil)
+++++
simpl in *.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.
simpl in *.

*****
H : lt (S n) O
d : A
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y)\n (cons (nth n y d)\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end)
n : nat
A : Type
*****
eq nil (cons d nil)
+++++
contradict H.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.
simpl in *.
contradict H.

*****
d : A
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y)\n (cons (nth n y d)\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end)
n : nat
A : Type
*****
not (lt (S n) O)
+++++
omega.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.

*****
H : lt (S n) (length (cons a y))
d : A
y : list A
a : A
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y) (cons (nth n y d) (skipn (S n) y))
n : nat
A : Type
*****
eq (skipn n y) (cons (nth (S n) (cons a y) d) match y with | nil => nil | cons _ l => skipn n l end)
+++++
simpl in *.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.
simpl in *.

*****
H : lt (S n) (S (length y))
d : A
y : list A
a : A
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y)\n (cons (nth n y d)\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end)
n : nat
A : Type
*****
eq (skipn n y) (cons (nth n y d) match y with | nil => nil | cons _ l => skipn n l end)
+++++
apply IHn.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.
simpl.
intros.
destruct y.
simpl in *.
apply IHn.

*****
H : lt (S n) (S (length y))
d : A
y : list A
a : A
IHn : forall (y : list A) (d : A) (_ : lt n (length y)),\neq (skipn n y)\n (cons (nth n y d)\n match y with\n | nil => nil\n | cons _ l => skipn n l\n end)
n : nat
A : Type
*****
lt n (length y)
+++++
omega.
-----
Lemma skipn_hd : forall {A} n y (d:A), n < length y -> skipn n y = nth n y d :: skipn (S n) y.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma firstn_app {A} (l l' : list A) : \n  firstn (length l) (l ++ l') = l.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.

*****
l,l' : list A
A : Type
*****
eq (firstn (length l) (app l l')) l
+++++
Proof.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.

*****
l,l' : list A
A : Type
*****
eq (firstn (length l) (app l l')) l
+++++
induction l.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.

*****
l' : list A
A : Type
*****
eq (firstn (length nil) (app nil l')) nil
+++++
intros.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.
intros.

*****
l' : list A
A : Type
*****
eq (firstn (length nil) (app nil l')) nil
+++++
simpl.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.
intros.
simpl.

*****
l' : list A
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.

*****
IHl : eq (firstn (length l) (app l l')) l
l,l' : list A
a : A
A : Type
*****
eq (firstn (length (cons a l)) (app (cons a l) l')) (cons a l)
+++++
intros.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.
intros.

*****
IHl : eq (firstn (length l) (app l l')) l
l,l' : list A
a : A
A : Type
*****
eq (firstn (length (cons a l)) (app (cons a l) l')) (cons a l)
+++++
simpl.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.
intros.
simpl.

*****
IHl : eq (firstn (length l) (app l l')) l
l,l' : list A
a : A
A : Type
*****
eq (cons a (firstn (length l) (app l l'))) (cons a l)
+++++
trivial.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.
intros.
simpl.
trivial.

*****
IHl : eq (firstn (length l) (app l l')) l
l,l' : list A
a : A
A : Type
*****
eq (cons a (firstn (length l) (app l l'))) (cons a l)
+++++
rewrite IHl.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.
intros.
simpl.
trivial.
rewrite IHl.

*****
IHl : eq (firstn (length l) (app l l')) l
l,l' : list A
a : A
A : Type
*****
eq (cons a l) (cons a l)
+++++
trivial.
-----
Lemma firstn_app {A} (l l' : list A) : firstn (length l) (l ++ l') = l.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma skipn_app {A} (l l' : list A) : \n  skipn (length l) (l ++ l') = l'.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.

*****
l,l' : list A
A : Type
*****
eq (skipn (length l) (app l l')) l'
+++++
Proof.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.
Proof.

*****
l,l' : list A
A : Type
*****
eq (skipn (length l) (app l l')) l'
+++++
induction l.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.
Proof.
induction l.

*****
l' : list A
A : Type
*****
eq (skipn (length nil) (app nil l')) l'
+++++
intros.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.
Proof.
induction l.
intros.

*****
l' : list A
A : Type
*****
eq (skipn (length nil) (app nil l')) l'
+++++
simpl.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.
Proof.
induction l.
intros.
simpl.

*****
l' : list A
A : Type
*****
eq l' l'
+++++
trivial.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.
Proof.
induction l.

*****
IHl : eq (skipn (length l) (app l l')) l'
l,l' : list A
a : A
A : Type
*****
eq (skipn (length (cons a l)) (app (cons a l) l')) l'
+++++
intros.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.
Proof.
induction l.
intros.

*****
IHl : eq (skipn (length l) (app l l')) l'
l,l' : list A
a : A
A : Type
*****
eq (skipn (length (cons a l)) (app (cons a l) l')) l'
+++++
simpl.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.
Proof.
induction l.
intros.
simpl.

*****
IHl : eq (skipn (length l) (app l l')) l'
l,l' : list A
a : A
A : Type
*****
eq (skipn (length l) (app l l')) l'
+++++
trivial.
-----
Lemma skipn_app {A} (l l' : list A) : skipn (length l) (l ++ l') = l'.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma map_cons : forall A B (f:A->B) a l, map f (a::l) = f a :: map f l.
-----
Lemma map_cons : forall A B (f:A->B) a l, map f (a::l) = f a :: map f l.

*****

*****
forall (A B : Type) (f : forall _ : A, B) (a : A) (l : list A), eq (map f (cons a l)) (cons (f a) (map f l))
+++++
Proof.
-----
Lemma map_cons : forall A B (f:A->B) a l, map f (a::l) = f a :: map f l.
Proof.

*****

*****
forall (A B : Type) (f : forall _ : A, B) (a : A) (l : list A), eq (map f (cons a l)) (cons (f a) (map f l))
+++++
trivial.
-----
Lemma map_cons : forall A B (f:A->B) a l, map f (a::l) = f a :: map f l.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma map_firstn : forall A B (f:A->B) n l,\n  map f (firstn n l) = firstn n (map f l).
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).

*****

*****
forall (A B : Type) (f : forall _ : A, B) (n : nat) (l : list A), eq (map f (firstn n l)) (firstn n (map f l))
+++++
Proof.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.

*****

*****
forall (A B : Type) (f : forall _ : A, B) (n : nat) (l : list A), eq (map f (firstn n l)) (firstn n (map f l))
+++++
induction n.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.

*****
f : forall _ : A, B
B : Type
A : Type
*****
forall l : list A, eq (map f (firstn O l)) (firstn O (map f l))
+++++
simpl.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.

*****
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : list A, eq nil nil
+++++
intros.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.
intros.

*****
l : list A
f : forall _ : A, B
B : Type
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.

*****
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall l : list A, eq (map f (firstn (S n) l)) (firstn (S n) (map f l))
+++++
simpl.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.

*****
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall l : list A, eq (map f match l with | nil => nil | cons a l0 => cons a (firstn n l0) end) match map f l with | nil => nil | cons a l0 => cons a (firstn n l0) end
+++++
intros.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.
intros.

*****
l : list A
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f match l with | nil => nil | cons a l => cons a (firstn n l) end) match map f l with | nil => nil | cons a l => cons a (firstn n l) end
+++++
trivial.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.

*****
l : list A
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f match l with | nil => nil | cons a l => cons a (firstn n l) end) match map f l with | nil => nil | cons a l => cons a (firstn n l) end
+++++
case l.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.

*****
l : list A
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f nil) match map f nil with | nil => nil | cons a l => cons a (firstn n l) end
+++++
simpl.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.
simpl.

*****
l : list A
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.

*****
l : list A
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall (a : A) (l : list A), eq (map f (cons a (firstn n l))) match map f (cons a l) with | nil => nil | cons a0 l0 => cons a0 (firstn n l0) end
+++++
simpl.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.
simpl.

*****
l : list A
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall (a : A) (l : list A), eq (cons (f a) (map f (firstn n l))) (cons (f a) (firstn n (map f l)))
+++++
trivial.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.
simpl.
trivial.

*****
l : list A
IHn : forall l : list A, eq (map f (firstn n l)) (firstn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall (a : A) (l : list A), eq (cons (f a) (map f (firstn n l))) (cons (f a) (firstn n (map f l)))
+++++
congruence.
-----
Lemma map_firstn : forall A B (f:A->B) n l, map f (firstn n l) = firstn n (map f l).
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma map_skipn : forall A B (f:A->B) n l,\n  map f (skipn n l) = skipn n (map f l).
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).

*****

*****
forall (A B : Type) (f : forall _ : A, B) (n : nat) (l : list A), eq (map f (skipn n l)) (skipn n (map f l))
+++++
Proof.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.

*****

*****
forall (A B : Type) (f : forall _ : A, B) (n : nat) (l : list A), eq (map f (skipn n l)) (skipn n (map f l))
+++++
induction n.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.

*****
f : forall _ : A, B
B : Type
A : Type
*****
forall l : list A, eq (map f (skipn O l)) (skipn O (map f l))
+++++
simpl.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.

*****
f : forall _ : A, B
B : Type
A : Type
*****
forall l : list A, eq (map f l) (map f l)
+++++
intros.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.
intros.

*****
l : list A
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f l) (map f l)
+++++
trivial.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.

*****
IHn : forall l : list A, eq (map f (skipn n l)) (skipn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall l : list A, eq (map f (skipn (S n) l)) (skipn (S n) (map f l))
+++++
simpl.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.

*****
IHn : forall l : list A, eq (map f (skipn n l)) (skipn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall l : list A, eq (map f match l with | nil => nil | cons _ l0 => skipn n l0 end) match map f l with | nil => nil | cons _ l0 => skipn n l0 end
+++++
intros.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.
intros.

*****
l : list A
IHn : forall l : list A, eq (map f (skipn n l)) (skipn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f match l with | nil => nil | cons _ l => skipn n l end) match map f l with | nil => nil | cons _ l => skipn n l end
+++++
trivial.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.

*****
l : list A
IHn : forall l : list A, eq (map f (skipn n l)) (skipn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f match l with | nil => nil | cons _ l => skipn n l end) match map f l with | nil => nil | cons _ l => skipn n l end
+++++
case l.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.

*****
l : list A
IHn : forall l : list A, eq (map f (skipn n l)) (skipn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
eq (map f nil) match map f nil with | nil => nil | cons _ l => skipn n l end
+++++
simpl.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.
simpl.

*****
l : list A
IHn : forall l : list A, eq (map f (skipn n l)) (skipn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.

*****
l : list A
IHn : forall l : list A, eq (map f (skipn n l)) (skipn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall (a : A) (l : list A), eq (map f (skipn n l)) match map f (cons a l) with | nil => nil | cons _ l0 => skipn n l0 end
+++++
simpl.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.
simpl.
intros.
trivial.
case l.
simpl.

*****
l : list A
IHn : forall l : list A, eq (map f (skipn n l)) (skipn n (map f l))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall (_ : A) (l : list A), eq (map f (skipn n l)) (skipn n (map f l))
+++++
trivial.
-----
Lemma map_skipn : forall A B (f:A->B) n l, map f (skipn n l) = skipn n (map f l).
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma map_nth_seq : forall A (l:list A) len n d,\n  length l = len + n ->\n  map (fun x : nat => nth x l d) (seq n len) = (skipn n l).
-----
Lemma map_nth_seq : forall A (l:list A) len n d, length l = len + n -> map (fun x : nat => nth x l d) (seq n len) = (skipn n l).

*****

*****
forall (A : Type) (l : list A) (len n : nat) (d : A) (_ : eq (length l) (Init.Nat.add len n)), eq (map (fun x : nat => nth x l d) (seq n len)) (skipn n l)
+++++
Proof.
-----
Lemma map_nth_seq : forall A (l:list A) len n d, length l = len + n -> map (fun x : nat => nth x l d) (seq n len) = (skipn n l).
Proof.

*****

*****
forall (A : Type) (l : list A) (len n : nat) (d : A) (_ : eq (length l) (Init.Nat.add len n)), eq (map (fun x : nat => nth x l d) (seq n len)) (skipn n l)
+++++
intros A l len; revert l.
-----
Lemma map_nth_seq : forall A (l:list A) len n d, length l = len + n -> map (fun x : nat => nth x l d) (seq n len) = (skipn n l).
Proof.
intros A l len; revert l.

*****
len : nat
A : Type
*****
forall (l : list A) (n : nat) (d : A) (_ : eq (length l) (Init.Nat.add len n)), eq (map (fun x : nat => nth x l d) (seq n len)) (skipn n l)
+++++
induction len; simpl; intros.
-----
Lemma map_nth_seq : forall A (l:list A) len n d, length l = len + n -> map (fun x : nat => nth x l d) (seq n len) = (skipn n l).
Proof.
intros A l len; revert l.
induction len; simpl; intros.

*****
H : eq (length l) n
d : A
n : nat
l : list A
A : Type
*****
eq nil (skipn n l)
+++++
rewrite skipn_nil; trivial; omega.
-----
Lemma map_nth_seq : forall A (l:list A) len n d, length l = len + n -> map (fun x : nat => nth x l d) (seq n len) = (skipn n l).
Proof.
intros A l len; revert l.
induction len; simpl; intros.
rewrite skipn_nil; trivial; omega.

*****
H : eq (length l) (S (Init.Nat.add len n))
d : A
n : nat
l : list A
IHlen : forall (l : list A) (n : nat) (d : A)\n (_ : eq (length l) (Init.Nat.add len n)),\neq (map (fun x : nat => nth x l d) (seq n len)) (skipn n l)
len : nat
A : Type
*****
eq (cons (nth n l d) (map (fun x : nat => nth x l d) (seq (S n) len))) (skipn n l)
+++++
rewrite IHlen, <- skipn_hd; trivial; omega.
-----
Lemma map_nth_seq : forall A (l:list A) len n d, length l = len + n -> map (fun x : nat => nth x l d) (seq n len) = (skipn n l).
Proof.
intros A l len; revert l.
induction len; simpl; intros.
rewrite skipn_nil; trivial; omega.
rewrite IHlen, <- skipn_hd; trivial; omega.

*****

*****

+++++
Qed.
-----
Lemma skipn_nil_length : forall A n (l : list A),\n  skipn n l = nil -> length l <= n.
-----
Lemma skipn_nil_length : forall A n (l : list A), skipn n l = nil -> length l <= n.

*****

*****
forall (A : Type) (n : nat) (l : list A) (_ : eq (skipn n l) nil), le (length l) n
+++++
Proof.
-----
Lemma skipn_nil_length : forall A n (l : list A), skipn n l = nil -> length l <= n.
Proof.

*****

*****
forall (A : Type) (n : nat) (l : list A) (_ : eq (skipn n l) nil), le (length l) n
+++++
induction n; simpl in *; intros.
-----
Lemma skipn_nil_length : forall A n (l : list A), skipn n l = nil -> length l <= n.
Proof.
induction n; simpl in *; intros.

*****
H : eq l nil
l : list A
A : Type
*****
le (length l) O
+++++
subst; simpl; trivial.
-----
Lemma skipn_nil_length : forall A n (l : list A), skipn n l = nil -> length l <= n.
Proof.
induction n; simpl in *; intros.
subst; simpl; trivial.

*****
H : eq match l with\n | nil => nil\n | cons _ l => skipn n l\n end nil
l : list A
IHn : forall (l : list A) (_ : eq (skipn n l) nil), le (length l) n
n : nat
A : Type
*****
le (length l) (S n)
+++++
destruct l; simpl; [ omega | ].
-----
Lemma skipn_nil_length : forall A n (l : list A), skipn n l = nil -> length l <= n.
Proof.
induction n; simpl in *; intros.
subst; simpl; trivial.
destruct l; simpl; [ omega | ].

*****
H : eq (skipn n l) nil
l : list A
a : A
IHn : forall (l : list A) (_ : eq (skipn n l) nil), le (length l) n
n : nat
A : Type
*****
le (S (length l)) (S n)
+++++
generalize (IHn _ H); omega.
-----
Lemma skipn_nil_length : forall A n (l : list A), skipn n l = nil -> length l <= n.
Proof.
induction n; simpl in *; intros.
subst; simpl; trivial.
destruct l; simpl; [ omega | ].
generalize (IHn _ H); omega.

*****

*****

+++++
Qed.
-----
Lemma firstn_map_nth :\n  forall A d n m (l:list A),\n  m+n <= length l ->\n  firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).

*****

*****
forall (A : Type) (d : A) (n m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)), eq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
+++++
Proof.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.

*****

*****
forall (A : Type) (d : A) (n m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)), eq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
+++++
induction n as [ | n IH].
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].

*****
d : A
A : Type
*****
forall (m : nat) (l : list A) (_ : le (Init.Nat.add m O) (length l)), eq (firstn O (skipn m l)) (map (fun i : nat => nth i l d) (seq m O))
+++++
simpl.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.

*****
d : A
A : Type
*****
forall (m : nat) (l : list A) (_ : le (Init.Nat.add m O) (length l)), eq nil nil
+++++
intros.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.

*****
H : le (Init.Nat.add m O) (length l)
l : list A
m : nat
d : A
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].

*****
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
forall (m : nat) (l : list A) (_ : le (Init.Nat.add m (S n)) (length l)), eq (firstn (S n) (skipn m l)) (map (fun i : nat => nth i l d) (seq m (S n)))
+++++
simpl.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.

*****
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
forall (m : nat) (l : list A) (_ : le (Init.Nat.add m (S n)) (length l)), eq match skipn m l with | nil => nil | cons a l0 => cons a (firstn n l0) end (cons (nth m l d) (map (fun i : nat => nth i l d) (seq (S m) n)))
+++++
intros.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq match skipn m l with | nil => nil | cons a l => cons a (firstn n l) end (cons (nth m l d) (map (fun i : nat => nth i l d) (seq (S m) n)))
+++++
trivial.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq match skipn m l with | nil => nil | cons a l => cons a (firstn n l) end (cons (nth m l d) (map (fun i : nat => nth i l d) (seq (S m) n)))
+++++
rewrite <- IH.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq match skipn m l with | nil => nil | cons a l => cons a (firstn n l) end (cons (nth m l d) (firstn n (skipn (S m) l)))
+++++
idtac.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq match skipn m l with | nil => nil | cons a l => cons a (firstn n l) end (cons (nth m l d) (firstn n (skipn (S m) l)))
+++++
replace (skipn (S m) l) with (tl (skipn m l)).
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq match skipn m l with | nil => nil | cons a l => cons a (firstn n l) end (cons (nth m l d) (firstn n (tl (skipn m l))))
+++++
case_eq (skipn m l).
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
forall _ : eq (skipn m l) nil, eq nil (cons (nth m l d) (firstn n (tl nil)))
+++++
intro H0.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intro H0.

*****
H0 : eq (skipn m l) nil
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq nil (cons (nth m l d) (firstn n (tl nil)))
+++++
contradict H0.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intro H0.
contradict H0.

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
not (eq (skipn m l) nil)
+++++
contradict H.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intro H0.
contradict H0.
contradict H.

*****
H : eq (skipn m l) nil
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
not (le (Init.Nat.add m (S n)) (length l))
+++++
apply skipn_nil_length in H.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intro H0.
contradict H0.
contradict H.
apply skipn_nil_length in H.

*****
H : le (length l) m
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
not (le (Init.Nat.add m (S n)) (length l))
+++++
omega.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
forall (a : A) (l0 : list A) (_ : eq (skipn m l) (cons a l0)), eq (cons a (firstn n l0)) (cons (nth m l d) (firstn n (tl (cons a l0))))
+++++
intros x l' H0.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intros x l' H0.

*****
H0 : eq (skipn m l) (cons x l')
l' : list A
x : A
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq (cons x (firstn n l')) (cons (nth m l d) (firstn n (tl (cons x l'))))
+++++
simpl.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intros x l' H0.
simpl.

*****
H0 : eq (skipn m l) (cons x l')
l' : list A
x : A
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq (cons x (firstn n l')) (cons (nth m l d) (firstn n l'))
+++++
f_equal.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intros x l' H0.
simpl.
f_equal.

*****
H0 : eq (skipn m l) (cons x l')
l' : list A
x : A
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq x (nth m l d)
+++++
erewrite skipn_hd in H0.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intros x l' H0.
simpl.
f_equal.
erewrite skipn_hd in H0.

*****
H0 : eq (cons (nth m l ?d) (skipn (S m) l)) (cons x l')
l' : list A
x : A
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq x (nth m l d)
+++++
injection H0.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intros x l' H0.
simpl.
f_equal.
erewrite skipn_hd in H0.
injection H0.

*****
H0 : eq (cons (nth m l ?d) (skipn (S m) l)) (cons x l')
l' : list A
x : A
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
forall (_ : eq match l with | nil => nil | cons _ l => skipn m l end l') (_ : eq (nth m l ?d) x), eq x (nth m l d)
+++++
intros _ H1.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intros x l' H0.
simpl.
f_equal.
erewrite skipn_hd in H0.
injection H0.
intros _ H1.

*****
H1 : eq (nth m l ?d) x
H0 : eq (cons (nth m l ?d) (skipn (S m) l)) (cons x l')
l' : list A
x : A
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq x (nth m l d)
+++++
symmetry.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intros x l' H0.
simpl.
f_equal.
erewrite skipn_hd in H0.
injection H0.
intros _ H1.
symmetry.

*****
H1 : eq (nth m l ?d) x
H0 : eq (cons (nth m l ?d) (skipn (S m) l)) (cons x l')
l' : list A
x : A
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq (nth m l d) x
+++++
apply H1.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
case_eq (skipn m l).
intros x l' H0.
simpl.
f_equal.
erewrite skipn_hd in H0.

*****
H0 : eq (skipn m l) (cons x l')
l' : list A
x : A
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
lt m (length l)
+++++
omega.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq (tl (skipn m l)) (skipn (S m) l)
+++++
rewrite <- cons_skipn with (d:=d).
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
rewrite <- cons_skipn with (d:=d).

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
eq (tl (cons (nth m l d) (skipn (S m) l))) (skipn (S m) l)
+++++
trivial.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
rewrite <- cons_skipn with (d:=d).

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
lt m (length l)
+++++
trivial.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.
idtac.
replace (skipn (S m) l) with (tl (skipn m l)).
rewrite <- cons_skipn with (d:=d).
trivial.

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
lt m (length l)
+++++
omega.
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].
simpl.
intros.
trivial.
rewrite <- IH.

*****
H : le (Init.Nat.add m (S n)) (length l)
l : list A
m : nat
IH : forall (m : nat) (l : list A) (_ : le (Init.Nat.add m n) (length l)),\neq (firstn n (skipn m l)) (map (fun i : nat => nth i l d) (seq m n))
n : nat
d : A
A : Type
*****
le (Init.Nat.add (S m) n) (length l)
+++++
omega .
-----
Lemma firstn_map_nth : forall A d n m (l:list A), m+n <= length l -> firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).
Proof.
induction n as [ | n IH].

*****

*****

+++++
Qed.
-----
Lemma firstn_seq n start len :\n  firstn n (seq start len) = seq start (min n len).
-----
Lemma firstn_seq n start len : firstn n (seq start len) = seq start (min n len).

*****
n,start,len : nat
*****
eq (firstn n (seq start len)) (seq start (Init.Nat.min n len))
+++++
Proof.
-----
Lemma firstn_seq n start len : firstn n (seq start len) = seq start (min n len).
Proof.

*****
n,start,len : nat
*****
eq (firstn n (seq start len)) (seq start (Init.Nat.min n len))
+++++
intros; revert n start.
-----
Lemma firstn_seq n start len : firstn n (seq start len) = seq start (min n len).
Proof.
intros; revert n start.

*****
len : nat
*****
forall n start : nat, eq (firstn n (seq start len)) (seq start (Init.Nat.min n len))
+++++
induction len; simpl; intros.
-----
Lemma firstn_seq n start len : firstn n (seq start len) = seq start (min n len).
Proof.
intros; revert n start.
induction len; simpl; intros.

*****
n,start : nat
*****
eq (firstn n nil) (seq start (Init.Nat.min n O))
+++++
rewrite min_r; simpl;[ | omega].
-----
Lemma firstn_seq n start len : firstn n (seq start len) = seq start (min n len).
Proof.
intros; revert n start.
induction len; simpl; intros.
rewrite min_r; simpl;[ | omega].

*****
n,start : nat
*****
eq (firstn n nil) nil
+++++
apply firstn_nil.
-----
Lemma firstn_seq n start len : firstn n (seq start len) = seq start (min n len).
Proof.
intros; revert n start.
induction len; simpl; intros.
rewrite min_r; simpl;[ | omega].
apply firstn_nil.

*****
n,start : nat
IHlen : forall n start : nat,\neq (firstn n (seq start len)) (seq start (Init.Nat.min n len))
len : nat
*****
eq (firstn n (cons start (seq (S start) len))) (seq start (Init.Nat.min n (S len)))
+++++
case n; simpl; trivial; congruence.
-----
Lemma firstn_seq n start len : firstn n (seq start len) = seq start (min n len).
Proof.
intros; revert n start.
induction len; simpl; intros.
rewrite min_r; simpl;[ | omega].
apply firstn_nil.
case n; simpl; trivial; congruence.

*****

*****

+++++
Qed.
-----
Lemma skipn_seq n start len :\n  skipn n (seq start len) = seq (start+n) (len-n).
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).

*****
n,start,len : nat
*****
eq (skipn n (seq start len)) (seq (Init.Nat.add start n) (Init.Nat.sub len n))
+++++
Proof.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.

*****
n,start,len : nat
*****
eq (skipn n (seq start len)) (seq (Init.Nat.add start n) (Init.Nat.sub len n))
+++++
intros.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.

*****
n,start,len : nat
*****
eq (skipn n (seq start len)) (seq (Init.Nat.add start n) (Init.Nat.sub len n))
+++++
revert n start.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.

*****
len : nat
*****
forall n start : nat, eq (skipn n (seq start len)) (seq (Init.Nat.add start n) (Init.Nat.sub len n))
+++++
induction len.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.

*****

*****
forall n start : nat, eq (skipn n (seq start O)) (seq (Init.Nat.add start n) (Init.Nat.sub O n))
+++++
simpl.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.

*****

*****
forall n _ : nat, eq (skipn n nil) nil
+++++
intros.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.

*****
n,start : nat
*****
eq (skipn n nil) nil
+++++
apply skipn_nil.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
apply skipn_nil.

*****
n,start : nat
*****
le (length nil) n
+++++
simpl.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
apply skipn_nil.
simpl.

*****
n,start : nat
*****
le O n
+++++
omega.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.

*****
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
forall n start : nat, eq (skipn n (seq start (S len))) (seq (Init.Nat.add start n) (Init.Nat.sub (S len) n))
+++++
simpl.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.

*****
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
forall n start : nat, eq (skipn n (cons start (seq (S start) len))) (seq (Init.Nat.add start n) match n with | O => S len | S l => Init.Nat.sub len l end)
+++++
intros.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.

*****
n,start : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
eq (skipn n (cons start (seq (S start) len))) (seq (Init.Nat.add start n) match n with | O => S len | S l => Init.Nat.sub len l end)
+++++
case n.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
case n.

*****
n,start : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
eq (skipn O (cons start (seq (S start) len))) (seq (Init.Nat.add start O) (S len))
+++++
simpl.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
case n.
simpl.

*****
n,start : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
eq (cons start (seq (S start) len)) (cons (Init.Nat.add start O) (seq (S (Init.Nat.add start O)) len))
+++++
intros.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
case n.
simpl.
intros.

*****
n,start : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
eq (cons start (seq (S start) len)) (cons (Init.Nat.add start O) (seq (S (Init.Nat.add start O)) len))
+++++
rewrite plus_0_r.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
case n.
simpl.
intros.
rewrite plus_0_r.

*****
n,start : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
eq (cons start (seq (S start) len)) (cons start (seq (S start) len))
+++++
trivial.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
case n.

*****
n,start : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
forall n : nat, eq (skipn (S n) (cons start (seq (S start) len))) (seq (Init.Nat.add start (S n)) (Init.Nat.sub len n))
+++++
simpl.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
case n.
simpl.

*****
n,start : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
forall n : nat, eq (skipn n (seq (S start) len)) (seq (Init.Nat.add start (S n)) (Init.Nat.sub len n))
+++++
intros.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
case n.
simpl.
intros.

*****
n,start,n0 : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
eq (skipn n0 (seq (S start) len)) (seq (Init.Nat.add start (S n0)) (Init.Nat.sub len n0))
+++++
rewrite <- plus_Snm_nSm.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.
simpl.
intros.
case n.
simpl.
intros.
rewrite <- plus_Snm_nSm.

*****
n,start,n0 : nat
IHlen : forall n start : nat,\neq (skipn n (seq start len))\n (seq (Init.Nat.add start n) (Init.Nat.sub len n))
len : nat
*****
eq (skipn n0 (seq (S start) len)) (seq (Init.Nat.add (S start) n0) (Init.Nat.sub len n0))
+++++
apply IHlen.
-----
Lemma skipn_seq n start len : skipn n (seq start len) = seq (start+n) (len-n).
Proof.
intros.
revert n start.
induction len.

*****

*****

+++++
Qed.
-----
Lemma in_seq_iff : forall x len start,\n  In x (seq start len) <-> start <= x < start+len.
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.

*****

*****
forall x len start : nat, iff (In x (seq start len)) (and (le start x) (lt x (Init.Nat.add start len)))
+++++
Proof.
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.

*****

*****
forall x len start : nat, iff (In x (seq start len)) (and (le start x) (lt x (Init.Nat.add start len)))
+++++
intros x len.
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.
intros x len.

*****
x,len : nat
*****
forall start : nat, iff (In x (seq start len)) (and (le start x) (lt x (Init.Nat.add start len)))
+++++
induction len; simpl; intros;[ omega | ].
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.
intros x len.
induction len; simpl; intros;[ omega | ].

*****
start : nat
IHlen : forall start : nat,\niff (In x (seq start len))\n (and (le start x) (lt x (Init.Nat.add start len)))
x,len : nat
*****
iff (or (eq start x) (In x (seq (S start) len))) (and (le start x) (lt x (Init.Nat.add start (S len))))
+++++
split.
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.
intros x len.
induction len; simpl; intros;[ omega | ].
split.

*****
start : nat
IHlen : forall start : nat,\niff (In x (seq start len))\n (and (le start x) (lt x (Init.Nat.add start len)))
x,len : nat
*****
forall _ : or (eq start x) (In x (seq (S start) len)), and (le start x) (lt x (Init.Nat.add start (S len)))
+++++
intros [H | H]; subst; try omega.
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.
intros x len.
induction len; simpl; intros;[ omega | ].
split.
intros [H | H]; subst; try omega.

*****
H : In x (seq (S start) len)
start : nat
IHlen : forall start : nat,\niff (In x (seq start len))\n (and (le start x) (lt x (Init.Nat.add start len)))
x,len : nat
*****
and (le start x) (lt x (Init.Nat.add start (S len)))
+++++
assert (S start <= x < S start + len).
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.
intros x len.
induction len; simpl; intros;[ omega | ].
split.
intros [H | H]; subst; try omega.
assert (S start <= x < S start + len).

*****
H : In x (seq (S start) len)
start : nat
IHlen : forall start : nat,\niff (In x (seq start len))\n (and (le start x) (lt x (Init.Nat.add start len)))
x,len : nat
*****
and (le (S start) x) (lt x (Init.Nat.add (S start) len))
+++++
rewrite <- IHlen; trivial.
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.
intros x len.
induction len; simpl; intros;[ omega | ].
split.
intros [H | H]; subst; try omega.
assert (S start <= x < S start + len).
rewrite <- IHlen; trivial.

*****
H0 : and (le (S start) x) (lt x (Init.Nat.add (S start) len))
H : In x (seq (S start) len)
start : nat
IHlen : forall start : nat,\niff (In x (seq start len))\n (and (le start x) (lt x (Init.Nat.add start len)))
x,len : nat
*****
and (le start x) (lt x (Init.Nat.add start (S len)))
+++++
omega.
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.
intros x len.
induction len; simpl; intros;[ omega | ].
split.
intros [H | H]; subst; try omega.
assert (S start <= x < S start + len).
rewrite <- IHlen; trivial.
omega.

*****
start : nat
IHlen : forall start : nat,\niff (In x (seq start len))\n (and (le start x) (lt x (Init.Nat.add start len)))
x,len : nat
*****
forall _ : and (le start x) (lt x (Init.Nat.add start (S len))), or (eq start x) (In x (seq (S start) len))
+++++
intro H; rewrite IHlen; omega.
-----
Lemma in_seq_iff : forall x len start, In x (seq start len) <-> start <= x < start+len.
Proof.
intros x len.
induction len; simpl; intros;[ omega | ].
split.
intros [H | H]; subst; try omega.
assert (S start <= x < S start + len).
rewrite <- IHlen; trivial.
omega.
intro H; rewrite IHlen; omega.

*****

*****

+++++
Qed.
-----
Lemma nth_map_cst :\n  forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.

*****

*****
forall (A B : Type) (l : list A) (n : nat) (d : B), eq (nth n (map (fun _ : A => d) l) d) d
+++++
Proof.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.

*****

*****
forall (A B : Type) (l : list A) (n : nat) (d : B), eq (nth n (map (fun _ : A => d) l) d) d
+++++
intros A B l.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.

*****
l : list A
B : Type
A : Type
*****
forall (n : nat) (d : B), eq (nth n (map (fun _ : A => d) l) d) d
+++++
induction l as [ | a l IH].
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].

*****
B : Type
A : Type
*****
forall (n : nat) (d : B), eq (nth n (map (fun _ : A => d) nil) d) d
+++++
intros [ | n] d.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].
intros [ | n] d.

*****
d : B
B : Type
A : Type
*****
eq (nth O (map (fun _ : A => d) nil) d) d
+++++
simpl.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].
intros [ | n] d.
simpl.

*****
d : B
B : Type
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].
intros [ | n] d.

*****
d : B
n : nat
B : Type
A : Type
*****
eq (nth (S n) (map (fun _ : A => d) nil) d) d
+++++
simpl.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].
intros [ | n] d.
simpl.

*****
d : B
n : nat
B : Type
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].

*****
IH : forall (n : nat) (d : B), eq (nth n (map (fun _ : A => d) l) d) d
l : list A
a : A
B : Type
A : Type
*****
forall (n : nat) (d : B), eq (nth n (map (fun _ : A => d) (cons a l)) d) d
+++++
intros [ | n] d.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].
intros [ | n] d.

*****
d : B
IH : forall (n : nat) (d : B), eq (nth n (map (fun _ : A => d) l) d) d
l : list A
a : A
B : Type
A : Type
*****
eq (nth O (map (fun _ : A => d) (cons a l)) d) d
+++++
simpl.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].
intros [ | n] d.
simpl.

*****
d : B
IH : forall (n : nat) (d : B), eq (nth n (map (fun _ : A => d) l) d) d
l : list A
a : A
B : Type
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].
intros [ | n] d.

*****
d : B
n : nat
IH : forall (n : nat) (d : B), eq (nth n (map (fun _ : A => d) l) d) d
l : list A
a : A
B : Type
A : Type
*****
eq (nth (S n) (map (fun _ : A => d) (cons a l)) d) d
+++++
simpl.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].
intros [ | n] d.
simpl.

*****
d : B
n : nat
IH : forall (n : nat) (d : B), eq (nth n (map (fun _ : A => d) l) d) d
l : list A
a : A
B : Type
A : Type
*****
eq (nth n (map (fun _ : A => d) l) d) d
+++++
trivial.
-----
Lemma nth_map_cst : forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.
Proof.
intros A B l.
induction l as [ | a l IH].

*****

*****

+++++
Qed.
-----
Lemma nth_S_tl A (l : list A) d n :\n  nth n (tl l) d = nth (S n) l d.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.

*****
n : nat
d : A
l : list A
A : Type
*****
eq (nth n (tl l) d) (nth (S n) l d)
+++++
Proof.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.

*****
n : nat
d : A
l : list A
A : Type
*****
eq (nth n (tl l) d) (nth (S n) l d)
+++++
intros.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.

*****
n : nat
d : A
l : list A
A : Type
*****
eq (nth n (tl l) d) (nth (S n) l d)
+++++
destruct l.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.

*****
n : nat
d : A
A : Type
*****
eq (nth n (tl nil) d) (nth (S n) nil d)
+++++
simpl.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.
simpl.

*****
n : nat
d : A
A : Type
*****
eq match n with | O | _ => d end d
+++++
intros.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.
simpl.
intros.

*****
n : nat
d : A
A : Type
*****
eq match n with | O | _ => d end d
+++++
trivial.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.
simpl.
intros.
trivial.

*****
n : nat
d : A
A : Type
*****
eq match n with | O | _ => d end d
+++++
case n.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.
simpl.
intros.
trivial.
case n.

*****
n : nat
d : A
A : Type
*****
eq d d
+++++
trivial.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.
simpl.
intros.
trivial.
case n.

*****
n : nat
d : A
A : Type
*****
forall _ : nat, eq d d
+++++
trivial.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.

*****
n : nat
d : A
l : list A
a : A
A : Type
*****
eq (nth n (tl (cons a l)) d) (nth (S n) (cons a l) d)
+++++
simpl.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.
simpl.

*****
n : nat
d : A
l : list A
a : A
A : Type
*****
eq (nth n l d) (nth n l d)
+++++
intros.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.
simpl.
intros.

*****
n : nat
d : A
l : list A
a : A
A : Type
*****
eq (nth n l d) (nth n l d)
+++++
trivial.
-----
Lemma nth_S_tl A (l : list A) d n : nth n (tl l) d = nth (S n) l d.
Proof.
intros.
destruct l.

*****

*****

+++++
Qed.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l,\n  (forall a : A, In a l -> f a = g a) -> map f l = map g l.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.

*****

*****
forall (A B : Type) (f g : forall _ : A, B) (l : list A) (_ : forall (a : A) (_ : In a l), eq (f a) (g a)), eq (map f l) (map g l)
+++++
Proof.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.

*****

*****
forall (A B : Type) (f g : forall _ : A, B) (l : list A) (_ : forall (a : A) (_ : In a l), eq (f a) (g a)), eq (map f l) (map g l)
+++++
intros.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.

*****
H : forall (a : A) (_ : In a l), eq (f a) (g a)
l : list A
f,g : forall _ : A, B
B : Type
A : Type
*****
eq (map f l) (map g l)
+++++
induction l.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.

*****
H : forall (a : A) (_ : In a nil), eq (f a) (g a)
f,g : forall _ : A, B
B : Type
A : Type
*****
eq (map f nil) (map g nil)
+++++
simpl.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.

*****
H : forall (a : A) (_ : In a nil), eq (f a) (g a)
f,g : forall _ : A, B
B : Type
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.

*****
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
eq (map f (cons a l)) (map g (cons a l))
+++++
simpl.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.

*****
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
eq (cons (f a) (map f l)) (cons (g a) (map g l))
+++++
trivial.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.

*****
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
eq (cons (f a) (map f l)) (cons (g a) (map g l))
+++++
f_equal.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.
f_equal.

*****
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
eq (f a) (g a)
+++++
apply H.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.
f_equal.
apply H.

*****
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
In a (cons a l)
+++++
simpl.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.
f_equal.
apply H.
simpl.

*****
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
or (eq a a) (In a l)
+++++
auto.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.
f_equal.

*****
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
eq (map f l) (map g l)
+++++
apply IHl.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.
f_equal.
apply IHl.

*****
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
forall (a : A) (_ : In a l), eq (f a) (g a)
+++++
intros.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.
f_equal.
apply IHl.
intros.

*****
H0 : In a0 l
a0 : A
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
eq (f a0) (g a0)
+++++
apply H.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.
f_equal.
apply IHl.
intros.
apply H.

*****
H0 : In a0 l
a0 : A
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
In a0 (cons a l)
+++++
simpl.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.
simpl.
trivial.
f_equal.
apply IHl.
intros.
apply H.
simpl.

*****
H0 : In a0 l
a0 : A
IHl : forall _ : forall (a : A) (_ : In a l), eq (f a) (g a),\neq (map f l) (map g l)
H : forall (a0 : A) (_ : In a0 (cons a l)), eq (f a0) (g a0)
l : list A
a : A
f,g : forall _ : A, B
B : Type
A : Type
*****
or (eq a a0) (In a0 l)
+++++
auto.
-----
Lemma map_ext2 : forall {A B} (f g : A -> B) l, (forall a : A, In a l -> f a = g a) -> map f l = map g l.
Proof.
intros.
induction l.

*****

*****

+++++
Qed.
-----
Lemma map_nth2\n  (A B : Type) (f : A -> B) (l : list A) b d n :\n  (f d) = b ->\n  nth n (map f l) b = f (nth n l d).
-----
Lemma map_nth2 (A B : Type) (f : A -> B) (l : list A) b d n : (f d) = b -> nth n (map f l) b = f (nth n l d).

*****
n : nat
d : A
b : B
l : list A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq (f d) b, eq (nth n (map f l) b) (f (nth n l d))
+++++
Proof.
-----
Lemma map_nth2 (A B : Type) (f : A -> B) (l : list A) b d n : (f d) = b -> nth n (map f l) b = f (nth n l d).
Proof.

*****
n : nat
d : A
b : B
l : list A
f : forall _ : A, B
B : Type
A : Type
*****
forall _ : eq (f d) b, eq (nth n (map f l) b) (f (nth n l d))
+++++
intros.
-----
Lemma map_nth2 (A B : Type) (f : A -> B) (l : list A) b d n : (f d) = b -> nth n (map f l) b = f (nth n l d).
Proof.
intros.

*****
H : eq (f d) b
n : nat
d : A
b : B
l : list A
f : forall _ : A, B
B : Type
A : Type
*****
eq (nth n (map f l) b) (f (nth n l d))
+++++
rewrite <- H.
-----
Lemma map_nth2 (A B : Type) (f : A -> B) (l : list A) b d n : (f d) = b -> nth n (map f l) b = f (nth n l d).
Proof.
intros.
rewrite <- H.

*****
H : eq (f d) b
n : nat
d : A
b : B
l : list A
f : forall _ : A, B
B : Type
A : Type
*****
eq (nth n (map f l) (f d)) (f (nth n l d))
+++++
apply map_nth.
-----
Lemma map_nth2 (A B : Type) (f : A -> B) (l : list A) b d n : (f d) = b -> nth n (map f l) b = f (nth n l d).
Proof.
intros.
rewrite <- H.
apply map_nth.

*****

*****

+++++
Qed.
-----
Lemma length_plus_ex {A} n1 n2 (l : list A):\n  length l = n1 + n2 ->\n  exists l1, exists l2,\n    length l1 = n1 /\ length l2 = n2 /\ l = l1 ++ l2.
-----
Lemma length_plus_ex {A} n1 n2 (l : list A): length l = n1 + n2 -> exists l1, exists l2, length l1 = n1 /\\ length l2 = n2 /\\ l = l1 ++ l2.

*****
l : list A
n1,n2 : nat
A : Type
*****
forall _ : eq (length l) (Init.Nat.add n1 n2), ex (fun l1 : list A => ex (fun l2 : list A => and (eq (length l1) n1) (and (eq (length l2) n2) (eq l (app l1 l2)))))
+++++
Proof.
-----
Lemma length_plus_ex {A} n1 n2 (l : list A): length l = n1 + n2 -> exists l1, exists l2, length l1 = n1 /\\ length l2 = n2 /\\ l = l1 ++ l2.
Proof.

*****
l : list A
n1,n2 : nat
A : Type
*****
forall _ : eq (length l) (Init.Nat.add n1 n2), ex (fun l1 : list A => ex (fun l2 : list A => and (eq (length l1) n1) (and (eq (length l2) n2) (eq l (app l1 l2)))))
+++++
intros.
-----
Lemma length_plus_ex {A} n1 n2 (l : list A): length l = n1 + n2 -> exists l1, exists l2, length l1 = n1 /\\ length l2 = n2 /\\ l = l1 ++ l2.
Proof.
intros.

*****
H : eq (length l) (Init.Nat.add n1 n2)
l : list A
n1,n2 : nat
A : Type
*****
ex (fun l1 : list A => ex (fun l2 : list A => and (eq (length l1) n1) (and (eq (length l2) n2) (eq l (app l1 l2)))))
+++++
exists (firstn n1 l).
-----
Lemma length_plus_ex {A} n1 n2 (l : list A): length l = n1 + n2 -> exists l1, exists l2, length l1 = n1 /\\ length l2 = n2 /\\ l = l1 ++ l2.
Proof.
intros.
exists (firstn n1 l).

*****
H : eq (length l) (Init.Nat.add n1 n2)
l : list A
n1,n2 : nat
A : Type
*****
ex (fun l2 : list A => and (eq (length (firstn n1 l)) n1) (and (eq (length l2) n2) (eq l (app (firstn n1 l) l2))))
+++++
exists (skipn n1 l).
-----
Lemma length_plus_ex {A} n1 n2 (l : list A): length l = n1 + n2 -> exists l1, exists l2, length l1 = n1 /\\ length l2 = n2 /\\ l = l1 ++ l2.
Proof.
intros.
exists (firstn n1 l).
exists (skipn n1 l).

*****
H : eq (length l) (Init.Nat.add n1 n2)
l : list A
n1,n2 : nat
A : Type
*****
and (eq (length (firstn n1 l)) n1) (and (eq (length (skipn n1 l)) n2) (eq l (app (firstn n1 l) (skipn n1 l))))
+++++
rewrite firstn_length, min_l, length_skipn, firstn_skipn; repeat split; omega.
-----
Lemma length_plus_ex {A} n1 n2 (l : list A): length l = n1 + n2 -> exists l1, exists l2, length l1 = n1 /\\ length l2 = n2 /\\ l = l1 ++ l2.
Proof.
intros.
exists (firstn n1 l).
exists (skipn n1 l).
rewrite firstn_length, min_l, length_skipn, firstn_skipn; repeat split; omega.

*****

*****

+++++
Qed.
-----
Lemma tl_app : forall A (l1 l2 : list A),\n  l1 <> nil ->\n  tl (l1 ++ l2) = tl l1 ++ l2.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.

*****

*****
forall (A : Type) (l1 l2 : list A) (_ : not (eq l1 nil)), eq (tl (app l1 l2)) (app (tl l1) l2)
+++++
Proof.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.

*****

*****
forall (A : Type) (l1 l2 : list A) (_ : not (eq l1 nil)), eq (tl (app l1 l2)) (app (tl l1) l2)
+++++
intros.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.
intros.

*****
H : not (eq l1 nil)
l1,l2 : list A
A : Type
*****
eq (tl (app l1 l2)) (app (tl l1) l2)
+++++
destruct l1.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.
intros.
destruct l1.

*****
H : not (eq nil nil)
l2 : list A
A : Type
*****
eq (tl (app nil l2)) (app (tl nil) l2)
+++++
simpl.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.
intros.
destruct l1.
simpl.

*****
H : not (eq nil nil)
l2 : list A
A : Type
*****
eq (tl l2) l2
+++++
trivial.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.
intros.
destruct l1.
simpl.
trivial.

*****
H : not (eq nil nil)
l2 : list A
A : Type
*****
eq (tl l2) l2
+++++
elim H.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.
intros.
destruct l1.
simpl.
trivial.
elim H.

*****
H : not (eq nil nil)
l2 : list A
A : Type
*****
eq nil nil
+++++
trivial.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.
intros.
destruct l1.

*****
H : not (eq (cons a l1) nil)
l1,l2 : list A
a : A
A : Type
*****
eq (tl (app (cons a l1) l2)) (app (tl (cons a l1)) l2)
+++++
simpl.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.
intros.
destruct l1.
simpl.

*****
H : not (eq (cons a l1) nil)
l1,l2 : list A
a : A
A : Type
*****
eq (app l1 l2) (app l1 l2)
+++++
trivial.
-----
Lemma tl_app : forall A (l1 l2 : list A), l1 <> nil -> tl (l1 ++ l2) = tl l1 ++ l2.
Proof.
intros.
destruct l1.

*****

*****

+++++
Qed.
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, \n map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.

*****

*****
forall (A B : Type) (l : list A) (g : forall _ : A, B) (d : A), eq (map (fun n : nat => g (nth n l d)) (seq O (length l))) (map g l)
+++++
Proof.
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.
Proof.

*****

*****
forall (A B : Type) (l : list A) (g : forall _ : A, B) (d : A), eq (map (fun n : nat => g (nth n l d)) (seq O (length l))) (map g l)
+++++
intros A B l g d.
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.
Proof.
intros A B l g d.

*****
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth n l d)) (seq O (length l))) (map g l)
+++++
change l with (skipn 0 l) at 3.
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.
Proof.
intros A B l g d.
change l with (skipn 0 l) at 3.

*****
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth n l d)) (seq O (length l))) (map g (skipn O l))
+++++
rewrite <- map_nth_seq with (len := length l) (d := d).
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.
Proof.
intros A B l g d.
change l with (skipn 0 l) at 3.
rewrite <- map_nth_seq with (len := length l) (d := d).

*****
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth n l d)) (seq O (length l))) (map g (map (fun x : nat => nth x l d) (seq O (length l))))
+++++
rewrite map_map.
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.
Proof.
intros A B l g d.
change l with (skipn 0 l) at 3.
rewrite <- map_nth_seq with (len := length l) (d := d).
rewrite map_map.

*****
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth n l d)) (seq O (length l))) (map (fun x : nat => g (nth x l d)) (seq O (length l)))
+++++
auto.
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.
Proof.
intros A B l g d.
change l with (skipn 0 l) at 3.
rewrite <- map_nth_seq with (len := length l) (d := d).

*****
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (length l) (Init.Nat.add (length l) O)
+++++
auto.
-----
Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.
Proof.
intros A B l g d.
change l with (skipn 0 l) at 3.
rewrite <- map_nth_seq with (len := length l) (d := d).

*****

*****

+++++
Qed.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n,\nn <> 0 ->\nmap f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).

*****

*****
forall (A : Type) (m : nat) (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)), eq (map f (seq O m)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
+++++
Proof.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.

*****

*****
forall (A : Type) (m : nat) (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)), eq (map f (seq O m)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
+++++
induction m.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.

*****
A : Type
*****
forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)), eq (map f (seq O O)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq n O))
+++++
simpl.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.

*****
A : Type
*****
forall (_ : forall _ : nat, A) (n : nat) (_ : not (eq n O)), eq nil nil
+++++
intros.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
A : Type
*****
eq nil nil
+++++
auto.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.

*****
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)), eq (map f (seq O (S m))) (map (fun x : nat => f (Init.Nat.sub x n)) (seq n (S m)))
+++++
simpl.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.

*****
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)), eq (cons (f O) (map f (seq (S O) m))) (cons (f (Init.Nat.sub n n)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq (S n) m)))
+++++
intros.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (cons (f O) (map f (seq (S O) m))) (cons (f (Init.Nat.sub n n)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq (S n) m)))
+++++
auto.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (cons (f O) (map f (seq (S O) m))) (cons (f (Init.Nat.sub n n)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq (S n) m)))
+++++
f_equal.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (f O) (f (Init.Nat.sub n n))
+++++
f_equal.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
f_equal.

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq O (Init.Nat.sub n n)
+++++
omega.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (map f (seq (S O) m)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq (S n) m))
+++++
rewrite <- seq_shift with (start := 0).
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
rewrite <- seq_shift with (start := 0).

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (map f (map S (seq O m))) (map (fun x : nat => f (Init.Nat.sub x n)) (seq (S n) m))
+++++
rewrite map_map.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
rewrite <- seq_shift with (start := 0).
rewrite map_map.

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (map (fun x : nat => f (S x)) (seq O m)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq (S n) m))
+++++
rewrite IHm with (n := S n).
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
rewrite <- seq_shift with (start := 0).
rewrite map_map.
rewrite IHm with (n := S n).

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (map (fun x : nat => f (S (Init.Nat.sub x (S n)))) (seq (S n) m)) (map (fun x : nat => f (Init.Nat.sub x n)) (seq (S n) m))
+++++
apply map_ext2.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
rewrite <- seq_shift with (start := 0).
rewrite map_map.
rewrite IHm with (n := S n).
apply map_ext2.

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
forall (a : nat) (_ : In a (seq (S n) m)), eq (f (S (Init.Nat.sub a (S n)))) (f (Init.Nat.sub a n))
+++++
intros.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
rewrite <- seq_shift with (start := 0).
rewrite map_map.
rewrite IHm with (n := S n).
apply map_ext2.
intros.

*****
H0 : In a (seq (S n) m)
a : nat
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (f (S (Init.Nat.sub a (S n)))) (f (Init.Nat.sub a n))
+++++
f_equal.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
rewrite <- seq_shift with (start := 0).
rewrite map_map.
rewrite IHm with (n := S n).
apply map_ext2.
intros.
f_equal.

*****
H0 : In a (seq (S n) m)
a : nat
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (S (Init.Nat.sub a (S n))) (Init.Nat.sub a n)
+++++
rewrite in_seq_iff in H0.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
rewrite <- seq_shift with (start := 0).
rewrite map_map.
rewrite IHm with (n := S n).
apply map_ext2.
intros.
f_equal.
rewrite in_seq_iff in H0.

*****
H0 : and (le (S n) a) (lt a (Init.Nat.add (S n) m))
a : nat
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
eq (S (Init.Nat.sub a (S n))) (Init.Nat.sub a n)
+++++
omega.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.
simpl.
intros.
auto.
f_equal.
rewrite <- seq_shift with (start := 0).
rewrite map_map.
rewrite IHm with (n := S n).

*****
H : not (eq n O)
n : nat
f : forall _ : nat, A
IHm : forall (f : forall _ : nat, A) (n : nat) (_ : not (eq n O)),\neq (map f (seq O m))\n (map (fun x : nat => f (Init.Nat.sub x n)) (seq n m))
m : nat
A : Type
*****
not (eq (S n) O)
+++++
omega.
-----
Lemma map_seq_shift : forall A m (f : nat -> A) n, n <> 0 -> map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, \n map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.

*****

*****
forall (A B : Type) (l : list A) (g : forall _ : A, B) (d : A) (m : nat), eq (map (fun n : nat => g (nth (Init.Nat.sub n m) l d)) (seq m (length l))) (map g l)
+++++
Proof.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.

*****

*****
forall (A B : Type) (l : list A) (g : forall _ : A, B) (d : A) (m : nat), eq (map (fun n : nat => g (nth (Init.Nat.sub n m) l d)) (seq m (length l))) (map g l)
+++++
intros A B l g d m.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.

*****
m : nat
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth (Init.Nat.sub n m) l d)) (seq m (length l))) (map g l)
+++++
rewrite <- map_seq_nth with (d := d).
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).

*****
m : nat
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth (Init.Nat.sub n m) l d)) (seq m (length l))) (map (fun n : nat => g (nth n l d)) (seq O (length l)))
+++++
destruct m.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.

*****
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth (Init.Nat.sub n O) l d)) (seq O (length l))) (map (fun n : nat => g (nth n l d)) (seq O (length l)))
+++++
simpl.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.
simpl.

*****
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth (Init.Nat.sub n O) l d)) (seq O (length l))) (map (fun n : nat => g (nth n l d)) (seq O (length l)))
+++++
apply map_ext.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.
simpl.
apply map_ext.

*****
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
forall a : nat, eq (g (nth (Init.Nat.sub a O) l d)) (g (nth a l d))
+++++
intros.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.
simpl.
apply map_ext.
intros.

*****
a : nat
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (g (nth (Init.Nat.sub a O) l d)) (g (nth a l d))
+++++
rewrite <- minus_n_O.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.
simpl.
apply map_ext.
intros.
rewrite <- minus_n_O.

*****
a : nat
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (g (nth a l d)) (g (nth a l d))
+++++
trivial.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.

*****
m : nat
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth (Init.Nat.sub n (S m)) l d)) (seq (S m) (length l))) (map (fun n : nat => g (nth n l d)) (seq O (length l)))
+++++
simpl.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.
simpl.

*****
m : nat
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth (Init.Nat.sub n (S m)) l d)) (seq (S m) (length l))) (map (fun n : nat => g (nth n l d)) (seq O (length l)))
+++++
rewrite map_seq_shift with (n := S m).
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.
simpl.
rewrite map_seq_shift with (n := S m).

*****
m : nat
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
eq (map (fun n : nat => g (nth (Init.Nat.sub n (S m)) l d)) (seq (S m) (length l))) (map (fun x : nat => g (nth (Init.Nat.sub x (S m)) l d)) (seq (S m) (length l)))
+++++
auto.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.
simpl.
rewrite map_seq_shift with (n := S m).

*****
m : nat
d : A
g : forall _ : A, B
l : list A
B : Type
A : Type
*****
not (eq (S m) O)
+++++
auto.
-----
Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.
Proof.
intros A B l g d m.
rewrite <- map_seq_nth with (d := d).
destruct m.

*****

*****

+++++
Qed.
-----
Lemma seq_app : forall x y z,\n  seq x y ++ seq (x + y) z = seq x (y + z).
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).

*****

*****
forall x y z : nat, eq (app (seq x y) (seq (Init.Nat.add x y) z)) (seq x (Init.Nat.add y z))
+++++
Proof.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.

*****

*****
forall x y z : nat, eq (app (seq x y) (seq (Init.Nat.add x y) z)) (seq x (Init.Nat.add y z))
+++++
intros.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.

*****
x,y,z : nat
*****
eq (app (seq x y) (seq (Init.Nat.add x y) z)) (seq x (Init.Nat.add y z))
+++++
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).

*****
x,y,z : nat
*****
eq (app (seq x y) (seq (Init.Nat.add x y) z)) (app (firstn y (seq x (Init.Nat.add y z))) (skipn y (seq x (Init.Nat.add y z))))
+++++
f_equal.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.

*****
x,y,z : nat
*****
eq (seq x y) (firstn y (seq x (Init.Nat.add y z)))
+++++
rewrite firstn_seq.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.
rewrite firstn_seq.

*****
x,y,z : nat
*****
eq (seq x y) (seq x (Init.Nat.min y (Init.Nat.add y z)))
+++++
rewrite Min.min_l.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.
rewrite firstn_seq.
rewrite Min.min_l.

*****
x,y,z : nat
*****
eq (seq x y) (seq x y)
+++++
auto.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.
rewrite firstn_seq.
rewrite Min.min_l.

*****
x,y,z : nat
*****
le y (Init.Nat.add y z)
+++++
auto.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.
rewrite firstn_seq.
rewrite Min.min_l.
auto.

*****
x,y,z : nat
*****
le y (Init.Nat.add y z)
+++++
omega.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.

*****
x,y,z : nat
*****
eq (seq (Init.Nat.add x y) z) (skipn y (seq x (Init.Nat.add y z)))
+++++
rewrite skipn_seq.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.
rewrite skipn_seq.

*****
x,y,z : nat
*****
eq (seq (Init.Nat.add x y) z) (seq (Init.Nat.add x y) (Init.Nat.sub (Init.Nat.add y z) y))
+++++
f_equal.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.
rewrite skipn_seq.
f_equal.

*****
x,y,z : nat
*****
eq z (Init.Nat.sub (Init.Nat.add y z) y)
+++++
omega.
-----
Lemma seq_app : forall x y z, seq x y ++ seq (x + y) z = seq x (y + z).
Proof.
intros.
rewrite <- firstn_skipn with (l := seq x (y + z)) (n := y).
f_equal.

*****

*****

+++++
Qed.
-----
Definition andl {A} (P:A->Prop)(l:list A) : Prop :=\n  fold_right (fun a res => P a /\ res) True l.
-----
Lemma forall_andl A (P:A->Prop) l :\n  (forall x, In x l -> P x) <-> andl P l.
-----
Lemma forall_andl A (P:A->Prop) l : (forall x, In x l -> P x) <-> andl P l.

*****
l : list A
P : forall _ : A, Prop
A : Type
*****
iff (forall (x : A) (_ : In x l), P x) (andl P l)
+++++
Proof.
-----
Lemma forall_andl A (P:A->Prop) l : (forall x, In x l -> P x) <-> andl P l.
Proof.

*****
l : list A
P : forall _ : A, Prop
A : Type
*****
iff (forall (x : A) (_ : In x l), P x) (andl P l)
+++++
induction l; simpl; intros;[ tauto | ].
-----
Lemma forall_andl A (P:A->Prop) l : (forall x, In x l -> P x) <-> andl P l.
Proof.
induction l; simpl; intros;[ tauto | ].

*****
IHl : iff (forall (x : A) (_ : In x l), P x) (andl P l)
l : list A
a : A
P : forall _ : A, Prop
A : Type
*****
iff (forall (x : A) (_ : or (eq a x) (In x l)), P x) (and (P a) (andl P l))
+++++
split; intro.
-----
Lemma forall_andl A (P:A->Prop) l : (forall x, In x l -> P x) <-> andl P l.
Proof.
induction l; simpl; intros;[ tauto | ].
split; intro.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), P x
IHl : iff (forall (x : A) (_ : In x l), P x) (andl P l)
l : list A
a : A
P : forall _ : A, Prop
A : Type
*****
and (P a) (andl P l)
+++++
rewrite <- IHl; auto.
-----
Lemma forall_andl A (P:A->Prop) l : (forall x, In x l -> P x) <-> andl P l.
Proof.
induction l; simpl; intros;[ tauto | ].
split; intro.
rewrite <- IHl; auto.

*****
H : and (P a) (andl P l)
IHl : iff (forall (x : A) (_ : In x l), P x) (andl P l)
l : list A
a : A
P : forall _ : A, Prop
A : Type
*****
forall (x : A) (_ : or (eq a x) (In x l)), P x
+++++
intros x [H1 | H2]; subst;[ tauto | ].
-----
Lemma forall_andl A (P:A->Prop) l : (forall x, In x l -> P x) <-> andl P l.
Proof.
induction l; simpl; intros;[ tauto | ].
split; intro.
rewrite <- IHl; auto.
intros x [H1 | H2]; subst;[ tauto | ].

*****
H2 : In x l
x : A
H : and (P a) (andl P l)
IHl : iff (forall (x : A) (_ : In x l), P x) (andl P l)
l : list A
a : A
P : forall _ : A, Prop
A : Type
*****
P x
+++++
apply IHl; tauto.
-----
Lemma forall_andl A (P:A->Prop) l : (forall x, In x l -> P x) <-> andl P l.
Proof.
induction l; simpl; intros;[ tauto | ].
split; intro.
rewrite <- IHl; auto.
intros x [H1 | H2]; subst;[ tauto | ].
apply IHl; tauto.

*****

*****

+++++
Qed.
-----
Fixpoint fun_power {A:Type}(n:nat)(f:A->A)(x:A) : A :=\n  match n with\n  | 0 => x\n  | S n' => f (fun_power n' f x)\n  end.
-----
Lemma fun_power_minus_S : forall A (f:A->A) x m n,\n  m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.
-----
Lemma fun_power_minus_S : forall A (f:A->A) x m n, m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.

*****

*****
forall (A : Type) (f : forall _ : A, A) (x : A) (m n : nat) (_ : lt m n), eq (f (fun_power (Init.Nat.sub n (S m)) f x)) (fun_power (Init.Nat.sub n m) f x)
+++++
Proof.
-----
Lemma fun_power_minus_S : forall A (f:A->A) x m n, m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.
Proof.

*****

*****
forall (A : Type) (f : forall _ : A, A) (x : A) (m n : nat) (_ : lt m n), eq (f (fun_power (Init.Nat.sub n (S m)) f x)) (fun_power (Init.Nat.sub n m) f x)
+++++
intros A f x m n H.
-----
Lemma fun_power_minus_S : forall A (f:A->A) x m n, m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.
Proof.
intros A f x m n H.

*****
H : lt m n
m,n : nat
x : A
f : forall _ : A, A
A : Type
*****
eq (f (fun_power (Init.Nat.sub n (S m)) f x)) (fun_power (Init.Nat.sub n m) f x)
+++++
replace (n-m) with (S (n - S m)) by omega.
-----
Lemma fun_power_minus_S : forall A (f:A->A) x m n, m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.
Proof.
intros A f x m n H.
replace (n-m) with (S (n - S m)) by omega.

*****
H : lt m n
m,n : nat
x : A
f : forall _ : A, A
A : Type
*****
eq (f (fun_power (Init.Nat.sub n (S m)) f x)) (fun_power (S (Init.Nat.sub n (S m))) f x)
+++++
trivial.
-----
Lemma fun_power_minus_S : forall A (f:A->A) x m n, m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.
Proof.
intros A f x m n H.
replace (n-m) with (S (n - S m)) by omega.
trivial.

*****

*****

+++++
Qed.
-----
Definition mod2 (n : nat) : nat :=\n  n - 2 * div2 n.
-----
Fixpoint power (m n:nat) : nat :=\n match n with\n | 0 => 1\n | S n' => m * power m n'\n end.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.

*****

*****
forall (a b n : nat) (_ : le a b), le (power a n) (power b n)
+++++
Proof.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.

*****

*****
forall (a b n : nat) (_ : le a b), le (power a n) (power b n)
+++++
induction n.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.

*****
a,b : nat
*****
forall _ : le a b, le (power a O) (power b O)
+++++
simpl.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.
simpl.

*****
a,b : nat
*****
forall _ : le a b, le (S O) (S O)
+++++
intros.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.
simpl.
intros.

*****
H : le a b
a,b : nat
*****
le (S O) (S O)
+++++
trivial.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.

*****
IHn : forall _ : le a b, le (power a n) (power b n)
a,b,n : nat
*****
forall _ : le a b, le (power a (S n)) (power b (S n))
+++++
simpl.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.
simpl.

*****
IHn : forall _ : le a b, le (power a n) (power b n)
a,b,n : nat
*****
forall _ : le a b, le (Init.Nat.mul a (power a n)) (Init.Nat.mul b (power b n))
+++++
intros.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.
simpl.
intros.

*****
H : le a b
IHn : forall _ : le a b, le (power a n) (power b n)
a,b,n : nat
*****
le (Init.Nat.mul a (power a n)) (Init.Nat.mul b (power b n))
+++++
trivial.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.
simpl.
intros.
trivial.

*****
H : le a b
IHn : forall _ : le a b, le (power a n) (power b n)
a,b,n : nat
*****
le (Init.Nat.mul a (power a n)) (Init.Nat.mul b (power b n))
+++++
apply mult_le_compat.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.
simpl.
intros.
trivial.
apply mult_le_compat.

*****
H : le a b
IHn : forall _ : le a b, le (power a n) (power b n)
a,b,n : nat
*****
le a b
+++++
tauto.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.
simpl.
intros.
trivial.
apply mult_le_compat.

*****
H : le a b
IHn : forall _ : le a b, le (power a n) (power b n)
a,b,n : nat
*****
le (power a n) (power b n)
+++++
tauto.
-----
Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Definition plusl (l:list nat) : nat :=\n  fold_right plus 0 l.
-----
Lemma plusl_cons : forall x l, plusl (x :: l) = x + plusl l.
-----
Lemma plusl_cons : forall x l, plusl (x :: l) = x + plusl l.

*****

*****
forall (x : nat) (l : list nat), eq (plusl (cons x l)) (Init.Nat.add x (plusl l))
+++++
Proof.
-----
Lemma plusl_cons : forall x l, plusl (x :: l) = x + plusl l.
Proof.

*****

*****
forall (x : nat) (l : list nat), eq (plusl (cons x l)) (Init.Nat.add x (plusl l))
+++++
trivial.
-----
Lemma plusl_cons : forall x l, plusl (x :: l) = x + plusl l.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma plusl_app l1 l2 :\n  plusl (l1++l2) = plusl l1 + plusl l2.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.

*****
l1,l2 : list nat
*****
eq (plusl (app l1 l2)) (Init.Nat.add (plusl l1) (plusl l2))
+++++
Proof.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.

*****
l1,l2 : list nat
*****
eq (plusl (app l1 l2)) (Init.Nat.add (plusl l1) (plusl l2))
+++++
induction l1.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.

*****
l2 : list nat
*****
eq (plusl (app nil l2)) (Init.Nat.add (plusl nil) (plusl l2))
+++++
simpl.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.
simpl.

*****
l2 : list nat
*****
eq (plusl l2) (plusl l2)
+++++
intros.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.
simpl.
intros.

*****
l2 : list nat
*****
eq (plusl l2) (plusl l2)
+++++
trivial.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.

*****
IHl1 : eq (plusl (app l1 l2)) (Init.Nat.add (plusl l1) (plusl l2))
l1,l2 : list nat
a : nat
*****
eq (plusl (app (cons a l1) l2)) (Init.Nat.add (plusl (cons a l1)) (plusl l2))
+++++
simpl.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.
simpl.

*****
IHl1 : eq (plusl (app l1 l2)) (Init.Nat.add (plusl l1) (plusl l2))
l1,l2 : list nat
a : nat
*****
eq (Init.Nat.add a (plusl (app l1 l2))) (Init.Nat.add (Init.Nat.add a (plusl l1)) (plusl l2))
+++++
intros.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.
simpl.
intros.

*****
IHl1 : eq (plusl (app l1 l2)) (Init.Nat.add (plusl l1) (plusl l2))
l1,l2 : list nat
a : nat
*****
eq (Init.Nat.add a (plusl (app l1 l2))) (Init.Nat.add (Init.Nat.add a (plusl l1)) (plusl l2))
+++++
trivial.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.
simpl.
intros.
trivial.

*****
IHl1 : eq (plusl (app l1 l2)) (Init.Nat.add (plusl l1) (plusl l2))
l1,l2 : list nat
a : nat
*****
eq (Init.Nat.add a (plusl (app l1 l2))) (Init.Nat.add (Init.Nat.add a (plusl l1)) (plusl l2))
+++++
rewrite IHl1.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.
simpl.
intros.
trivial.
rewrite IHl1.

*****
IHl1 : eq (plusl (app l1 l2)) (Init.Nat.add (plusl l1) (plusl l2))
l1,l2 : list nat
a : nat
*****
eq (Init.Nat.add a (Init.Nat.add (plusl l1) (plusl l2))) (Init.Nat.add (Init.Nat.add a (plusl l1)) (plusl l2))
+++++
ring.
-----
Lemma plusl_app l1 l2 : plusl (l1++l2) = plusl l1 + plusl l2.
Proof.
induction l1.

*****

*****

+++++
Qed.
-----
Lemma plusl_compat : forall A (l : list A) f g,\n  (forall x, In x l -> f x <= g x) ->\n  plusl (map f l) <= plusl (map g l).
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).

*****

*****
forall (A : Type) (l : list A) (f g : forall _ : A, nat) (_ : forall (x : A) (_ : In x l), le (f x) (g x)), le (plusl (map f l)) (plusl (map g l))
+++++
Proof.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.

*****

*****
forall (A : Type) (l : list A) (f g : forall _ : A, nat) (_ : forall (x : A) (_ : In x l), le (f x) (g x)), le (plusl (map f l)) (plusl (map g l))
+++++
induction l.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.

*****
A : Type
*****
forall (f g : forall _ : A, nat) (_ : forall (x : A) (_ : In x nil), le (f x) (g x)), le (plusl (map f nil)) (plusl (map g nil))
+++++
simpl.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.
simpl.

*****
A : Type
*****
forall (f g : forall _ : A, nat) (_ : forall (x : A) (_ : False), le (f x) (g x)), le O O
+++++
intros.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.
simpl.
intros.

*****
H : forall (x : A) (_ : False), le (f x) (g x)
f,g : forall _ : A, nat
A : Type
*****
le O O
+++++
auto.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.

*****
IHl : forall (f g : forall _ : A, nat)\n (_ : forall (x : A) (_ : In x l), le (f x) (g x)),\nle (plusl (map f l)) (plusl (map g l))
l : list A
a : A
A : Type
*****
forall (f g : forall _ : A, nat) (_ : forall (x : A) (_ : In x (cons a l)), le (f x) (g x)), le (plusl (map f (cons a l))) (plusl (map g (cons a l)))
+++++
simpl.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.
simpl.

*****
IHl : forall (f g : forall _ : A, nat)\n (_ : forall (x : A) (_ : In x l), le (f x) (g x)),\nle (plusl (map f l)) (plusl (map g l))
l : list A
a : A
A : Type
*****
forall (f g : forall _ : A, nat) (_ : forall (x : A) (_ : or (eq a x) (In x l)), le (f x) (g x)), le (Init.Nat.add (f a) (plusl (map f l))) (Init.Nat.add (g a) (plusl (map g l)))
+++++
intros.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.
simpl.
intros.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), le (f x) (g x)
f,g : forall _ : A, nat
IHl : forall (f g : forall _ : A, nat)\n (_ : forall (x : A) (_ : In x l), le (f x) (g x)),\nle (plusl (map f l)) (plusl (map g l))
l : list A
a : A
A : Type
*****
le (Init.Nat.add (f a) (plusl (map f l))) (Init.Nat.add (g a) (plusl (map g l)))
+++++
auto.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.
simpl.
intros.
auto.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), le (f x) (g x)
f,g : forall _ : A, nat
IHl : forall (f g : forall _ : A, nat)\n (_ : forall (x : A) (_ : In x l), le (f x) (g x)),\nle (plusl (map f l)) (plusl (map g l))
l : list A
a : A
A : Type
*****
le (Init.Nat.add (f a) (plusl (map f l))) (Init.Nat.add (g a) (plusl (map g l)))
+++++
apply plus_le_compat.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.
simpl.
intros.
auto.
apply plus_le_compat.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), le (f x) (g x)
f,g : forall _ : A, nat
IHl : forall (f g : forall _ : A, nat)\n (_ : forall (x : A) (_ : In x l), le (f x) (g x)),\nle (plusl (map f l)) (plusl (map g l))
l : list A
a : A
A : Type
*****
le (f a) (g a)
+++++
auto.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.
simpl.
intros.
auto.
apply plus_le_compat.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), le (f x) (g x)
f,g : forall _ : A, nat
IHl : forall (f g : forall _ : A, nat)\n (_ : forall (x : A) (_ : In x l), le (f x) (g x)),\nle (plusl (map f l)) (plusl (map g l))
l : list A
a : A
A : Type
*****
le (plusl (map f l)) (plusl (map g l))
+++++
auto.
-----
Lemma plusl_compat : forall A (l : list A) f g, (forall x, In x l -> f x <= g x) -> plusl (map f l) <= plusl (map g l).
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Definition multl (l:list nat) : nat :=\n  fold_right mult 1 l.
-----
Lemma multl_app l1 l2 :\n  multl (l1++l2) = multl l1 * multl l2.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.

*****
l1,l2 : list nat
*****
eq (multl (app l1 l2)) (Init.Nat.mul (multl l1) (multl l2))
+++++
Proof.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.

*****
l1,l2 : list nat
*****
eq (multl (app l1 l2)) (Init.Nat.mul (multl l1) (multl l2))
+++++
induction l1.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.

*****
l2 : list nat
*****
eq (multl (app nil l2)) (Init.Nat.mul (multl nil) (multl l2))
+++++
simpl.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.
simpl.

*****
l2 : list nat
*****
eq (multl l2) (Init.Nat.add (multl l2) O)
+++++
intros.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.
simpl.
intros.

*****
l2 : list nat
*****
eq (multl l2) (Init.Nat.add (multl l2) O)
+++++
trivial.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.

*****
IHl1 : eq (multl (app l1 l2)) (Init.Nat.mul (multl l1) (multl l2))
l1,l2 : list nat
a : nat
*****
eq (multl (app (cons a l1) l2)) (Init.Nat.mul (multl (cons a l1)) (multl l2))
+++++
simpl.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.
simpl.

*****
IHl1 : eq (multl (app l1 l2)) (Init.Nat.mul (multl l1) (multl l2))
l1,l2 : list nat
a : nat
*****
eq (Init.Nat.mul a (multl (app l1 l2))) (Init.Nat.mul (Init.Nat.mul a (multl l1)) (multl l2))
+++++
intros.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.
simpl.
intros.

*****
IHl1 : eq (multl (app l1 l2)) (Init.Nat.mul (multl l1) (multl l2))
l1,l2 : list nat
a : nat
*****
eq (Init.Nat.mul a (multl (app l1 l2))) (Init.Nat.mul (Init.Nat.mul a (multl l1)) (multl l2))
+++++
trivial.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.
simpl.
intros.
trivial.

*****
IHl1 : eq (multl (app l1 l2)) (Init.Nat.mul (multl l1) (multl l2))
l1,l2 : list nat
a : nat
*****
eq (Init.Nat.mul a (multl (app l1 l2))) (Init.Nat.mul (Init.Nat.mul a (multl l1)) (multl l2))
+++++
rewrite IHl1.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.
simpl.
intros.
trivial.
rewrite IHl1.

*****
IHl1 : eq (multl (app l1 l2)) (Init.Nat.mul (multl l1) (multl l2))
l1,l2 : list nat
a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (multl l1) (multl l2))) (Init.Nat.mul (Init.Nat.mul a (multl l1)) (multl l2))
+++++
ring.
-----
Lemma multl_app l1 l2 : multl (l1++l2) = multl l1 * multl l2.
Proof.
induction l1.

*****

*****

+++++
Qed.
-----
Lemma multl_plus_distr_l n l :\n  n * plusl l = plusl (map (fun m => n * m) l).
-----
Lemma multl_plus_distr_l n l : n * plusl l = plusl (map (fun m => n * m) l).

*****
l : list nat
n : nat
*****
eq (Init.Nat.mul n (plusl l)) (plusl (map (fun m : nat => Init.Nat.mul n m) l))
+++++
Proof.
-----
Lemma multl_plus_distr_l n l : n * plusl l = plusl (map (fun m => n * m) l).
Proof.

*****
l : list nat
n : nat
*****
eq (Init.Nat.mul n (plusl l)) (plusl (map (fun m : nat => Init.Nat.mul n m) l))
+++++
induction l as [ | m l' IH]; simpl; intros; [ | rewrite <- IH]; ring.
-----
Lemma multl_plus_distr_l n l : n * plusl l = plusl (map (fun m => n * m) l).
Proof.
induction l as [ | m l' IH]; simpl; intros; [ | rewrite <- IH]; ring.

*****

*****

+++++
Qed.
-----
Fixpoint maxl l := \n  match l with\n    | nil => 0\n    | a :: l' => max a (maxl l')\n  end.
-----
Lemma in_le_maxl x l : In x l -> x <= maxl l.
-----
Lemma in_le_maxl x l : In x l -> x <= maxl l.

*****
l : list nat
x : nat
*****
forall _ : In x l, le x (maxl l)
+++++
Proof.
-----
Lemma in_le_maxl x l : In x l -> x <= maxl l.
Proof.

*****
l : list nat
x : nat
*****
forall _ : In x l, le x (maxl l)
+++++
induction l; simpl; intros.
-----
Lemma in_le_maxl x l : In x l -> x <= maxl l.
Proof.
induction l; simpl; intros.

*****
H : False
x : nat
*****
le x O
+++++
tauto.
-----
Lemma in_le_maxl x l : In x l -> x <= maxl l.
Proof.
induction l; simpl; intros.
tauto.

*****
H : or (eq a x) (In x l)
IHl : forall _ : In x l, le x (maxl l)
l : list nat
x,a : nat
*****
le x (Init.Nat.max a (maxl l))
+++++
destruct H; subst.
-----
Lemma in_le_maxl x l : In x l -> x <= maxl l.
Proof.
induction l; simpl; intros.
tauto.
destruct H; subst.

*****
IHl : forall _ : In x l, le x (maxl l)
l : list nat
x : nat
*****
le x (Init.Nat.max x (maxl l))
+++++
apply Nat.le_max_l.
-----
Lemma in_le_maxl x l : In x l -> x <= maxl l.
Proof.
induction l; simpl; intros.
tauto.
destruct H; subst.
apply Nat.le_max_l.

*****
H : In x l
IHl : forall _ : In x l, le x (maxl l)
l : list nat
x,a : nat
*****
le x (Init.Nat.max a (maxl l))
+++++
eapply le_trans; [ | apply Nat.le_max_r]; tauto.
-----
Lemma in_le_maxl x l : In x l -> x <= maxl l.
Proof.
induction l; simpl; intros.
tauto.
destruct H; subst.
apply Nat.le_max_l.
eapply le_trans; [ | apply Nat.le_max_r]; tauto.

*****

*****

+++++
Qed.
-----
Lemma maxl_map A l (f : A -> nat) n :\n  (forall x, In x l -> f x = n) ->\n  maxl (map f l) <= n.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.

*****
n : nat
f : forall _ : A, nat
l : list A
A : Type
*****
forall _ : forall (x : A) (_ : In x l), eq (f x) n, le (maxl (map f l)) n
+++++
Proof.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.

*****
n : nat
f : forall _ : A, nat
l : list A
A : Type
*****
forall _ : forall (x : A) (_ : In x l), eq (f x) n, le (maxl (map f l)) n
+++++
induction l.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.

*****
n : nat
f : forall _ : A, nat
A : Type
*****
forall _ : forall (x : A) (_ : In x nil), eq (f x) n, le (maxl (map f nil)) n
+++++
simpl.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.

*****
n : nat
f : forall _ : A, nat
A : Type
*****
forall _ : forall (x : A) (_ : False), eq (f x) n, le O n
+++++
intros.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.

*****
H : forall (x : A) (_ : False), eq (f x) n
n : nat
f : forall _ : A, nat
A : Type
*****
le O n
+++++
trivial.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.

*****
H : forall (x : A) (_ : False), eq (f x) n
n : nat
f : forall _ : A, nat
A : Type
*****
le O n
+++++
omega.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.

*****
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
forall _ : forall (x : A) (_ : In x (cons a l)), eq (f x) n, le (maxl (map f (cons a l))) n
+++++
simpl.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.

*****
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
forall _ : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n, le (Init.Nat.max (f a) (maxl (map f l))) n
+++++
intros.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (Init.Nat.max (f a) (maxl (map f l))) n
+++++
trivial.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (Init.Nat.max (f a) (maxl (map f l))) n
+++++
apply Nat.max_lub.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.
apply Nat.max_lub.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (f a) n
+++++
rewrite H.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.
apply Nat.max_lub.
rewrite H.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
le n n
+++++
auto.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.
apply Nat.max_lub.
rewrite H.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
or (eq a a) (In a l)
+++++
auto.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.
apply Nat.max_lub.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (maxl (map f l)) n
+++++
apply IHl.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.
apply Nat.max_lub.
apply IHl.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
forall (x : A) (_ : In x l), eq (f x) n
+++++
intros.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.
apply Nat.max_lub.
apply IHl.
intros.

*****
H0 : In x l
x : A
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
eq (f x) n
+++++
apply H.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.
simpl.
intros.
trivial.
apply Nat.max_lub.
apply IHl.
intros.
apply H.

*****
H0 : In x l
x : A
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) n
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) n,\nle (maxl (map f l)) n
n : nat
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
or (eq a x) (In x l)
+++++
auto.
-----
Lemma maxl_map A l (f : A -> nat) n : (forall x, In x l -> f x = n) -> maxl (map f l) <= n.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma maxl_le l e :\n  maxl l <= e ->\n  (forall x, In x l -> x <= e).
-----
Lemma maxl_le l e : maxl l <= e -> (forall x, In x l -> x <= e).

*****
e : nat
l : list nat
*****
forall (_ : le (maxl l) e) (x : nat) (_ : In x l), le x e
+++++
Proof.
-----
Lemma maxl_le l e : maxl l <= e -> (forall x, In x l -> x <= e).
Proof.

*****
e : nat
l : list nat
*****
forall (_ : le (maxl l) e) (x : nat) (_ : In x l), le x e
+++++
induction l; simpl;[ tauto | intros].
-----
Lemma maxl_le l e : maxl l <= e -> (forall x, In x l -> x <= e).
Proof.
induction l; simpl;[ tauto | intros].

*****
H0 : or (eq a x) (In x l)
x : nat
H : le (Init.Nat.max a (maxl l)) e
IHl : forall (_ : le (maxl l) e) (x : nat) (_ : In x l), le x e
e : nat
l : list nat
a : nat
*****
le x e
+++++
destruct H0; subst.
-----
Lemma maxl_le l e : maxl l <= e -> (forall x, In x l -> x <= e).
Proof.
induction l; simpl;[ tauto | intros].
destruct H0; subst.

*****
H : le (Init.Nat.max x (maxl l)) e
x : nat
IHl : forall (_ : le (maxl l) e) (x : nat) (_ : In x l), le x e
e : nat
l : list nat
*****
le x e
+++++
apply Nat.max_lub_l with (maxl l); trivial.
-----
Lemma maxl_le l e : maxl l <= e -> (forall x, In x l -> x <= e).
Proof.
induction l; simpl;[ tauto | intros].
destruct H0; subst.
apply Nat.max_lub_l with (maxl l); trivial.

*****
H0 : In x l
x : nat
H : le (Init.Nat.max a (maxl l)) e
IHl : forall (_ : le (maxl l) e) (x : nat) (_ : In x l), le x e
e : nat
l : list nat
a : nat
*****
le x e
+++++
apply IHl; trivial.
-----
Lemma maxl_le l e : maxl l <= e -> (forall x, In x l -> x <= e).
Proof.
induction l; simpl;[ tauto | intros].
destruct H0; subst.
apply Nat.max_lub_l with (maxl l); trivial.
apply IHl; trivial.

*****
H0 : In x l
x : nat
H : le (Init.Nat.max a (maxl l)) e
IHl : forall (_ : le (maxl l) e) (x : nat) (_ : In x l), le x e
e : nat
l : list nat
a : nat
*****
le (maxl l) e
+++++
apply Nat.max_lub_r with a; trivial.
-----
Lemma maxl_le l e : maxl l <= e -> (forall x, In x l -> x <= e).
Proof.
induction l; simpl;[ tauto | intros].
destruct H0; subst.
apply Nat.max_lub_l with (maxl l); trivial.
apply IHl; trivial.
apply Nat.max_lub_r with a; trivial.

*****

*****

+++++
Qed.
-----
Lemma maxl_eq_le l e :\n  maxl l = e ->\n  (forall x, In x l -> x <= e).
-----
Lemma maxl_eq_le l e : maxl l = e -> (forall x, In x l -> x <= e).

*****
e : nat
l : list nat
*****
forall (_ : eq (maxl l) e) (x : nat) (_ : In x l), le x e
+++++
Proof.
-----
Lemma maxl_eq_le l e : maxl l = e -> (forall x, In x l -> x <= e).
Proof.

*****
e : nat
l : list nat
*****
forall (_ : eq (maxl l) e) (x : nat) (_ : In x l), le x e
+++++
intros.
-----
Lemma maxl_eq_le l e : maxl l = e -> (forall x, In x l -> x <= e).
Proof.
intros.

*****
H0 : In x l
x : nat
H : eq (maxl l) e
e : nat
l : list nat
*****
le x e
+++++
apply maxl_le with l.
-----
Lemma maxl_eq_le l e : maxl l = e -> (forall x, In x l -> x <= e).
Proof.
intros.
apply maxl_le with l.

*****
H0 : In x l
x : nat
H : eq (maxl l) e
e : nat
l : list nat
*****
le (maxl l) e
+++++
auto.
-----
Lemma maxl_eq_le l e : maxl l = e -> (forall x, In x l -> x <= e).
Proof.
intros.
apply maxl_le with l.
auto.

*****
H0 : In x l
x : nat
H : eq (maxl l) e
e : nat
l : list nat
*****
le (maxl l) e
+++++
rewrite H.
-----
Lemma maxl_eq_le l e : maxl l = e -> (forall x, In x l -> x <= e).
Proof.
intros.
apply maxl_le with l.
auto.
rewrite H.

*****
H0 : In x l
x : nat
H : eq (maxl l) e
e : nat
l : list nat
*****
le e e
+++++
auto.
-----
Lemma maxl_eq_le l e : maxl l = e -> (forall x, In x l -> x <= e).
Proof.
intros.
apply maxl_le with l.

*****
H0 : In x l
x : nat
H : eq (maxl l) e
e : nat
l : list nat
*****
In x l
+++++
auto.
-----
Lemma maxl_eq_le l e : maxl l = e -> (forall x, In x l -> x <= e).
Proof.
intros.
apply maxl_le with l.

*****

*****

+++++
Qed.
-----
Lemma maxl_eq_le3 e1 e2 e3 e :\n  maxl [e1; e2; e3] = e ->\n  e1 <= e /\ e2 <= e /\ e3 <= e.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.

*****
e1,e2,e3,e : nat
*****
forall _ : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e, and (le e1 e) (and (le e2 e) (le e3 e))
+++++
Proof.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.

*****
e1,e2,e3,e : nat
*****
forall _ : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e, and (le e1 e) (and (le e2 e) (le e3 e))
+++++
intros.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.

*****
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
and (le e1 e) (and (le e2 e) (le e3 e))
+++++
assert (Hl := maxl_eq_le _ _ H).
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
and (le e1 e) (and (le e2 e) (le e3 e))
+++++
repeat split.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
le e1 e
+++++
apply Hl.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.
apply Hl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
In e1 (cons e1 (cons e2 (cons e3 nil)))
+++++
simpl.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.
apply Hl.
simpl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
or (eq e1 e1) (or (eq e2 e1) (or (eq e3 e1) False))
+++++
auto.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
le e2 e
+++++
apply Hl.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.
apply Hl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
In e2 (cons e1 (cons e2 (cons e3 nil)))
+++++
simpl.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.
apply Hl.
simpl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
or (eq e1 e2) (or (eq e2 e2) (or (eq e3 e2) False))
+++++
auto.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
le e3 e
+++++
apply Hl.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.
apply Hl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
In e3 (cons e1 (cons e2 (cons e3 nil)))
+++++
simpl.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.
apply Hl.
simpl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : eq (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
or (eq e1 e3) (or (eq e2 e3) (or (eq e3 e3) False))
+++++
auto.
-----
Lemma maxl_eq_le3 e1 e2 e3 e : maxl [e1; e2; e3] = e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_eq_le _ _ H).
repeat split.

*****

*****

+++++
Qed.
-----
Lemma maxl_le3 e1 e2 e3 e :\n  maxl [e1; e2; e3] <= e ->\n  e1 <= e /\ e2 <= e /\ e3 <= e.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.

*****
e1,e2,e3,e : nat
*****
forall _ : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e, and (le e1 e) (and (le e2 e) (le e3 e))
+++++
Proof.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.

*****
e1,e2,e3,e : nat
*****
forall _ : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e, and (le e1 e) (and (le e2 e) (le e3 e))
+++++
intros.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.

*****
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
and (le e1 e) (and (le e2 e) (le e3 e))
+++++
assert (Hl := maxl_le _ _ H).
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
and (le e1 e) (and (le e2 e) (le e3 e))
+++++
repeat split.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
le e1 e
+++++
apply Hl.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.
apply Hl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
In e1 (cons e1 (cons e2 (cons e3 nil)))
+++++
simpl.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.
apply Hl.
simpl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
or (eq e1 e1) (or (eq e2 e1) (or (eq e3 e1) False))
+++++
auto.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
le e2 e
+++++
apply Hl.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.
apply Hl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
In e2 (cons e1 (cons e2 (cons e3 nil)))
+++++
simpl.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.
apply Hl.
simpl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
or (eq e1 e2) (or (eq e2 e2) (or (eq e3 e2) False))
+++++
auto.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
le e3 e
+++++
apply Hl.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.
apply Hl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
In e3 (cons e1 (cons e2 (cons e3 nil)))
+++++
simpl.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.
apply Hl.
simpl.

*****
Hl : forall (x : nat) (_ : In x (cons e1 (cons e2 (cons e3 nil)))), le x e
H : le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
e1,e2,e3,e : nat
*****
or (eq e1 e3) (or (eq e2 e3) (or (eq e3 e3) False))
+++++
auto.
-----
Lemma maxl_le3 e1 e2 e3 e : maxl [e1; e2; e3] <= e -> e1 <= e /\\ e2 <= e /\\ e3 <= e.
Proof.
intros.
assert (Hl := maxl_le _ _ H).
repeat split.

*****

*****

+++++
Qed.
-----
Lemma maxl_bound e1 e2 e3 e :\n  e1 <= e -> e2 <= e -> e3 <= e ->\n  maxl [e1; e2; e3] <= e.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.

*****
e1,e2,e3,e : nat
*****
forall (_ : le e1 e) (_ : le e2 e) (_ : le e3 e), le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
+++++
Proof.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.

*****
e1,e2,e3,e : nat
*****
forall (_ : le e1 e) (_ : le e2 e) (_ : le e3 e), le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
+++++
intros.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le (maxl (cons e1 (cons e2 (cons e3 nil)))) e
+++++
simpl.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le (Init.Nat.max e1 (Init.Nat.max e2 (Init.Nat.max e3 O))) e
+++++
apply Nat.max_lub.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le e1 e
+++++
trivial.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le (Init.Nat.max e2 (Init.Nat.max e3 O)) e
+++++
trivial.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.
trivial.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le (Init.Nat.max e2 (Init.Nat.max e3 O)) e
+++++
apply Nat.max_lub.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le e2 e
+++++
trivial.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le (Init.Nat.max e3 O) e
+++++
trivial.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.
trivial.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le (Init.Nat.max e3 O) e
+++++
apply Nat.max_lub.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le e3 e
+++++
trivial.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le O e
+++++
trivial.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.
trivial.
apply Nat.max_lub.
trivial.

*****
H1 : le e3 e
H0 : le e2 e
H : le e1 e
e1,e2,e3,e : nat
*****
le O e
+++++
omega.
-----
Lemma maxl_bound e1 e2 e3 e : e1 <= e -> e2 <= e -> e3 <= e -> maxl [e1; e2; e3] <= e.
Proof.
intros.
simpl.
apply Nat.max_lub.

*****

*****

+++++
Qed.
-----
Lemma maxl_bound_in l e :\n  (forall e', In e' l -> e' <= e) -> maxl l <= e.
-----
Lemma maxl_bound_in l e : (forall e', In e' l -> e' <= e) -> maxl l <= e.

*****
e : nat
l : list nat
*****
forall _ : forall (e' : nat) (_ : In e' l), le e' e, le (maxl l) e
+++++
Proof.
-----
Lemma maxl_bound_in l e : (forall e', In e' l -> e' <= e) -> maxl l <= e.
Proof.

*****
e : nat
l : list nat
*****
forall _ : forall (e' : nat) (_ : In e' l), le e' e, le (maxl l) e
+++++
induction l; simpl; intros;[ omega | ].
-----
Lemma maxl_bound_in l e : (forall e', In e' l -> e' <= e) -> maxl l <= e.
Proof.
induction l; simpl; intros;[ omega | ].

*****
H : forall (e' : nat) (_ : or (eq a e') (In e' l)), le e' e
IHl : forall _ : forall (e' : nat) (_ : In e' l), le e' e, le (maxl l) e
e : nat
l : list nat
a : nat
*****
le (Init.Nat.max a (maxl l)) e
+++++
apply Nat.max_lub.
-----
Lemma maxl_bound_in l e : (forall e', In e' l -> e' <= e) -> maxl l <= e.
Proof.
induction l; simpl; intros;[ omega | ].
apply Nat.max_lub.

*****
H : forall (e' : nat) (_ : or (eq a e') (In e' l)), le e' e
IHl : forall _ : forall (e' : nat) (_ : In e' l), le e' e, le (maxl l) e
e : nat
l : list nat
a : nat
*****
le a e
+++++
apply H; auto.
-----
Lemma maxl_bound_in l e : (forall e', In e' l -> e' <= e) -> maxl l <= e.
Proof.
induction l; simpl; intros;[ omega | ].
apply Nat.max_lub.
apply H; auto.

*****
H : forall (e' : nat) (_ : or (eq a e') (In e' l)), le e' e
IHl : forall _ : forall (e' : nat) (_ : In e' l), le e' e, le (maxl l) e
e : nat
l : list nat
a : nat
*****
le (maxl l) e
+++++
apply IHl.
-----
Lemma maxl_bound_in l e : (forall e', In e' l -> e' <= e) -> maxl l <= e.
Proof.
induction l; simpl; intros;[ omega | ].
apply Nat.max_lub.
apply H; auto.
apply IHl.

*****
H : forall (e' : nat) (_ : or (eq a e') (In e' l)), le e' e
IHl : forall _ : forall (e' : nat) (_ : In e' l), le e' e, le (maxl l) e
e : nat
l : list nat
a : nat
*****
forall (e' : nat) (_ : In e' l), le e' e
+++++
intros; apply H; auto.
-----
Lemma maxl_bound_in l e : (forall e', In e' l -> e' <= e) -> maxl l <= e.
Proof.
induction l; simpl; intros;[ omega | ].
apply Nat.max_lub.
apply H; auto.
apply IHl.
intros; apply H; auto.

*****

*****

+++++
Qed.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
-----
Lemma maxl_cons l n : n <= maxl (n :: l).

*****
n : nat
l : list nat
*****
le n (maxl (cons n l))
+++++
Proof.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
Proof.

*****
n : nat
l : list nat
*****
le n (maxl (cons n l))
+++++
destruct l.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
Proof.
destruct l.

*****
n : nat
*****
le n (maxl (cons n nil))
+++++
simpl.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
Proof.
destruct l.
simpl.

*****
n : nat
*****
le n (Init.Nat.max n O)
+++++
intros.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
Proof.
destruct l.
simpl.
intros.

*****
n : nat
*****
le n (Init.Nat.max n O)
+++++
auto with arith.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
Proof.
destruct l.

*****
n : nat
l : list nat
n0 : nat
*****
le n (maxl (cons n (cons n0 l)))
+++++
simpl.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
Proof.
destruct l.
simpl.

*****
n : nat
l : list nat
n0 : nat
*****
le n (Init.Nat.max n (Init.Nat.max n0 (maxl l)))
+++++
intros.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
Proof.
destruct l.
simpl.
intros.

*****
n : nat
l : list nat
n0 : nat
*****
le n (Init.Nat.max n (Init.Nat.max n0 (maxl l)))
+++++
apply Nat.le_max_l.
-----
Lemma maxl_cons l n : n <= maxl (n :: l).
Proof.
destruct l.

*****

*****

+++++
Qed.
-----
Lemma le_maxl_cons l m n :\n n <= maxl l -> n <= maxl (m :: l).
-----
Lemma le_maxl_cons l m n : n <= maxl l -> n <= maxl (m :: l).

*****
m,n : nat
l : list nat
*****
forall _ : le n (maxl l), le n (maxl (cons m l))
+++++
Proof.
-----
Lemma le_maxl_cons l m n : n <= maxl l -> n <= maxl (m :: l).
Proof.

*****
m,n : nat
l : list nat
*****
forall _ : le n (maxl l), le n (maxl (cons m l))
+++++
induction l; simpl; intros;[ omega | ].
-----
Lemma le_maxl_cons l m n : n <= maxl l -> n <= maxl (m :: l).
Proof.
induction l; simpl; intros;[ omega | ].

*****
H : le n (Init.Nat.max a (maxl l))
IHl : forall _ : le n (maxl l), le n (maxl (cons m l))
m,n : nat
l : list nat
a : nat
*****
le n (Init.Nat.max m (Init.Nat.max a (maxl l)))
+++++
eapply le_trans.
-----
Lemma le_maxl_cons l m n : n <= maxl l -> n <= maxl (m :: l).
Proof.
induction l; simpl; intros;[ omega | ].
eapply le_trans.

*****
H : le n (Init.Nat.max a (maxl l))
IHl : forall _ : le n (maxl l), le n (maxl (cons m l))
m,n : nat
l : list nat
a : nat
*****
le n ?m
+++++
apply Nat.le_max_r.
-----
Lemma le_maxl_cons l m n : n <= maxl l -> n <= maxl (m :: l).
Proof.
induction l; simpl; intros;[ omega | ].
eapply le_trans.
apply Nat.le_max_r.

*****
H : le n (Init.Nat.max a (maxl l))
IHl : forall _ : le n (maxl l), le n (maxl (cons m l))
m,n : nat
l : list nat
a : nat
*****
le (Nat.max ?n n) (Init.Nat.max m (Init.Nat.max a (maxl l)))
+++++
apply Nat.max_le_compat_l; trivial.
-----
Lemma le_maxl_cons l m n : n <= maxl l -> n <= maxl (m :: l).
Proof.
induction l; simpl; intros;[ omega | ].
eapply le_trans.
apply Nat.le_max_r.
apply Nat.max_le_compat_l; trivial.

*****

*****

+++++
Qed.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i,\n  m d = 0 -> m (nth i l d) <= maxl (map m l).
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).

*****

*****
forall (A : Type) (l : list A) (m : forall _ : A, nat) (d : A) (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
+++++
Proof.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.

*****

*****
forall (A : Type) (l : list A) (m : forall _ : A, nat) (d : A) (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
+++++
intros A l m d.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.

*****
d : A
m : forall _ : A, nat
l : list A
A : Type
*****
forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
+++++
induction l as [ | a l IH].
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].

*****
d : A
m : forall _ : A, nat
A : Type
*****
forall (i : nat) (_ : eq (m d) O), le (m (nth i nil d)) (maxl (map m nil))
+++++
intros [ | i] H.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.

*****
H : eq (m d) O
d : A
m : forall _ : A, nat
A : Type
*****
le (m (nth O nil d)) (maxl (map m nil))
+++++
simpl.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.
simpl.

*****
H : eq (m d) O
d : A
m : forall _ : A, nat
A : Type
*****
le (m d) O
+++++
omega.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.

*****
H : eq (m d) O
i : nat
d : A
m : forall _ : A, nat
A : Type
*****
le (m (nth (S i) nil d)) (maxl (map m nil))
+++++
simpl.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.
simpl.

*****
H : eq (m d) O
i : nat
d : A
m : forall _ : A, nat
A : Type
*****
le (m d) O
+++++
omega.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].

*****
IH : forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
d : A
m : forall _ : A, nat
l : list A
a : A
A : Type
*****
forall (i : nat) (_ : eq (m d) O), le (m (nth i (cons a l) d)) (maxl (map m (cons a l)))
+++++
intros [ | i] H.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.

*****
H : eq (m d) O
IH : forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
d : A
m : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (m (nth O (cons a l) d)) (maxl (map m (cons a l)))
+++++
simpl.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.
simpl.

*****
H : eq (m d) O
IH : forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
d : A
m : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (m a) (Init.Nat.max (m a) (maxl (map m l)))
+++++
auto with arith.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.

*****
H : eq (m d) O
i : nat
IH : forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
d : A
m : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (m (nth (S i) (cons a l) d)) (maxl (map m (cons a l)))
+++++
simpl.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.
simpl.

*****
H : eq (m d) O
i : nat
IH : forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
d : A
m : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (m (nth i l d)) (Init.Nat.max (m a) (maxl (map m l)))
+++++
eapply le_trans.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.
simpl.
eapply le_trans.

*****
H : eq (m d) O
i : nat
IH : forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
d : A
m : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (m (nth i l d)) ?m
+++++
apply IH.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.
simpl.
eapply le_trans.
apply IH.

*****
H : eq (m d) O
i : nat
IH : forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
d : A
m : forall _ : A, nat
l : list A
a : A
A : Type
*****
eq (m d) O
+++++
exact H.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].
intros [ | i] H.
simpl.
eapply le_trans.

*****
H : eq (m d) O
i : nat
IH : forall (i : nat) (_ : eq (m d) O), le (m (nth i l d)) (maxl (map m l))
d : A
m : forall _ : A, nat
l : list A
a : A
A : Type
*****
le (maxl (map m l)) (Init.Nat.max (m a) (maxl (map m l)))
+++++
apply Nat.le_max_r.
-----
Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i, m d = 0 -> m (nth i l d) <= maxl (map m l).
Proof.
intros A l m d.
induction l as [ | a l IH].

*****

*****

+++++
Qed.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) :\n  length (hd nil l1) <= length (hd nil (l1 ++ l2)).
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).

*****
l1,l2 : list (list A)
A : Type
*****
le (length (hd nil l1)) (length (hd nil (app l1 l2)))
+++++
Proof.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).
Proof.

*****
l1,l2 : list (list A)
A : Type
*****
le (length (hd nil l1)) (length (hd nil (app l1 l2)))
+++++
intros.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).
Proof.
intros.

*****
l1,l2 : list (list A)
A : Type
*****
le (length (hd nil l1)) (length (hd nil (app l1 l2)))
+++++
case l1.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).
Proof.
intros.
case l1.

*****
l1,l2 : list (list A)
A : Type
*****
le (length (hd nil nil)) (length (hd nil (app nil l2)))
+++++
simpl.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).
Proof.
intros.
case l1.
simpl.

*****
l1,l2 : list (list A)
A : Type
*****
le O (length (hd nil l2))
+++++
trivial.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).
Proof.
intros.
case l1.
simpl.
trivial.

*****
l1,l2 : list (list A)
A : Type
*****
le O (length (hd nil l2))
+++++
omega.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).
Proof.
intros.
case l1.

*****
l1,l2 : list (list A)
A : Type
*****
forall (l : list A) (l0 : list (list A)), le (length (hd nil (cons l l0))) (length (hd nil (app (cons l l0) l2)))
+++++
simpl.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).
Proof.
intros.
case l1.
simpl.

*****
l1,l2 : list (list A)
A : Type
*****
forall (l : list A) (_ : list (list A)), le (length l) (length l)
+++++
trivial.
-----
Lemma length_hd_app A (l1 l2 : list (list A)) : length (hd nil l1) <= length (hd nil (l1 ++ l2)).
Proof.
intros.
case l1.

*****

*****

+++++
Qed.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i :\n  length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).

*****
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length (nth i l1 nil)) (length (nth i (app l1 l2) nil))
+++++
Proof.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.

*****
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length (nth i l1 nil)) (length (nth i (app l1 l2) nil))
+++++
intros.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.

*****
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length (nth i l1 nil)) (length (nth i (app l1 l2) nil))
+++++
destruct (le_lt_dec (length l1) i).
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).

*****
l : le (length l1) i
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length (nth i l1 nil)) (length (nth i (app l1 l2) nil))
+++++
rewrite nth_overflow.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).
rewrite nth_overflow.

*****
l : le (length l1) i
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length nil) (length (nth i (app l1 l2) nil))
+++++
simpl.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).
rewrite nth_overflow.
simpl.

*****
l : le (length l1) i
i : nat
l1,l2 : list (list A)
A : Type
*****
le O (length (nth i (app l1 l2) nil))
+++++
trivial.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).
rewrite nth_overflow.
simpl.
trivial.

*****
l : le (length l1) i
i : nat
l1,l2 : list (list A)
A : Type
*****
le O (length (nth i (app l1 l2) nil))
+++++
omega.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).
rewrite nth_overflow.

*****
l : le (length l1) i
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length l1) i
+++++
simpl.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).
rewrite nth_overflow.
simpl.

*****
l : le (length l1) i
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length l1) i
+++++
trivial.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).

*****
l : lt i (length l1)
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length (nth i l1 nil)) (length (nth i (app l1 l2) nil))
+++++
rewrite app_nth1.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).
rewrite app_nth1.

*****
l : lt i (length l1)
i : nat
l1,l2 : list (list A)
A : Type
*****
le (length (nth i l1 nil)) (length (nth i l1 nil))
+++++
trivial.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).
rewrite app_nth1.

*****
l : lt i (length l1)
i : nat
l1,l2 : list (list A)
A : Type
*****
lt i (length l1)
+++++
trivial.
-----
Lemma length_nth_app A (l1 l2 : list (list A)) i : length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).
Proof.
intros.
destruct (le_lt_dec (length l1) i).

*****

*****

+++++
Qed.
-----
Lemma maxl_nth l :\n  exists i, maxl l = nth i l 0.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.

*****
l : list nat
*****
ex (fun i : nat => eq (maxl l) (nth i l O))
+++++
Proof.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.

*****
l : list nat
*****
ex (fun i : nat => eq (maxl l) (nth i l O))
+++++
induction l.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.

*****

*****
ex (fun i : nat => eq (maxl nil) (nth i nil O))
+++++
simpl.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.

*****

*****
ex (fun i : nat => eq O match i with | O | _ => O end)
+++++
exists 0.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
exists 0.

*****

*****
eq O O
+++++
trivial.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.

*****
IHl : ex (fun i : nat => eq (maxl l) (nth i l O))
l : list nat
a : nat
*****
ex (fun i : nat => eq (maxl (cons a l)) (nth i (cons a l) O))
+++++
simpl.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.

*****
IHl : ex (fun i : nat => eq (maxl l) (nth i l O))
l : list nat
a : nat
*****
ex (fun i : nat => eq (Init.Nat.max a (maxl l)) match i with | O => a | S m => nth m l O end)
+++++
destruct IHl.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.

*****
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
ex (fun i : nat => eq (Init.Nat.max a (maxl l)) match i with | O => a | S m => nth m l O end)
+++++
destruct (le_lt_dec a (maxl l)).
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).

*****
l0 : le a (maxl l)
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
ex (fun i : nat => eq (Init.Nat.max a (maxl l)) match i with | O => a | S m => nth m l O end)
+++++
rewrite max_r.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).
rewrite max_r.

*****
l0 : le a (maxl l)
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
ex (fun i : nat => eq (maxl l) match i with | O => a | S m => nth m l O end)
+++++
trivial.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).
rewrite max_r.
trivial.

*****
l0 : le a (maxl l)
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
ex (fun i : nat => eq (maxl l) match i with | O => a | S m => nth m l O end)
+++++
exists (S x).
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).
rewrite max_r.
trivial.
exists (S x).

*****
l0 : le a (maxl l)
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
eq (maxl l) (nth x l O)
+++++
trivial.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).
rewrite max_r.

*****
l0 : le a (maxl l)
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
le a (maxl l)
+++++
trivial.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).

*****
l0 : lt (maxl l) a
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
ex (fun i : nat => eq (Init.Nat.max a (maxl l)) match i with | O => a | S m => nth m l O end)
+++++
exists 0.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).
exists 0.

*****
l0 : lt (maxl l) a
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
eq (Init.Nat.max a (maxl l)) a
+++++
rewrite max_l.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).
exists 0.
rewrite max_l.

*****
l0 : lt (maxl l) a
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
eq a a
+++++
trivial.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).
exists 0.
rewrite max_l.

*****
l0 : lt (maxl l) a
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
le (maxl l) a
+++++
trivial.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.
simpl.
destruct IHl.
destruct (le_lt_dec a (maxl l)).
exists 0.
rewrite max_l.
trivial.

*****
l0 : lt (maxl l) a
H : eq (maxl l) (nth x l O)
x : nat
l : list nat
a : nat
*****
le (maxl l) a
+++++
omega.
-----
Lemma maxl_nth l : exists i, maxl l = nth i l 0.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma maxl_map_0 A l (f : A -> nat)  :\n  (forall x, In x l -> (f x) = 0) ->\n  maxl (map f l) = 0.
-----
Lemma maxl_map_0 A l (f : A -> nat) : (forall x, In x l -> (f x) = 0) -> maxl (map f l) = 0.

*****
f : forall _ : A, nat
l : list A
A : Type
*****
forall _ : forall (x : A) (_ : In x l), eq (f x) O, eq (maxl (map f l)) O
+++++
Proof.
-----
Lemma maxl_map_0 A l (f : A -> nat) : (forall x, In x l -> (f x) = 0) -> maxl (map f l) = 0.
Proof.

*****
f : forall _ : A, nat
l : list A
A : Type
*****
forall _ : forall (x : A) (_ : In x l), eq (f x) O, eq (maxl (map f l)) O
+++++
induction l; simpl; intros; trivial.
-----
Lemma maxl_map_0 A l (f : A -> nat) : (forall x, In x l -> (f x) = 0) -> maxl (map f l) = 0.
Proof.
induction l; simpl; intros; trivial.

*****
H : forall (x : A) (_ : or (eq a x) (In x l)), eq (f x) O
IHl : forall _ : forall (x : A) (_ : In x l), eq (f x) O,\neq (maxl (map f l)) O
f : forall _ : A, nat
l : list A
a : A
A : Type
*****
eq (Init.Nat.max (f a) (maxl (map f l))) O
+++++
rewrite H, IHl; simpl; trivial; intros; auto.
-----
Lemma maxl_map_0 A l (f : A -> nat) : (forall x, In x l -> (f x) = 0) -> maxl (map f l) = 0.
Proof.
induction l; simpl; intros; trivial.
rewrite H, IHl; simpl; trivial; intros; auto.

*****

*****

+++++
Qed.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.

*****

*****
forall l : list nat, le (maxl l) (plusl l)
+++++
Proof.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
Proof.

*****

*****
forall l : list nat, le (maxl l) (plusl l)
+++++
induction l.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
Proof.
induction l.

*****

*****
le (maxl nil) (plusl nil)
+++++
trivial.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
Proof.
induction l.

*****
IHl : le (maxl l) (plusl l)
l : list nat
a : nat
*****
le (maxl (cons a l)) (plusl (cons a l))
+++++
trivial.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
Proof.
induction l.
trivial.

*****
IHl : le (maxl l) (plusl l)
l : list nat
a : nat
*****
le (maxl (cons a l)) (plusl (cons a l))
+++++
simpl.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
Proof.
induction l.
trivial.
simpl.

*****
IHl : le (maxl l) (plusl l)
l : list nat
a : nat
*****
le (Init.Nat.max a (maxl l)) (Init.Nat.add a (plusl l))
+++++
apply Nat.max_lub.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
Proof.
induction l.
trivial.
simpl.
apply Nat.max_lub.

*****
IHl : le (maxl l) (plusl l)
l : list nat
a : nat
*****
le a (Init.Nat.add a (plusl l))
+++++
omega.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
Proof.
induction l.
trivial.
simpl.
apply Nat.max_lub.

*****
IHl : le (maxl l) (plusl l)
l : list nat
a : nat
*****
le (maxl l) (Init.Nat.add a (plusl l))
+++++
omega.
-----
Lemma maxl_le_plusl : forall l, maxl l <= plusl l.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma forallb_forall_conv :\n  forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\ f x = false).
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).

*****

*****
forall (A : Type) (f : forall _ : A, bool) (l : list A), iff (eq (forallb f l) false) (ex (fun x : A => and (In x l) (eq (f x) false)))
+++++
Proof.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.

*****

*****
forall (A : Type) (f : forall _ : A, bool) (l : list A), iff (eq (forallb f l) false) (ex (fun x : A => and (In x l) (eq (f x) false)))
+++++
induction l as [ | x l IH].
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].

*****
f : forall _ : A, bool
A : Type
*****
iff (eq (forallb f nil) false) (ex (fun x : A => and (In x nil) (eq (f x) false)))
+++++
simpl.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.

*****
f : forall _ : A, bool
A : Type
*****
iff (eq true false) (ex (fun x : A => and False (eq (f x) false)))
+++++
split.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.

*****
f : forall _ : A, bool
A : Type
*****
forall _ : eq true false, ex (fun x : A => and False (eq (f x) false))
+++++
congruence.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.

*****
f : forall _ : A, bool
A : Type
*****
forall _ : ex (fun x : A => and False (eq (f x) false)), eq true false
+++++
intros [x H].
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [x H].

*****
H : and False (eq (f x) false)
x : A
f : forall _ : A, bool
A : Type
*****
eq true false
+++++
tauto.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].

*****
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
iff (eq (forallb f (cons x l)) false) (ex (fun x0 : A => and (In x0 (cons x l)) (eq (f x0) false)))
+++++
simpl.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.

*****
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
iff (eq (andb (f x) (forallb f l)) false) (ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false)))
+++++
split.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.

*****
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
forall _ : eq (andb (f x) (forallb f l)) false, ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false))
+++++
intro H.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intro H.

*****
H : eq (andb (f x) (forallb f l)) false
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false))
+++++
apply andb_false_elim in H.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intro H.
apply andb_false_elim in H.

*****
H : sumbool (eq (f x) false) (eq (forallb f l) false)
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false))
+++++
destruct H as [H | H].
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intro H.
apply andb_false_elim in H.
destruct H as [H | H].

*****
H : eq (f x) false
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false))
+++++
exists x.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intro H.
apply andb_false_elim in H.
destruct H as [H | H].
exists x.

*****
H : eq (f x) false
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
and (or (eq x x) (In x l)) (eq (f x) false)
+++++
tauto.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intro H.
apply andb_false_elim in H.
destruct H as [H | H].

*****
H : eq (forallb f l) false
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false))
+++++
rewrite IH in H.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intro H.
apply andb_false_elim in H.
destruct H as [H | H].
rewrite IH in H.

*****
H : ex (fun x : A => and (In x l) (eq (f x) false))
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false))
+++++
destruct H as [y H].
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intro H.
apply andb_false_elim in H.
destruct H as [H | H].
rewrite IH in H.
destruct H as [y H].

*****
H : and (In y l) (eq (f y) false)
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false))
+++++
exists y.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intro H.
apply andb_false_elim in H.
destruct H as [H | H].
rewrite IH in H.
destruct H as [y H].
exists y.

*****
H : and (In y l) (eq (f y) false)
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
and (or (eq x y) (In y l)) (eq (f y) false)
+++++
tauto.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.

*****
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
forall _ : ex (fun x0 : A => and (or (eq x x0) (In x0 l)) (eq (f x0) false)), eq (andb (f x) (forallb f l)) false
+++++
intros [y H].
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].

*****
H : and (or (eq x y) (In y l)) (eq (f y) false)
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
eq (andb (f x) (forallb f l)) false
+++++
apply andb_false_iff.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.

*****
H : and (or (eq x y) (In y l)) (eq (f y) false)
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
or (eq (f x) false) (eq (forallb f l) false)
+++++
destruct H as [ [H1 | H1] H2].
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.
destruct H as [ [H1 | H1] H2].

*****
H2 : eq (f y) false
H1 : eq x y
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
or (eq (f x) false) (eq (forallb f l) false)
+++++
subst.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.
destruct H as [ [H1 | H1] H2].
subst.

*****
H2 : eq (f y) false
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
f : forall _ : A, bool
A : Type
*****
or (eq (f y) false) (eq (forallb f l) false)
+++++
auto.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.
destruct H as [ [H1 | H1] H2].

*****
H2 : eq (f y) false
H1 : In y l
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
or (eq (f x) false) (eq (forallb f l) false)
+++++
subst.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.
destruct H as [ [H1 | H1] H2].
subst.

*****
H2 : eq (f y) false
H1 : In y l
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
or (eq (f x) false) (eq (forallb f l) false)
+++++
auto.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.
destruct H as [ [H1 | H1] H2].
subst.
auto.

*****
H2 : eq (f y) false
H1 : In y l
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
or (eq (f x) false) (eq (forallb f l) false)
+++++
right.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.
destruct H as [ [H1 | H1] H2].
subst.
auto.
right.

*****
H2 : eq (f y) false
H1 : In y l
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
eq (forallb f l) false
+++++
rewrite IH.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.
destruct H as [ [H1 | H1] H2].
subst.
auto.
right.
rewrite IH.

*****
H2 : eq (f y) false
H1 : In y l
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
ex (fun x : A => and (In x l) (eq (f x) false))
+++++
exists y.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].
simpl.
split.
intros [y H].
apply andb_false_iff.
destruct H as [ [H1 | H1] H2].
subst.
auto.
right.
rewrite IH.
exists y.

*****
H2 : eq (f y) false
H1 : In y l
y : A
IH : iff (eq (forallb f l) false)\n (ex (fun x : A => and (In x l) (eq (f x) false)))
l : list A
x : A
f : forall _ : A, bool
A : Type
*****
and (In y l) (eq (f y) false)
+++++
tauto.
-----
Lemma forallb_forall_conv : forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\\ f x = false).
Proof.
induction l as [ | x l IH].

*****

*****

+++++
Qed.
-----
Lemma forallb_nth : forall A (l : list A) (p : A -> bool) n d,\n  p d = true ->\n  forallb p l = true ->\n  p (nth n l d) = true.
-----
Lemma forallb_nth : forall A (l : list A) (p : A -> bool) n d, p d = true -> forallb p l = true -> p (nth n l d) = true.

*****

*****
forall (A : Type) (l : list A) (p : forall _ : A, bool) (n : nat) (d : A) (_ : eq (p d) true) (_ : eq (forallb p l) true), eq (p (nth n l d)) true
+++++
Proof.
-----
Lemma forallb_nth : forall A (l : list A) (p : A -> bool) n d, p d = true -> forallb p l = true -> p (nth n l d) = true.
Proof.

*****

*****
forall (A : Type) (l : list A) (p : forall _ : A, bool) (n : nat) (d : A) (_ : eq (p d) true) (_ : eq (forallb p l) true), eq (p (nth n l d)) true
+++++
induction l; simpl; intros; case n; trivial; intros; rewrite andb_true_iff in H0; [ | apply IHl ]; tauto.
-----
Lemma forallb_nth : forall A (l : list A) (p : A -> bool) n d, p d = true -> forallb p l = true -> p (nth n l d) = true.
Proof.
induction l; simpl; intros; case n; trivial; intros; rewrite andb_true_iff in H0; [ | apply IHl ]; tauto.

*****

*****

+++++
Qed.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d,\n  forallb p l = true ->\n  p d = true ->\n  p (hd d l) = true.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.

*****

*****
forall (A : Type) (l : list A) (p : forall _ : A, bool) (d : A) (_ : eq (forallb p l) true) (_ : eq (p d) true), eq (p (hd d l)) true
+++++
Proof.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.

*****

*****
forall (A : Type) (l : list A) (p : forall _ : A, bool) (d : A) (_ : eq (forallb p l) true) (_ : eq (p d) true), eq (p (hd d l)) true
+++++
destruct l.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.

*****
A : Type
*****
forall (p : forall _ : A, bool) (d : A) (_ : eq (forallb p nil) true) (_ : eq (p d) true), eq (p (hd d nil)) true
+++++
simpl.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.
simpl.

*****
A : Type
*****
forall (p : forall _ : A, bool) (d : A) (_ : eq true true) (_ : eq (p d) true), eq (p d) true
+++++
intros.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.
simpl.
intros.

*****
H0 : eq (p d) true
H : eq true true
d : A
p : forall _ : A, bool
A : Type
*****
eq (p d) true
+++++
trivial.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.

*****
l : list A
a : A
A : Type
*****
forall (p : forall _ : A, bool) (d : A) (_ : eq (forallb p (cons a l)) true) (_ : eq (p d) true), eq (p (hd d (cons a l))) true
+++++
simpl.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.
simpl.

*****
l : list A
a : A
A : Type
*****
forall (p : forall _ : A, bool) (d : A) (_ : eq (andb (p a) (forallb p l)) true) (_ : eq (p d) true), eq (p a) true
+++++
intros.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.
simpl.
intros.

*****
H0 : eq (p d) true
H : eq (andb (p a) (forallb p l)) true
d : A
p : forall _ : A, bool
l : list A
a : A
A : Type
*****
eq (p a) true
+++++
trivial.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.
simpl.
intros.
trivial.

*****
H0 : eq (p d) true
H : eq (andb (p a) (forallb p l)) true
d : A
p : forall _ : A, bool
l : list A
a : A
A : Type
*****
eq (p a) true
+++++
rewrite andb_true_iff in H.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.
simpl.
intros.
trivial.
rewrite andb_true_iff in H.

*****
H0 : eq (p d) true
H : and (eq (p a) true) (eq (forallb p l) true)
d : A
p : forall _ : A, bool
l : list A
a : A
A : Type
*****
eq (p a) true
+++++
tauto.
-----
Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d, forallb p l = true -> p d = true -> p (hd d l) = true.
Proof.
destruct l.

*****

*****

+++++
Qed.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool),\n  forallb p l = true ->\n  forallb p (tail l) = true.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.

*****

*****
forall (A : Type) (l : list A) (p : forall _ : A, bool) (_ : eq (forallb p l) true), eq (forallb p (tl l)) true
+++++
Proof.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.

*****

*****
forall (A : Type) (l : list A) (p : forall _ : A, bool) (_ : eq (forallb p l) true), eq (forallb p (tl l)) true
+++++
induction l.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.

*****
A : Type
*****
forall (p : forall _ : A, bool) (_ : eq (forallb p nil) true), eq (forallb p (tl nil)) true
+++++
simpl.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.
simpl.

*****
A : Type
*****
forall (_ : forall _ : A, bool) (_ : eq true true), eq true true
+++++
intros.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.
simpl.
intros.

*****
H : eq true true
p : forall _ : A, bool
A : Type
*****
eq true true
+++++
trivial.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.

*****
IHl : forall (p : forall _ : A, bool) (_ : eq (forallb p l) true),\neq (forallb p (tl l)) true
l : list A
a : A
A : Type
*****
forall (p : forall _ : A, bool) (_ : eq (forallb p (cons a l)) true), eq (forallb p (tl (cons a l))) true
+++++
simpl.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.
simpl.

*****
IHl : forall (p : forall _ : A, bool) (_ : eq (forallb p l) true),\neq (forallb p (tl l)) true
l : list A
a : A
A : Type
*****
forall (p : forall _ : A, bool) (_ : eq (andb (p a) (forallb p l)) true), eq (forallb p l) true
+++++
intros.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.
simpl.
intros.

*****
H : eq (andb (p a) (forallb p l)) true
p : forall _ : A, bool
IHl : forall (p : forall _ : A, bool) (_ : eq (forallb p l) true),\neq (forallb p (tl l)) true
l : list A
a : A
A : Type
*****
eq (forallb p l) true
+++++
trivial.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.
simpl.
intros.
trivial.

*****
H : eq (andb (p a) (forallb p l)) true
p : forall _ : A, bool
IHl : forall (p : forall _ : A, bool) (_ : eq (forallb p l) true),\neq (forallb p (tl l)) true
l : list A
a : A
A : Type
*****
eq (forallb p l) true
+++++
rewrite andb_true_iff in H.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.
simpl.
intros.
trivial.
rewrite andb_true_iff in H.

*****
H : and (eq (p a) true) (eq (forallb p l) true)
p : forall _ : A, bool
IHl : forall (p : forall _ : A, bool) (_ : eq (forallb p l) true),\neq (forallb p (tl l)) true
l : list A
a : A
A : Type
*****
eq (forallb p l) true
+++++
tauto.
-----
Lemma forallb_tl : forall A (l : list A) (p : A -> bool), forallb p l = true -> forallb p (tail l) = true.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B),\n  (forall x, In x l -> p (f x) = true) ->\n  forallb p (map f l) = true.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.

*****

*****
forall (A B : Type) (l : list A) (p : forall _ : B, bool) (f : forall _ : A, B) (_ : forall (x : A) (_ : In x l), eq (p (f x)) true), eq (forallb p (map f l)) true
+++++
Proof.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.
Proof.

*****

*****
forall (A B : Type) (l : list A) (p : forall _ : B, bool) (f : forall _ : A, B) (_ : forall (x : A) (_ : In x l), eq (p (f x)) true), eq (forallb p (map f l)) true
+++++
intros.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.
Proof.
intros.

*****
H : forall (x : A) (_ : In x l), eq (p (f x)) true
f : forall _ : A, B
p : forall _ : B, bool
l : list A
B : Type
A : Type
*****
eq (forallb p (map f l)) true
+++++
apply forallb_forall.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.
Proof.
intros.
apply forallb_forall.

*****
H : forall (x : A) (_ : In x l), eq (p (f x)) true
f : forall _ : A, B
p : forall _ : B, bool
l : list A
B : Type
A : Type
*****
forall (x : B) (_ : In x (map f l)), eq (p x) true
+++++
intros.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.
Proof.
intros.
apply forallb_forall.
intros.

*****
H0 : In x (map f l)
x : B
H : forall (x : A) (_ : In x l), eq (p (f x)) true
f : forall _ : A, B
p : forall _ : B, bool
l : list A
B : Type
A : Type
*****
eq (p x) true
+++++
apply in_map_iff in H0.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.
Proof.
intros.
apply forallb_forall.
intros.
apply in_map_iff in H0.

*****
H0 : ex (fun x0 : A => and (eq (f x0) x) (In x0 l))
x : B
H : forall (x : A) (_ : In x l), eq (p (f x)) true
f : forall _ : A, B
p : forall _ : B, bool
l : list A
B : Type
A : Type
*****
eq (p x) true
+++++
destruct H0 as ( x' & H0 & H1).
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.
Proof.
intros.
apply forallb_forall.
intros.
apply in_map_iff in H0.
destruct H0 as ( x' & H0 & H1).

*****
H1 : In x' l
H0 : eq (f x') x
x' : A
x : B
H : forall (x : A) (_ : In x l), eq (p (f x)) true
f : forall _ : A, B
p : forall _ : B, bool
l : list A
B : Type
A : Type
*****
eq (p x) true
+++++
subst.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.
Proof.
intros.
apply forallb_forall.
intros.
apply in_map_iff in H0.
destruct H0 as ( x' & H0 & H1).
subst.

*****
H1 : In x' l
x' : A
H : forall (x : A) (_ : In x l), eq (p (f x)) true
f : forall _ : A, B
p : forall _ : B, bool
l : list A
B : Type
A : Type
*****
eq (p (f x')) true
+++++
auto.
-----
Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B), (forall x, In x l -> p (f x) = true) -> forallb p (map f l) = true.
Proof.
intros.
apply forallb_forall.
intros.
apply in_map_iff in H0.
destruct H0 as ( x' & H0 & H1).
subst.
auto.

*****

*****

+++++
Qed.
-----
Fixpoint repeat {A:Type}(n:nat)(x:A) : list A :=\n  match n with\n  | 0 => nil\n  | S n' => x :: repeat n' x\n  end.
-----
Lemma firstn_repeat_le :\n  forall A (x:A) m n,\n  m <= n ->\n  firstn m (repeat n x) = repeat m x.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.

*****

*****
forall (A : Type) (x : A) (m n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
+++++
Proof.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.

*****

*****
forall (A : Type) (x : A) (m n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
+++++
intros A x m.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.

*****
m : nat
x : A
A : Type
*****
forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
+++++
induction m as [ | m IH].
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].

*****
x : A
A : Type
*****
forall (n : nat) (_ : le O n), eq (firstn O (repeat n x)) (repeat O x)
+++++
intros n H.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].
intros n H.

*****
H : le O n
n : nat
x : A
A : Type
*****
eq (firstn O (repeat n x)) (repeat O x)
+++++
trivial.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].

*****
IH : forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
m : nat
x : A
A : Type
*****
forall (n : nat) (_ : le (S m) n), eq (firstn (S m) (repeat n x)) (repeat (S m) x)
+++++
intros n H.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].
intros n H.

*****
H : le (S m) n
n : nat
IH : forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
m : nat
x : A
A : Type
*****
eq (firstn (S m) (repeat n x)) (repeat (S m) x)
+++++
destruct n as [ | n].
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].
intros n H.
destruct n as [ | n].

*****
H : le (S m) O
IH : forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
m : nat
x : A
A : Type
*****
eq (firstn (S m) (repeat O x)) (repeat (S m) x)
+++++
contradict H.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].
intros n H.
destruct n as [ | n].
contradict H.

*****
IH : forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
m : nat
x : A
A : Type
*****
not (le (S m) O)
+++++
omega.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].
intros n H.
destruct n as [ | n].

*****
H : le (S m) (S n)
n : nat
IH : forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
m : nat
x : A
A : Type
*****
eq (firstn (S m) (repeat (S n) x)) (repeat (S m) x)
+++++
simpl.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].
intros n H.
destruct n as [ | n].
simpl.

*****
H : le (S m) (S n)
n : nat
IH : forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
m : nat
x : A
A : Type
*****
eq (cons x (firstn m (repeat n x))) (cons x (repeat m x))
+++++
f_equal.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].
intros n H.
destruct n as [ | n].
simpl.
f_equal.

*****
H : le (S m) (S n)
n : nat
IH : forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
m : nat
x : A
A : Type
*****
eq (firstn m (repeat n x)) (repeat m x)
+++++
apply IH.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].
intros n H.
destruct n as [ | n].
simpl.
f_equal.
apply IH.

*****
H : le (S m) (S n)
n : nat
IH : forall (n : nat) (_ : le m n), eq (firstn m (repeat n x)) (repeat m x)
m : nat
x : A
A : Type
*****
le m n
+++++
omega.
-----
Lemma firstn_repeat_le : forall A (x:A) m n, m <= n -> firstn m (repeat n x) = repeat m x.
Proof.
intros A x m.
induction m as [ | m IH].

*****

*****

+++++
Qed.
-----
Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.
-----
Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.

*****

*****
forall (A : Type) (x y : A) (n : nat) (_ : In x (repeat n y)), eq x y
+++++
Proof.
-----
Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.
Proof.

*****

*****
forall (A : Type) (x y : A) (n : nat) (_ : In x (repeat n y)), eq x y
+++++
induction n as [ | n IH]; simpl; intro H; [ tauto | ].
-----
Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.
Proof.
induction n as [ | n IH]; simpl; intro H; [ tauto | ].

*****
H : or (eq y x) (In x (repeat n y))
IH : forall _ : In x (repeat n y), eq x y
n : nat
x,y : A
A : Type
*****
eq x y
+++++
destruct H as [H | H].
-----
Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.
Proof.
induction n as [ | n IH]; simpl; intro H; [ tauto | ].
destruct H as [H | H].

*****
H : eq y x
IH : forall _ : In x (repeat n y), eq x y
n : nat
x,y : A
A : Type
*****
eq x y
+++++
congruence.
-----
Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.
Proof.
induction n as [ | n IH]; simpl; intro H; [ tauto | ].
destruct H as [H | H].
congruence.

*****
H : In x (repeat n y)
IH : forall _ : In x (repeat n y), eq x y
n : nat
x,y : A
A : Type
*****
eq x y
+++++
tauto.
-----
Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.
Proof.
induction n as [ | n IH]; simpl; intro H; [ tauto | ].
destruct H as [H | H].
congruence.
tauto.

*****

*****

+++++
Qed.
-----
Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).
-----
Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).

*****

*****
forall (A B : Type) (f : forall _ : A, B) (n : nat) (x : A), eq (map f (repeat n x)) (repeat n (f x))
+++++
Proof.
-----
Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).
Proof.

*****

*****
forall (A B : Type) (f : forall _ : A, B) (n : nat) (x : A), eq (map f (repeat n x)) (repeat n (f x))
+++++
induction n as [ | n IH].
-----
Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).
Proof.
induction n as [ | n IH].

*****
f : forall _ : A, B
B : Type
A : Type
*****
forall x : A, eq (map f (repeat O x)) (repeat O (f x))
+++++
trivial.
-----
Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).
Proof.
induction n as [ | n IH].

*****
IH : forall x : A, eq (map f (repeat n x)) (repeat n (f x))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall x : A, eq (map f (repeat (S n) x)) (repeat (S n) (f x))
+++++
simpl.
-----
Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).
Proof.
induction n as [ | n IH].
simpl.

*****
IH : forall x : A, eq (map f (repeat n x)) (repeat n (f x))
n : nat
f : forall _ : A, B
B : Type
A : Type
*****
forall x : A, eq (cons (f x) (map f (repeat n x))) (cons (f x) (repeat n (f x)))
+++++
congruence.
-----
Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).
Proof.
induction n as [ | n IH].

*****

*****

+++++
Qed.
-----
Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.
-----
Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.

*****

*****
forall n x : nat, eq (multl (repeat n x)) (power x n)
+++++
Proof.
-----
Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.
Proof.

*****

*****
forall n x : nat, eq (multl (repeat n x)) (power x n)
+++++
induction n as [ | n IH].
-----
Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.
Proof.
induction n as [ | n IH].

*****

*****
forall x : nat, eq (multl (repeat O x)) (power x O)
+++++
trivial.
-----
Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.
Proof.
induction n as [ | n IH].

*****
IH : forall x : nat, eq (multl (repeat n x)) (power x n)
n : nat
*****
forall x : nat, eq (multl (repeat (S n) x)) (power x (S n))
+++++
trivial.
-----
Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.
Proof.
induction n as [ | n IH].
trivial.

*****
IH : forall x : nat, eq (multl (repeat n x)) (power x n)
n : nat
*****
forall x : nat, eq (multl (repeat (S n) x)) (power x (S n))
+++++
simpl.
-----
Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.
Proof.
induction n as [ | n IH].
trivial.
simpl.

*****
IH : forall x : nat, eq (multl (repeat n x)) (power x n)
n : nat
*****
forall x : nat, eq (Init.Nat.mul x (multl (repeat n x))) (Init.Nat.mul x (power x n))
+++++
congruence.
-----
Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.
Proof.
induction n as [ | n IH].

*****

*****

+++++
Qed.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.

*****

*****
forall (A : Type) (n : nat) (x : A), eq (length (repeat n x)) n
+++++
Proof.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.

*****

*****
forall (A : Type) (n : nat) (x : A), eq (length (repeat n x)) n
+++++
induction n.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.
induction n.

*****
A : Type
*****
forall x : A, eq (length (repeat O x)) O
+++++
simpl.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.
induction n.
simpl.

*****
A : Type
*****
forall _ : A, eq O O
+++++
intros.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.
induction n.
simpl.
intros.

*****
x : A
A : Type
*****
eq O O
+++++
trivial.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.
induction n.

*****
IHn : forall x : A, eq (length (repeat n x)) n
n : nat
A : Type
*****
forall x : A, eq (length (repeat (S n) x)) (S n)
+++++
simpl.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.
induction n.
simpl.

*****
IHn : forall x : A, eq (length (repeat n x)) n
n : nat
A : Type
*****
forall x : A, eq (S (length (repeat n x))) (S n)
+++++
intros.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.
induction n.
simpl.
intros.

*****
x : A
IHn : forall x : A, eq (length (repeat n x)) n
n : nat
A : Type
*****
eq (S (length (repeat n x))) (S n)
+++++
trivial.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.
induction n.
simpl.
intros.
trivial.

*****
x : A
IHn : forall x : A, eq (length (repeat n x)) n
n : nat
A : Type
*****
eq (S (length (repeat n x))) (S n)
+++++
congruence.
-----
Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma nth_repeat :\n  forall A n (x:A) d i, i < n ->\n  nth i (repeat n x) d = x.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.

*****

*****
forall (A : Type) (n : nat) (x d : A) (i : nat) (_ : lt i n), eq (nth i (repeat n x) d) x
+++++
Proof.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.

*****

*****
forall (A : Type) (n : nat) (x d : A) (i : nat) (_ : lt i n), eq (nth i (repeat n x) d) x
+++++
intros A n x d.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.

*****
x,d : A
n : nat
A : Type
*****
forall (i : nat) (_ : lt i n), eq (nth i (repeat n x) d) x
+++++
induction n as [ | n IH].
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].

*****
x,d : A
A : Type
*****
forall (i : nat) (_ : lt i O), eq (nth i (repeat O x) d) x
+++++
simpl.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].
simpl.

*****
x,d : A
A : Type
*****
forall (i : nat) (_ : lt i O), eq match i with | O | _ => d end x
+++++
intros i H.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].
simpl.
intros i H.

*****
H : lt i O
i : nat
x,d : A
A : Type
*****
eq match i with | O | _ => d end x
+++++
contradict H.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].
simpl.
intros i H.
contradict H.

*****
i : nat
x,d : A
A : Type
*****
not (lt i O)
+++++
omega.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].

*****
IH : forall (i : nat) (_ : lt i n), eq (nth i (repeat n x) d) x
x,d : A
n : nat
A : Type
*****
forall (i : nat) (_ : lt i (S n)), eq (nth i (repeat (S n) x) d) x
+++++
simpl.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].
simpl.

*****
IH : forall (i : nat) (_ : lt i n), eq (nth i (repeat n x) d) x
x,d : A
n : nat
A : Type
*****
forall (i : nat) (_ : lt i (S n)), eq match i with | O => x | S m => nth m (repeat n x) d end x
+++++
intros i H.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].
simpl.
intros i H.

*****
H : lt i (S n)
i : nat
IH : forall (i : nat) (_ : lt i n), eq (nth i (repeat n x) d) x
x,d : A
n : nat
A : Type
*****
eq match i with | O => x | S m => nth m (repeat n x) d end x
+++++
destruct i as [ | i].
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].
simpl.
intros i H.
destruct i as [ | i].

*****
H : lt O (S n)
IH : forall (i : nat) (_ : lt i n), eq (nth i (repeat n x) d) x
x,d : A
n : nat
A : Type
*****
eq x x
+++++
auto with arith.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].
simpl.
intros i H.
destruct i as [ | i].

*****
H : lt (S i) (S n)
i : nat
IH : forall (i : nat) (_ : lt i n), eq (nth i (repeat n x) d) x
x,d : A
n : nat
A : Type
*****
eq (nth i (repeat n x) d) x
+++++
auto with arith.
-----
Lemma nth_repeat : forall A n (x:A) d i, i < n -> nth i (repeat n x) d = x.
Proof.
intros A n x d.
induction n as [ | n IH].

*****

*****

+++++
Qed.
-----
Definition move_forward {A}(i j:nat)(l:list A)(d:A) : list A :=\n  firstn i l ++ firstn j (skipn (S i) l) ++ (nth i l d :: skipn (S (i+j)) l).
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l :\n  f d1 = d2 ->\n  move_forward i j (map f l) d2 = map f (move_forward i j l d1).
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).

*****
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
forall _ : eq (f d1) d2, eq (move_forward i j (map f l) d2) (map f (move_forward i j l d1))
+++++
Proof.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.

*****
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
forall _ : eq (f d1) d2, eq (move_forward i j (map f l) d2) (map f (move_forward i j l d1))
+++++
intros.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (move_forward i j (map f l) d2) (map f (move_forward i j l d1))
+++++
unfold move_forward.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (app (firstn i (map f l)) (app (firstn j (skipn (S i) (map f l))) (cons (nth i (map f l) d2) (skipn (S (Init.Nat.add i j)) (map f l))))) (map f (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d1) (skipn (S (Init.Nat.add i j)) l)))))
+++++
rewrite !map_app.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (app (firstn i (map f l)) (app (firstn j (skipn (S i) (map f l))) (cons (nth i (map f l) d2) (skipn (S (Init.Nat.add i j)) (map f l))))) (app (map f (firstn i l)) (app (map f (firstn j (skipn (S i) l))) (map f (cons (nth i l d1) (skipn (S (Init.Nat.add i j)) l)))))
+++++
f_equal.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (firstn i (map f l)) (map f (firstn i l))
+++++
rewrite map_firstn.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
rewrite map_firstn.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (firstn i (map f l)) (firstn i (map f l))
+++++
trivial.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (app (firstn j (skipn (S i) (map f l))) (cons (nth i (map f l) d2) (skipn (S (Init.Nat.add i j)) (map f l)))) (app (map f (firstn j (skipn (S i) l))) (map f (cons (nth i l d1) (skipn (S (Init.Nat.add i j)) l))))
+++++
f_equal.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
f_equal.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (firstn j (skipn (S i) (map f l))) (map f (firstn j (skipn (S i) l)))
+++++
rewrite map_firstn.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
f_equal.
rewrite map_firstn.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (firstn j (skipn (S i) (map f l))) (firstn j (map f (skipn (S i) l)))
+++++
rewrite map_skipn.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
f_equal.
rewrite map_firstn.
rewrite map_skipn.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (firstn j (skipn (S i) (map f l))) (firstn j (skipn (S i) (map f l)))
+++++
trivial.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
f_equal.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (cons (nth i (map f l) d2) (skipn (S (Init.Nat.add i j)) (map f l))) (map f (cons (nth i l d1) (skipn (S (Init.Nat.add i j)) l)))
+++++
rewrite map_nth2 with (d:=d1).
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
f_equal.
rewrite map_nth2 with (d:=d1).

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (cons (f (nth i l d1)) (skipn (S (Init.Nat.add i j)) (map f l))) (map f (cons (nth i l d1) (skipn (S (Init.Nat.add i j)) l)))
+++++
trivial.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
f_equal.
rewrite map_nth2 with (d:=d1).
trivial.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (cons (f (nth i l d1)) (skipn (S (Init.Nat.add i j)) (map f l))) (map f (cons (nth i l d1) (skipn (S (Init.Nat.add i j)) l)))
+++++
rewrite <- map_skipn.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
f_equal.
rewrite map_nth2 with (d:=d1).
trivial.
rewrite <- map_skipn.

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (cons (f (nth i l d1)) (map f (skipn (S (Init.Nat.add i j)) l))) (map f (cons (nth i l d1) (skipn (S (Init.Nat.add i j)) l)))
+++++
trivial.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.
f_equal.
rewrite map_nth2 with (d:=d1).

*****
H : eq (f d1) d2
l : list A
f : forall _ : A, B
i,j : nat
d2 : B
d1 : A
B : Type
A : Type
*****
eq (f d1) d2
+++++
trivial.
-----
Lemma move_forward_map A B d1 d2 i j (f:A->B) l : f d1 = d2 -> move_forward i j (map f l) d2 = map f (move_forward i j l d1).
Proof.
intros.
unfold move_forward.
rewrite !map_app.
f_equal.

*****

*****

+++++
Qed.
-----
Lemma length_move_forward :\n  forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.

*****

*****
forall (A : Type) (i j : nat) (l : list A) (d : A) (_ : lt (Init.Nat.add i j) (length l)), eq (length (move_forward i j l d)) (length l)
+++++
Proof.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.

*****

*****
forall (A : Type) (i j : nat) (l : list A) (d : A) (_ : lt (Init.Nat.add i j) (length l)), eq (length (move_forward i j l d)) (length l)
+++++
unfold move_forward.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.

*****

*****
forall (A : Type) (i j : nat) (l : list A) (d : A) (_ : lt (Init.Nat.add i j) (length l)), eq (length (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (length l)
+++++
intros.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
eq (length (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (length l)
+++++
do 2 rewrite app_length.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
eq (Init.Nat.add (length (firstn i l)) (Init.Nat.add (length (firstn j (skipn (S i) l))) (length (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (length l)
+++++
do 2 rewrite firstn_length.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
eq (Init.Nat.add (Init.Nat.min i (length l)) (Init.Nat.add (Init.Nat.min j (length (skipn (S i) l))) (length (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (length l)
+++++
rewrite min_l.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.
rewrite min_l.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
eq (Init.Nat.add i (Init.Nat.add (Init.Nat.min j (length (skipn (S i) l))) (length (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (length l)
+++++
rewrite min_l.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.
rewrite min_l.
rewrite min_l.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
eq (Init.Nat.add i (Init.Nat.add j (length (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (length l)
+++++
change (length (nth i l d :: skipn (S (i + j)) l)) with (1 + length (skipn (S (i + j)) l)).
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.
rewrite min_l.
rewrite min_l.
change (length (nth i l d :: skipn (S (i + j)) l)) with (1 + length (skipn (S (i + j)) l)).

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
eq (Init.Nat.add i (Init.Nat.add j (Init.Nat.add (S O) (length (skipn (S (Init.Nat.add i j)) l))))) (length l)
+++++
rewrite length_skipn.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.
rewrite min_l.
rewrite min_l.
change (length (nth i l d :: skipn (S (i + j)) l)) with (1 + length (skipn (S (i + j)) l)).
rewrite length_skipn.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
eq (Init.Nat.add i (Init.Nat.add j (Init.Nat.add (S O) (Init.Nat.sub (length l) (S (Init.Nat.add i j)))))) (length l)
+++++
omega.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.
rewrite min_l.
rewrite min_l.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
le j (length (skipn (S i) l))
+++++
rewrite length_skipn.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.
rewrite min_l.
rewrite min_l.
rewrite length_skipn.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
le j (Init.Nat.sub (length l) (S i))
+++++
omega.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.
rewrite min_l.

*****
H : lt (Init.Nat.add i j) (length l)
d : A
l : list A
i,j : nat
A : Type
*****
le i (length l)
+++++
omega.
-----
Lemma length_move_forward : forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.
Proof.
unfold move_forward.
intros.
do 2 rewrite app_length.
do 2 rewrite firstn_length.
rewrite min_l.

*****

*****

+++++
Qed.
-----
Lemma in_move_forward_iff :\n  forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).

*****

*****
forall (A : Type) (x : A) (i j : nat) (d : A) (l : list A) (_ : lt i (length l)), iff (In x (move_forward i j l d)) (In x l)
+++++
Proof.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.

*****

*****
forall (A : Type) (x : A) (i j : nat) (d : A) (l : list A) (_ : lt i (length l)), iff (In x (move_forward i j l d)) (In x l)
+++++
unfold move_forward.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.

*****

*****
forall (A : Type) (x : A) (i j : nat) (d : A) (l : list A) (_ : lt i (length l)), iff (In x (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (In x l)
+++++
intros A x i j d l Hi.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
iff (In x (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (In x l)
+++++
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
iff (In x (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))) (In x (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l)))))
+++++
split.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
split.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
forall _ : In x (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l)))), In x (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))))
+++++
apply Permutation_in.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
split.
apply Permutation_in.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
Permutation (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l)))) (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))))
+++++
apply Permutation_app_head.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
split.
apply Permutation_in.
apply Permutation_app_head.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
Permutation (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l)))
+++++
apply Permutation_sym.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
split.
apply Permutation_in.
apply Permutation_app_head.
apply Permutation_sym.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
Permutation (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l)))
+++++
apply Permutation_middle.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
split.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
forall _ : In x (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l)))), In x (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))
+++++
apply Permutation_in.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
split.
apply Permutation_in.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
Permutation (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l)))) (app (firstn i l) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l))))
+++++
apply Permutation_app_head.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
split.
apply Permutation_in.
apply Permutation_app_head.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
Permutation (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))) (app (firstn j (skipn (S i) l)) (cons (nth i l d) (skipn (S (Init.Nat.add i j)) l)))
+++++
apply Permutation_middle.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
iff (In x (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))))) (In x l)
+++++
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq l (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))))
+++++
rewrite <- (firstn_skipn i l) at 1.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (app (firstn i l) (skipn i l)) (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))))
+++++
f_equal.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (skipn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l)))
+++++
transitivity (nth i l d :: skipn (S i) l).
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (skipn i l) (cons (nth i l d) (skipn (S i) l))
+++++
symmetry.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
symmetry.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (cons (nth i l d) (skipn (S i) l)) (skipn i l)
+++++
apply cons_skipn.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
symmetry.
apply cons_skipn.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
lt i (length l)
+++++
trivial.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (cons (nth i l d) (skipn (S i) l)) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l)))
+++++
f_equal.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
f_equal.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (skipn (S i) l) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))
+++++
transitivity (firstn j (skipn (S i) l) ++ skipn j (skipn (S i) l)).
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
f_equal.
transitivity (firstn j (skipn (S i) l) ++ skipn j (skipn (S i) l)).

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (skipn (S i) l) (app (firstn j (skipn (S i) l)) (skipn j (skipn (S i) l)))
+++++
rewrite firstn_skipn.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
f_equal.
transitivity (firstn j (skipn (S i) l) ++ skipn j (skipn (S i) l)).
rewrite firstn_skipn.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (skipn (S i) l) (skipn (S i) l)
+++++
trivial.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
f_equal.
transitivity (firstn j (skipn (S i) l) ++ skipn j (skipn (S i) l)).

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (app (firstn j (skipn (S i) l)) (skipn j (skipn (S i) l))) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))
+++++
f_equal.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
f_equal.
transitivity (firstn j (skipn (S i) l) ++ skipn j (skipn (S i) l)).
f_equal.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (skipn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l)
+++++
rewrite <- skipn_plus.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
f_equal.
transitivity (firstn j (skipn (S i) l) ++ skipn j (skipn (S i) l)).
f_equal.
rewrite <- skipn_plus.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (skipn (Init.Nat.add j (S i)) l) (skipn (S (Init.Nat.add i j)) l)
+++++
f_equal.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite <- (firstn_skipn i l) at 1.
f_equal.
transitivity (nth i l d :: skipn (S i) l).
f_equal.
transitivity (firstn j (skipn (S i) l) ++ skipn j (skipn (S i) l)).
f_equal.
rewrite <- skipn_plus.
f_equal.

*****
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
eq (Init.Nat.add j (S i)) (S (Init.Nat.add i j))
+++++
ring.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.

*****
H : eq l\n (app (firstn i l)\n (cons (nth i l d)\n (app (firstn j (skipn (S i) l))\n (skipn (S (Init.Nat.add i j)) l))))
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
iff (In x (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))))) (In x l)
+++++
rewrite H at 5.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).
assert (l = firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l) as H.
rewrite H at 5.

*****
H : eq l\n (app (firstn i l)\n (cons (nth i l d)\n (app (firstn j (skipn (S i) l))\n (skipn (S (Init.Nat.add i j)) l))))
Hi : lt i (length l)
l : list A
d : A
i,j : nat
x : A
A : Type
*****
iff (In x (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l))))) (In x (app (firstn i l) (cons (nth i l d) (app (firstn j (skipn (S i) l)) (skipn (S (Init.Nat.add i j)) l)))))
+++++
tauto.
-----
Lemma in_move_forward_iff : forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).
Proof.
unfold move_forward.
intros A x i j d l Hi.
transitivity (In x (firstn i l ++ nth i l d :: firstn j (skipn (S i) l) ++ skipn (S (i + j)) l)).

*****

*****

+++++
Qed.
-----
Lemma firstn_simpl : forall A B (l : list A) (l2 : list B),\n length l2 = length l ->\n firstn (length l2) l = l.
-----
Lemma firstn_simpl : forall A B (l : list A) (l2 : list B), length l2 = length l -> firstn (length l2) l = l.

*****

*****
forall (A B : Type) (l : list A) (l2 : list B) (_ : eq (length l2) (length l)), eq (firstn (length l2) l) l
+++++
Proof.
-----
Lemma firstn_simpl : forall A B (l : list A) (l2 : list B), length l2 = length l -> firstn (length l2) l = l.
Proof.

*****

*****
forall (A B : Type) (l : list A) (l2 : list B) (_ : eq (length l2) (length l)), eq (firstn (length l2) l) l
+++++
intros.
-----
Lemma firstn_simpl : forall A B (l : list A) (l2 : list B), length l2 = length l -> firstn (length l2) l = l.
Proof.
intros.

*****
H : eq (length l2) (length l)
l2 : list B
l : list A
B : Type
A : Type
*****
eq (firstn (length l2) l) l
+++++
rewrite H.
-----
Lemma firstn_simpl : forall A B (l : list A) (l2 : list B), length l2 = length l -> firstn (length l2) l = l.
Proof.
intros.
rewrite H.

*****
H : eq (length l2) (length l)
l2 : list B
l : list A
B : Type
A : Type
*****
eq (firstn (length l) l) l
+++++
rewrite <- app_nil_r with (l := l) at 2.
-----
Lemma firstn_simpl : forall A B (l : list A) (l2 : list B), length l2 = length l -> firstn (length l2) l = l.
Proof.
intros.
rewrite H.
rewrite <- app_nil_r with (l := l) at 2.

*****
H : eq (length l2) (length l)
l2 : list B
l : list A
B : Type
A : Type
*****
eq (firstn (length l) (app l nil)) l
+++++
rewrite firstn_app.
-----
Lemma firstn_simpl : forall A B (l : list A) (l2 : list B), length l2 = length l -> firstn (length l2) l = l.
Proof.
intros.
rewrite H.
rewrite <- app_nil_r with (l := l) at 2.
rewrite firstn_app.

*****
H : eq (length l2) (length l)
l2 : list B
l : list A
B : Type
A : Type
*****
eq l l
+++++
trivial.
-----
Lemma firstn_simpl : forall A B (l : list A) (l2 : list B), length l2 = length l -> firstn (length l2) l = l.
Proof.
intros.
rewrite H.
rewrite <- app_nil_r with (l := l) at 2.
rewrite firstn_app.
trivial.

*****

*****

+++++
Qed.
-----
Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, \n length l = n -> firstn n (l ++ l') = l.
-----
Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, length l = n -> firstn n (l ++ l') = l.

*****

*****
forall (A : Type) (l l' : list A) (n : nat) (_ : eq (length l) n), eq (firstn n (app l l')) l
+++++
Proof.
-----
Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, length l = n -> firstn n (l ++ l') = l.
Proof.

*****

*****
forall (A : Type) (l l' : list A) (n : nat) (_ : eq (length l) n), eq (firstn n (app l l')) l
+++++
intros.
-----
Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, length l = n -> firstn n (l ++ l') = l.
Proof.
intros.

*****
H : eq (length l) n
n : nat
l,l' : list A
A : Type
*****
eq (firstn n (app l l')) l
+++++
subst.
-----
Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, length l = n -> firstn n (l ++ l') = l.
Proof.
intros.
subst.

*****
l,l' : list A
A : Type
*****
eq (firstn (length l) (app l l')) l
+++++
apply firstn_app.
-----
Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, length l = n -> firstn n (l ++ l') = l.
Proof.
intros.
subst.
apply firstn_app.

*****

*****

+++++
Qed.
-----
Lemma firstn_firstn : forall A n (l : list A),\n firstn n (firstn n l) = firstn n l.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.

*****

*****
forall (A : Type) (n : nat) (l : list A), eq (firstn n (firstn n l)) (firstn n l)
+++++
Proof.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.

*****

*****
forall (A : Type) (n : nat) (l : list A), eq (firstn n (firstn n l)) (firstn n l)
+++++
induction n.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.

*****
A : Type
*****
forall l : list A, eq (firstn O (firstn O l)) (firstn O l)
+++++
simpl.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.
simpl.

*****
A : Type
*****
forall _ : list A, eq nil nil
+++++
auto.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.

*****
IHn : forall l : list A, eq (firstn n (firstn n l)) (firstn n l)
n : nat
A : Type
*****
forall l : list A, eq (firstn (S n) (firstn (S n) l)) (firstn (S n) l)
+++++
simpl.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.
simpl.

*****
IHn : forall l : list A, eq (firstn n (firstn n l)) (firstn n l)
n : nat
A : Type
*****
forall l : list A, eq match match l with | nil => nil | cons a l0 => cons a (firstn n l0) end with | nil => nil | cons a l0 => cons a (firstn n l0) end match l with | nil => nil | cons a l0 => cons a (firstn n l0) end
+++++
auto.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.
simpl.
auto.

*****
IHn : forall l : list A, eq (firstn n (firstn n l)) (firstn n l)
n : nat
A : Type
*****
forall l : list A, eq match match l with | nil => nil | cons a l0 => cons a (firstn n l0) end with | nil => nil | cons a l0 => cons a (firstn n l0) end match l with | nil => nil | cons a l0 => cons a (firstn n l0) end
+++++
intros [ | a l].
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.
simpl.
auto.
intros [ | a l].

*****
IHn : forall l : list A, eq (firstn n (firstn n l)) (firstn n l)
n : nat
A : Type
*****
eq nil nil
+++++
try rewrite IHn.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.
simpl.
auto.
intros [ | a l].
try rewrite IHn.

*****
IHn : forall l : list A, eq (firstn n (firstn n l)) (firstn n l)
n : nat
A : Type
*****
eq nil nil
+++++
auto.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.
simpl.
auto.
intros [ | a l].

*****
l : list A
a : A
IHn : forall l : list A, eq (firstn n (firstn n l)) (firstn n l)
n : nat
A : Type
*****
eq (cons a (firstn n (firstn n l))) (cons a (firstn n l))
+++++
try rewrite IHn.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.
simpl.
auto.
intros [ | a l].
try rewrite IHn.

*****
l : list A
a : A
IHn : forall l : list A, eq (firstn n (firstn n l)) (firstn n l)
n : nat
A : Type
*****
eq (cons a (firstn n l)) (cons a (firstn n l))
+++++
auto.
-----
Lemma firstn_firstn : forall A n (l : list A), firstn n (firstn n l) = firstn n l.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma In_firstn : forall A n a (l : list A),\n  In a (firstn n l) -> In a l.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.

*****

*****
forall (A : Type) (n : nat) (a : A) (l : list A) (_ : In a (firstn n l)), In a l
+++++
Proof.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.

*****

*****
forall (A : Type) (n : nat) (a : A) (l : list A) (_ : In a (firstn n l)), In a l
+++++
intros A.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.

*****
A : Type
*****
forall (n : nat) (a : A) (l : list A) (_ : In a (firstn n l)), In a l
+++++
induction n.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.

*****
A : Type
*****
forall (a : A) (l : list A) (_ : In a (firstn O l)), In a l
+++++
simpl.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.

*****
A : Type
*****
forall (a : A) (l : list A) (_ : False), In a l
+++++
intros.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.

*****
H : False
l : list A
a : A
A : Type
*****
In a l
+++++
elim H.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.

*****
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
forall (a : A) (l : list A) (_ : In a (firstn (S n) l)), In a l
+++++
simpl.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.

*****
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
forall (a : A) (l : list A) (_ : In a match l with | nil => nil | cons a0 l0 => cons a0 (firstn n l0) end), In a l
+++++
intros.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.

*****
H : In a match l with\n | nil => nil\n | cons a l => cons a (firstn n l)\n end
l : list A
a : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
In a l
+++++
destruct l.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.
destruct l.

*****
H : In a nil
a : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
In a nil
+++++
simpl in *.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.
destruct l.
simpl in *.

*****
H : False
a : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
False
+++++
elim H.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.
destruct l.

*****
H : In a (cons a0 (firstn n l))
l : list A
a,a0 : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
In a (cons a0 l)
+++++
simpl in *.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.
destruct l.
simpl in *.

*****
H : or (eq a0 a) (In a (firstn n l))
l : list A
a,a0 : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
or (eq a0 a) (In a l)
+++++
destruct H.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.
destruct l.
simpl in *.
destruct H.

*****
H : eq a0 a
l : list A
a,a0 : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
or (eq a0 a) (In a l)
+++++
subst.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.
destruct l.
simpl in *.
destruct H.
subst.

*****
l : list A
a : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
or (eq a a) (In a l)
+++++
auto.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.
destruct l.
simpl in *.
destruct H.

*****
H : In a (firstn n l)
l : list A
a,a0 : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
or (eq a0 a) (In a l)
+++++
subst.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.
simpl.
intros.
destruct l.
simpl in *.
destruct H.
subst.

*****
H : In a (firstn n l)
l : list A
a,a0 : A
IHn : forall (a : A) (l : list A) (_ : In a (firstn n l)), In a l
n : nat
A : Type
*****
or (eq a0 a) (In a l)
+++++
auto.
-----
Lemma In_firstn : forall A n a (l : list A), In a (firstn n l) -> In a l.
Proof.
intros A.
induction n.

*****

*****

+++++
Qed.
-----
