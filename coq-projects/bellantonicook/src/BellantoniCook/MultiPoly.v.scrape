From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import BellantoniCook.Lib.
-----
Definition pow : Type := (nat*nat)%type.
-----
Definition mon : Type := (nat * list pow)%type.
-----
Definition pol : Type := (nat * list mon)%type.
-----
Definition peval_pow (xn:pow)(l:list nat) : nat :=\n  power (nth (fst xn) l 0) (snd xn).
-----
Definition peval_mon (m:mon)(l:list nat) : nat :=\n  (fst m) * multl (map (fun x => peval_pow x l) (snd m)).
-----
Definition peval (p:pol)(l:list nat) :=\n  plusl (map (fun m => peval_mon m l) (snd p)).
-----
Lemma peval_parity : forall ar p l,\n  peval (ar, snd p) l = peval p l.
-----
Lemma peval_parity : forall ar p l, peval (ar, snd p) l = peval p l.

*****

*****
forall (ar : nat) (p : prod nat (list mon)) (l : list nat), eq (peval (pair ar (snd p)) l) (peval p l)
+++++
Proof.
-----
Lemma peval_parity : forall ar p l, peval (ar, snd p) l = peval p l.
Proof.

*****

*****
forall (ar : nat) (p : prod nat (list mon)) (l : list nat), eq (peval (pair ar (snd p)) l) (peval p l)
+++++
intros ar [ar0 ml] l.
-----
Lemma peval_parity : forall ar p l, peval (ar, snd p) l = peval p l.
Proof.
intros ar [ar0 ml] l.

*****
l : list nat
ml : list mon
ar,ar0 : nat
*****
eq (peval (pair ar (snd (pair ar0 ml))) l) (peval (pair ar0 ml) l)
+++++
simpl.
-----
Lemma peval_parity : forall ar p l, peval (ar, snd p) l = peval p l.
Proof.
intros ar [ar0 ml] l.
simpl.

*****
l : list nat
ml : list mon
ar,ar0 : nat
*****
eq (peval (pair ar ml) l) (peval (pair ar0 ml) l)
+++++
trivial.
-----
Lemma peval_parity : forall ar p l, peval (ar, snd p) l = peval p l.
Proof.
intros ar [ar0 ml] l.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma peval_pow_monotonic : forall xn l1 l2, \n  (forall i, nth i l1 0 <= nth i l2 0) ->\n  peval_pow xn l1 <= peval_pow xn l2.
-----
Lemma peval_pow_monotonic : forall xn l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_pow xn l1 <= peval_pow xn l2.

*****

*****
forall (xn : pow) (l1 l2 : list nat) (_ : forall i : nat, le (nth i l1 O) (nth i l2 O)), le (peval_pow xn l1) (peval_pow xn l2)
+++++
Proof.
-----
Lemma peval_pow_monotonic : forall xn l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_pow xn l1 <= peval_pow xn l2.
Proof.

*****

*****
forall (xn : pow) (l1 l2 : list nat) (_ : forall i : nat, le (nth i l1 O) (nth i l2 O)), le (peval_pow xn l1) (peval_pow xn l2)
+++++
intros [x n] l1 l2 H.
-----
Lemma peval_pow_monotonic : forall xn l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_pow xn l1 <= peval_pow xn l2.
Proof.
intros [x n] l1 l2 H.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
x,n : nat
*****
le (peval_pow (pair x n) l1) (peval_pow (pair x n) l2)
+++++
simpl.
-----
Lemma peval_pow_monotonic : forall xn l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_pow xn l1 <= peval_pow xn l2.
Proof.
intros [x n] l1 l2 H.
simpl.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
x,n : nat
*****
le (peval_pow (pair x n) l1) (peval_pow (pair x n) l2)
+++++
apply power_le_l.
-----
Lemma peval_pow_monotonic : forall xn l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_pow xn l1 <= peval_pow xn l2.
Proof.
intros [x n] l1 l2 H.
simpl.
apply power_le_l.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
x,n : nat
*****
le (nth (fst (pair x n)) l1 O) (nth (fst (pair x n)) l2 O)
+++++
trivial.
-----
Lemma peval_pow_monotonic : forall xn l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_pow xn l1 <= peval_pow xn l2.
Proof.
intros [x n] l1 l2 H.
simpl.
apply power_le_l.
trivial.

*****

*****

+++++
Qed.
-----
Lemma peval_mon_monotonic : forall m l1 l2, \n  (forall i, nth i l1 0 <= nth i l2 0) ->\n  peval_mon m l1 <= peval_mon m l2.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.

*****

*****
forall (m : mon) (l1 l2 : list nat) (_ : forall i : nat, le (nth i l1 O) (nth i l2 O)), le (peval_mon m l1) (peval_mon m l2)
+++++
Proof.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.

*****

*****
forall (m : mon) (l1 l2 : list nat) (_ : forall i : nat, le (nth i l1 O) (nth i l2 O)), le (peval_mon m l1) (peval_mon m l2)
+++++
unfold peval_mon.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.

*****

*****
forall (m : mon) (l1 l2 : list nat) (_ : forall i : nat, le (nth i l1 O) (nth i l2 O)), le (Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l1) (snd m)))) (Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l2) (snd m))))
+++++
intros [a xl] l1 l2 H.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a : nat
*****
le (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl))))) (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
+++++
induction xl.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
a : nat
*****
le (Init.Nat.mul (fst (pair a nil)) (multl (map (fun x : pow => peval_pow x l1) (snd (pair a nil))))) (Init.Nat.mul (fst (pair a nil)) (multl (map (fun x : pow => peval_pow x l2) (snd (pair a nil)))))
+++++
simpl.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
a : nat
*****
le (Init.Nat.mul a (S O)) (Init.Nat.mul a (S O))
+++++
trivial.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (Init.Nat.mul (fst (pair a (cons a0 xl))) (multl (map (fun x : pow => peval_pow x l1) (snd (pair a (cons a0 xl)))))) (Init.Nat.mul (fst (pair a (cons a0 xl))) (multl (map (fun x : pow => peval_pow x l2) (snd (pair a (cons a0 xl))))))
+++++
simpl.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 l1) (multl (map (fun x : pow => peval_pow x l1) xl)))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 l2) (multl (map (fun x : pow => peval_pow x l2) xl))))
+++++
trivial.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.
trivial.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 l1) (multl (map (fun x : pow => peval_pow x l1) xl)))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 l2) (multl (map (fun x : pow => peval_pow x l2) xl))))
+++++
rewrite !mult_assoc.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.
trivial.
rewrite !mult_assoc.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (Nat.mul (Nat.mul a (peval_pow a0 l1)) (multl (map (fun x : pow => peval_pow x l1) xl))) (Nat.mul (Nat.mul a (peval_pow a0 l2)) (multl (map (fun x : pow => peval_pow x l2) xl)))
+++++
rewrite !(mult_comm a).
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.
trivial.
rewrite !mult_assoc.
rewrite !(mult_comm a).

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (Nat.mul (Nat.mul (peval_pow a0 l1) a) (multl (map (fun x : pow => peval_pow x l1) xl))) (Nat.mul (Nat.mul (peval_pow a0 l2) a) (multl (map (fun x : pow => peval_pow x l2) xl)))
+++++
rewrite <- !mult_assoc.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.
trivial.
rewrite !mult_assoc.
rewrite !(mult_comm a).
rewrite <- !mult_assoc.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (Nat.mul (peval_pow a0 l1) (Nat.mul a (multl (map (fun x : pow => peval_pow x l1) xl)))) (Nat.mul (peval_pow a0 l2) (Nat.mul a (multl (map (fun x : pow => peval_pow x l2) xl))))
+++++
apply mult_le_compat.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.
trivial.
rewrite !mult_assoc.
rewrite !(mult_comm a).
rewrite <- !mult_assoc.
apply mult_le_compat.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (peval_pow a0 l1) (peval_pow a0 l2)
+++++
trivial.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.
trivial.
rewrite !mult_assoc.
rewrite !(mult_comm a).
rewrite <- !mult_assoc.
apply mult_le_compat.
trivial.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (peval_pow a0 l1) (peval_pow a0 l2)
+++++
apply peval_pow_monotonic.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.
trivial.
rewrite !mult_assoc.
rewrite !(mult_comm a).
rewrite <- !mult_assoc.
apply mult_le_compat.
trivial.
apply peval_pow_monotonic.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
forall i : nat, le (nth i l1 O) (nth i l2 O)
+++++
trivial.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.
simpl.
trivial.
rewrite !mult_assoc.
rewrite !(mult_comm a).
rewrite <- !mult_assoc.
apply mult_le_compat.

*****
IHxl : le\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l1) (snd (pair a xl)))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x l2) (snd (pair a xl)))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
xl : list pow
a0 : pow
a : nat
*****
le (Nat.mul a (multl (map (fun x : pow => peval_pow x l1) xl))) (Nat.mul a (multl (map (fun x : pow => peval_pow x l2) xl)))
+++++
trivial.
-----
Lemma peval_mon_monotonic : forall m l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval_mon m l1 <= peval_mon m l2.
Proof.
unfold peval_mon.
intros [a xl] l1 l2 H.
induction xl.

*****

*****

+++++
Qed.
-----
Lemma peval_monotonic : forall p l1 l2, \n  (forall i, nth i l1 0 <= nth i l2 0) ->\n  peval p l1 <= peval p l2.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.

*****

*****
forall (p : pol) (l1 l2 : list nat) (_ : forall i : nat, le (nth i l1 O) (nth i l2 O)), le (peval p l1) (peval p l2)
+++++
Proof.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.

*****

*****
forall (p : pol) (l1 l2 : list nat) (_ : forall i : nat, le (nth i l1 O) (nth i l2 O)), le (peval p l1) (peval p l2)
+++++
unfold peval.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.

*****

*****
forall (p : pol) (l1 l2 : list nat) (_ : forall i : nat, le (nth i l1 O) (nth i l2 O)), le (plusl (map (fun m : mon => peval_mon m l1) (snd p))) (plusl (map (fun m : mon => peval_mon m l2) (snd p)))
+++++
intros [ar ml] l1 l2 H.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ml : list mon
ar : nat
*****
le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar ml)))) (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar ml))))
+++++
induction ml.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ar : nat
*****
le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar nil)))) (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar nil))))
+++++
simpl.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.
simpl.

*****
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ar : nat
*****
le O O
+++++
trivial.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.

*****
IHml : le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar ml))))\n (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar ml))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ml : list mon
a : mon
ar : nat
*****
le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar (cons a ml))))) (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar (cons a ml)))))
+++++
simpl.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.
simpl.

*****
IHml : le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar ml))))\n (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar ml))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ml : list mon
a : mon
ar : nat
*****
le (Init.Nat.add (peval_mon a l1) (plusl (map (fun m : mon => peval_mon m l1) ml))) (Init.Nat.add (peval_mon a l2) (plusl (map (fun m : mon => peval_mon m l2) ml)))
+++++
trivial.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.
simpl.
trivial.

*****
IHml : le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar ml))))\n (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar ml))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ml : list mon
a : mon
ar : nat
*****
le (Init.Nat.add (peval_mon a l1) (plusl (map (fun m : mon => peval_mon m l1) ml))) (Init.Nat.add (peval_mon a l2) (plusl (map (fun m : mon => peval_mon m l2) ml)))
+++++
apply plus_le_compat.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.
simpl.
trivial.
apply plus_le_compat.

*****
IHml : le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar ml))))\n (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar ml))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ml : list mon
a : mon
ar : nat
*****
le (peval_mon a l1) (peval_mon a l2)
+++++
trivial.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.
simpl.
trivial.
apply plus_le_compat.
trivial.

*****
IHml : le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar ml))))\n (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar ml))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ml : list mon
a : mon
ar : nat
*****
le (peval_mon a l1) (peval_mon a l2)
+++++
apply peval_mon_monotonic.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.
simpl.
trivial.
apply plus_le_compat.
trivial.
apply peval_mon_monotonic.

*****
IHml : le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar ml))))\n (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar ml))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ml : list mon
a : mon
ar : nat
*****
forall i : nat, le (nth i l1 O) (nth i l2 O)
+++++
trivial.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.
simpl.
trivial.
apply plus_le_compat.

*****
IHml : le (plusl (map (fun m : mon => peval_mon m l1) (snd (pair ar ml))))\n (plusl (map (fun m : mon => peval_mon m l2) (snd (pair ar ml))))
H : forall i : nat, le (nth i l1 O) (nth i l2 O)
l1,l2 : list nat
ml : list mon
a : mon
ar : nat
*****
le (plusl (map (fun m : mon => peval_mon m l1) ml)) (plusl (map (fun m : mon => peval_mon m l2) ml))
+++++
trivial.
-----
Lemma peval_monotonic : forall p l1 l2, (forall i, nth i l1 0 <= nth i l2 0) -> peval p l1 <= peval p l2.
Proof.
unfold peval.
intros [ar ml] l1 l2 H.
induction ml.

*****

*****

+++++
Qed.
-----
Lemma peval_nth i pl p l :\n  peval (nth i pl p) l =\n  nth i (map (fun p => peval p l) pl) (peval p l).
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).

*****
l : list nat
p : pol
pl : list pol
i : nat
*****
eq (peval (nth i pl p) l) (nth i (map (fun p : pol => peval p l) pl) (peval p l))
+++++
Proof.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.

*****
l : list nat
p : pol
pl : list pol
i : nat
*****
eq (peval (nth i pl p) l) (nth i (map (fun p : pol => peval p l) pl) (peval p l))
+++++
intros.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.

*****
l : list nat
p : pol
pl : list pol
i : nat
*****
eq (peval (nth i pl p) l) (nth i (map (fun p : pol => peval p l) pl) (peval p l))
+++++
revert i.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.

*****
l : list nat
p : pol
pl : list pol
*****
forall i : nat, eq (peval (nth i pl p) l) (nth i (map (fun p : pol => peval p l) pl) (peval p l))
+++++
induction pl.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.

*****
l : list nat
p : pol
*****
forall i : nat, eq (peval (nth i nil p) l) (nth i (map (fun p : pol => peval p l) nil) (peval p l))
+++++
intros [ | i].
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].

*****
l : list nat
p : pol
*****
eq (peval (nth O nil p) l) (nth O (map (fun p : pol => peval p l) nil) (peval p l))
+++++
simpl.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].
simpl.

*****
l : list nat
p : pol
*****
eq (peval p l) (peval p l)
+++++
intros.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].
simpl.
intros.

*****
l : list nat
p : pol
*****
eq (peval p l) (peval p l)
+++++
trivial.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].

*****
i : nat
l : list nat
p : pol
*****
eq (peval (nth (S i) nil p) l) (nth (S i) (map (fun p : pol => peval p l) nil) (peval p l))
+++++
simpl.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].
simpl.

*****
i : nat
l : list nat
p : pol
*****
eq (peval p l) (peval p l)
+++++
intros.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].
simpl.
intros.

*****
i : nat
l : list nat
p : pol
*****
eq (peval p l) (peval p l)
+++++
trivial.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.

*****
IHpl : forall i : nat,\neq (peval (nth i pl p) l)\n (nth i (map (fun p : pol => peval p l) pl) (peval p l))
l : list nat
p : pol
pl : list pol
a : pol
*****
forall i : nat, eq (peval (nth i (cons a pl) p) l) (nth i (map (fun p : pol => peval p l) (cons a pl)) (peval p l))
+++++
intros [ | i].
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].

*****
IHpl : forall i : nat,\neq (peval (nth i pl p) l)\n (nth i (map (fun p : pol => peval p l) pl) (peval p l))
l : list nat
p : pol
pl : list pol
a : pol
*****
eq (peval (nth O (cons a pl) p) l) (nth O (map (fun p : pol => peval p l) (cons a pl)) (peval p l))
+++++
simpl.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].
simpl.

*****
IHpl : forall i : nat,\neq (peval (nth i pl p) l)\n (nth i (map (fun p : pol => peval p l) pl) (peval p l))
l : list nat
p : pol
pl : list pol
a : pol
*****
eq (peval a l) (peval a l)
+++++
intros.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].
simpl.
intros.

*****
IHpl : forall i : nat,\neq (peval (nth i pl p) l)\n (nth i (map (fun p : pol => peval p l) pl) (peval p l))
l : list nat
p : pol
pl : list pol
a : pol
*****
eq (peval a l) (peval a l)
+++++
trivial.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].

*****
i : nat
IHpl : forall i : nat,\neq (peval (nth i pl p) l)\n (nth i (map (fun p : pol => peval p l) pl) (peval p l))
l : list nat
p : pol
pl : list pol
a : pol
*****
eq (peval (nth (S i) (cons a pl) p) l) (nth (S i) (map (fun p : pol => peval p l) (cons a pl)) (peval p l))
+++++
simpl.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].
simpl.

*****
i : nat
IHpl : forall i : nat,\neq (peval (nth i pl p) l)\n (nth i (map (fun p : pol => peval p l) pl) (peval p l))
l : list nat
p : pol
pl : list pol
a : pol
*****
eq (peval (nth i pl p) l) (nth i (map (fun p : pol => peval p l) pl) (peval p l))
+++++
intros.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.
intros [ | i].
simpl.
intros.

*****
i : nat
IHpl : forall i : nat,\neq (peval (nth i pl p) l)\n (nth i (map (fun p : pol => peval p l) pl) (peval p l))
l : list nat
p : pol
pl : list pol
a : pol
*****
eq (peval (nth i pl p) l) (nth i (map (fun p : pol => peval p l) pl) (peval p l))
+++++
trivial.
-----
Lemma peval_nth i pl p l : peval (nth i pl p) l = nth i (map (fun p => peval p l) pl) (peval p l).
Proof.
intros.
revert i.
induction pl.

*****

*****

+++++
Qed.
-----
Notation parity := (@fst nat (list mon)).
-----
Definition pWF_pow (ar:nat)(xn:pow) : Prop :=\n  fst xn < ar.
-----
Definition pWF_mon (ar:nat)(m:mon) : Prop :=\n  andl (pWF_pow ar) (snd m).
-----
Definition pWF' (ar:nat)(ml:list mon) : Prop :=\n  andl (pWF_mon ar) ml.
-----
Definition pWF (p:pol) : Prop :=\n  pWF' (fst p) (snd p).
-----
Lemma pWF_mon_le : forall ar1 ar2 m,\n  ar1 <= ar2 -> \n  pWF_mon ar1 m -> pWF_mon ar2 m.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.

*****

*****
forall (ar1 ar2 : nat) (m : mon) (_ : le ar1 ar2) (_ : pWF_mon ar1 m), pWF_mon ar2 m
+++++
Proof.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.

*****

*****
forall (ar1 ar2 : nat) (m : mon) (_ : le ar1 ar2) (_ : pWF_mon ar1 m), pWF_mon ar2 m
+++++
unfold pWF_mon.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.

*****

*****
forall (ar1 ar2 : nat) (m : mon) (_ : le ar1 ar2) (_ : andl (pWF_pow ar1) (snd m)), andl (pWF_pow ar2) (snd m)
+++++
unfold pWF_pow.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (ar1 ar2 : nat) (m : mon) (_ : le ar1 ar2) (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd m)), andl (fun xn : pow => lt (fst xn) ar2) (snd m)
+++++
intros ar1 ar2 [a xl].
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].

*****
xl : list pow
ar1,ar2,a : nat
*****
forall (_ : le ar1 ar2) (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd (pair a xl))), andl (fun xn : pow => lt (fst xn) ar2) (snd (pair a xl))
+++++
induction xl as [ | xn xl' IH].
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].

*****
ar1,ar2,a : nat
*****
forall (_ : le ar1 ar2) (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd (pair a nil))), andl (fun xn : pow => lt (fst xn) ar2) (snd (pair a nil))
+++++
simpl.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.

*****
ar1,ar2,a : nat
*****
forall (_ : le ar1 ar2) (_ : True), True
+++++
intros.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.
intros.

*****
H0 : True
H : le ar1 ar2
ar1,ar2,a : nat
*****
True
+++++
trivial.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].

*****
IH : forall (_ : le ar1 ar2)\n (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd (pair a xl'))),\nandl (fun xn : pow => lt (fst xn) ar2) (snd (pair a xl'))
xl' : list pow
xn : pow
ar1,ar2,a : nat
*****
forall (_ : le ar1 ar2) (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd (pair a (cons xn xl')))), andl (fun xn : pow => lt (fst xn) ar2) (snd (pair a (cons xn xl')))
+++++
simpl.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.

*****
IH : forall (_ : le ar1 ar2)\n (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd (pair a xl'))),\nandl (fun xn : pow => lt (fst xn) ar2) (snd (pair a xl'))
xl' : list pow
xn : pow
ar1,ar2,a : nat
*****
forall (_ : le ar1 ar2) (_ : and (lt (fst xn) ar1) (andl (fun xn : pow => lt (fst xn) ar1) xl')), and (lt (fst xn) ar2) (andl (fun xn : pow => lt (fst xn) ar2) xl')
+++++
intros.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.
intros.

*****
H0 : and (lt (fst xn) ar1) (andl (fun xn : pow => lt (fst xn) ar1) xl')
H : le ar1 ar2
IH : forall (_ : le ar1 ar2)\n (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd (pair a xl'))),\nandl (fun xn : pow => lt (fst xn) ar2) (snd (pair a xl'))
xl' : list pow
xn : pow
ar1,ar2,a : nat
*****
and (lt (fst xn) ar2) (andl (fun xn : pow => lt (fst xn) ar2) xl')
+++++
trivial.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.
intros.
trivial.

*****
H0 : and (lt (fst xn) ar1) (andl (fun xn : pow => lt (fst xn) ar1) xl')
H : le ar1 ar2
IH : forall (_ : le ar1 ar2)\n (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd (pair a xl'))),\nandl (fun xn : pow => lt (fst xn) ar2) (snd (pair a xl'))
xl' : list pow
xn : pow
ar1,ar2,a : nat
*****
and (lt (fst xn) ar2) (andl (fun xn : pow => lt (fst xn) ar2) xl')
+++++
destruct xn as [x n].
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.
intros.
trivial.
destruct xn as [x n].

*****
H0 : and (lt (fst (pair x n)) ar1)\n (andl (fun xn : pow => lt (fst xn) ar1) xl')
H : le ar1 ar2
IH : forall (_ : le ar1 ar2)\n (_ : andl (fun xn : pow => lt (fst xn) ar1) (snd (pair a xl'))),\nandl (fun xn : pow => lt (fst xn) ar2) (snd (pair a xl'))
xl' : list pow
ar1,ar2,a,x,n : nat
*****
and (lt (fst (pair x n)) ar2) (andl (fun xn : pow => lt (fst xn) ar2) xl')
+++++
simpl in *.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.
intros.
trivial.
destruct xn as [x n].
simpl in *.

*****
H0 : and (lt x ar1) (andl (fun xn : pow => lt (fst xn) ar1) xl')
H : le ar1 ar2
IH : forall (_ : le ar1 ar2)\n (_ : andl (fun xn : pow => lt (fst xn) ar1) xl'),\nandl (fun xn : pow => lt (fst xn) ar2) xl'
xl' : list pow
ar1,ar2,a,x,n : nat
*****
and (lt x ar2) (andl (fun xn : pow => lt (fst xn) ar2) xl')
+++++
split.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.
intros.
trivial.
destruct xn as [x n].
simpl in *.
split.

*****
H0 : and (lt x ar1) (andl (fun xn : pow => lt (fst xn) ar1) xl')
H : le ar1 ar2
IH : forall (_ : le ar1 ar2)\n (_ : andl (fun xn : pow => lt (fst xn) ar1) xl'),\nandl (fun xn : pow => lt (fst xn) ar2) xl'
xl' : list pow
ar1,ar2,a,x,n : nat
*****
lt x ar2
+++++
omega.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].
simpl.
intros.
trivial.
destruct xn as [x n].
simpl in *.
split.

*****
H0 : and (lt x ar1) (andl (fun xn : pow => lt (fst xn) ar1) xl')
H : le ar1 ar2
IH : forall (_ : le ar1 ar2)\n (_ : andl (fun xn : pow => lt (fst xn) ar1) xl'),\nandl (fun xn : pow => lt (fst xn) ar2) xl'
xl' : list pow
ar1,ar2,a,x,n : nat
*****
andl (fun xn : pow => lt (fst xn) ar2) xl'
+++++
tauto.
-----
Lemma pWF_mon_le : forall ar1 ar2 m, ar1 <= ar2 -> pWF_mon ar1 m -> pWF_mon ar2 m.
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar1 ar2 [a xl].
induction xl as [ | xn xl' IH].

*****

*****

+++++
Qed.
-----
Lemma pWF'_le ar1 ar2 ml :\n  ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.

*****
ml : list mon
ar1,ar2 : nat
*****
forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
+++++
Proof.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.

*****
ml : list mon
ar1,ar2 : nat
*****
forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
+++++
induction ml.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.

*****
ar1,ar2 : nat
*****
forall (_ : le ar1 ar2) (_ : pWF' ar1 nil), pWF' ar2 nil
+++++
simpl.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.

*****
ar1,ar2 : nat
*****
forall (_ : le ar1 ar2) (_ : True), True
+++++
intros.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.

*****
H0 : True
H : le ar1 ar2
ar1,ar2 : nat
*****
True
+++++
trivial.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.

*****
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
forall (_ : le ar1 ar2) (_ : pWF' ar1 (cons a ml)), pWF' ar2 (cons a ml)
+++++
simpl.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.

*****
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
forall (_ : le ar1 ar2) (_ : and (pWF_mon ar1 a) (pWF' ar1 ml)), and (pWF_mon ar2 a) (pWF' ar2 ml)
+++++
intros.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.

*****
H0 : and (pWF_mon ar1 a) (pWF' ar1 ml)
H : le ar1 ar2
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
and (pWF_mon ar2 a) (pWF' ar2 ml)
+++++
trivial.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.
trivial.

*****
H0 : and (pWF_mon ar1 a) (pWF' ar1 ml)
H : le ar1 ar2
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
and (pWF_mon ar2 a) (pWF' ar2 ml)
+++++
split.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.
trivial.
split.

*****
H0 : and (pWF_mon ar1 a) (pWF' ar1 ml)
H : le ar1 ar2
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
pWF_mon ar2 a
+++++
idtac.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.
trivial.
split.
idtac.

*****
H0 : and (pWF_mon ar1 a) (pWF' ar1 ml)
H : le ar1 ar2
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
pWF_mon ar2 a
+++++
apply pWF_mon_le with ar1.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.
trivial.
split.
idtac.
apply pWF_mon_le with ar1.

*****
H0 : and (pWF_mon ar1 a) (pWF' ar1 ml)
H : le ar1 ar2
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
le ar1 ar2
+++++
trivial.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.
trivial.
split.
idtac.
apply pWF_mon_le with ar1.

*****
H0 : and (pWF_mon ar1 a) (pWF' ar1 ml)
H : le ar1 ar2
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
pWF_mon ar1 a
+++++
trivial.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.
trivial.
split.
idtac.
apply pWF_mon_le with ar1.
trivial.

*****
H0 : and (pWF_mon ar1 a) (pWF' ar1 ml)
H : le ar1 ar2
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
pWF_mon ar1 a
+++++
tauto.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.
simpl.
intros.
trivial.
split.

*****
H0 : and (pWF_mon ar1 a) (pWF' ar1 ml)
H : le ar1 ar2
IHml : forall (_ : le ar1 ar2) (_ : pWF' ar1 ml), pWF' ar2 ml
ml : list mon
a : mon
ar1,ar2 : nat
*****
pWF' ar2 ml
+++++
tauto.
-----
Lemma pWF'_le ar1 ar2 ml : ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.
Proof.
induction ml.

*****

*****

+++++
Qed.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2,\n  pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) ->\n  pWF_mon ar (a1*a2, xl1++xl2).
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).

*****

*****
forall (ar a1 : nat) (xl1 : list pow) (a2 : nat) (xl2 : list pow) (_ : pWF_mon ar (pair a1 xl1)) (_ : pWF_mon ar (pair a2 xl2)), pWF_mon ar (pair (Init.Nat.mul a1 a2) (app xl1 xl2))
+++++
Proof.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.

*****

*****
forall (ar a1 : nat) (xl1 : list pow) (a2 : nat) (xl2 : list pow) (_ : pWF_mon ar (pair a1 xl1)) (_ : pWF_mon ar (pair a2 xl2)), pWF_mon ar (pair (Init.Nat.mul a1 a2) (app xl1 xl2))
+++++
unfold pWF_mon.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.

*****

*****
forall (ar a1 : nat) (xl1 : list pow) (a2 : nat) (xl2 : list pow) (_ : andl (pWF_pow ar) (snd (pair a1 xl1))) (_ : andl (pWF_pow ar) (snd (pair a2 xl2))), andl (pWF_pow ar) (snd (pair (Init.Nat.mul a1 a2) (app xl1 xl2)))
+++++
unfold pWF_pow.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (ar a1 : nat) (xl1 : list pow) (a2 : nat) (xl2 : list pow) (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1))) (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))), andl (fun xn : pow => lt (fst xn) ar) (snd (pair (Init.Nat.mul a1 a2) (app xl1 xl2)))
+++++
induction xl1 as [ | [x n] xl1' IH].
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].

*****
ar,a1 : nat
*****
forall (a2 : nat) (xl2 : list pow) (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 nil))) (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))), andl (fun xn : pow => lt (fst xn) ar) (snd (pair (Init.Nat.mul a1 a2) (app nil xl2)))
+++++
simpl.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.

*****
ar,a1 : nat
*****
forall (_ : nat) (xl2 : list pow) (_ : True) (_ : andl (fun xn : pow => lt (fst xn) ar) xl2), andl (fun xn : pow => lt (fst xn) ar) xl2
+++++
intros.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.
intros.

*****
H0 : andl (fun xn : pow => lt (fst xn) ar) xl2
H : True
xl2 : list pow
ar,a1,a2 : nat
*****
andl (fun xn : pow => lt (fst xn) ar) xl2
+++++
trivial.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].

*****
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
forall (a2 : nat) (xl2 : list pow) (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 (cons (pair x n) xl1')))) (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))), andl (fun xn : pow => lt (fst xn) ar) (snd (pair (Init.Nat.mul a1 a2) (app (cons (pair x n) xl1') xl2)))
+++++
simpl.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.

*****
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
forall (_ : nat) (xl2 : list pow) (_ : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl1')) (_ : andl (fun xn : pow => lt (fst xn) ar) xl2), and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) (app xl1' xl2))
+++++
intros.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.
intros.

*****
H0 : andl (fun xn : pow => lt (fst xn) ar) xl2
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl1')
xl2 : list pow
a2 : nat
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) (app xl1' xl2))
+++++
trivial.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.
intros.
trivial.

*****
H0 : andl (fun xn : pow => lt (fst xn) ar) xl2
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl1')
xl2 : list pow
a2 : nat
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) (app xl1' xl2))
+++++
split.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.
intros.
trivial.
split.

*****
H0 : andl (fun xn : pow => lt (fst xn) ar) xl2
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl1')
xl2 : list pow
a2 : nat
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
lt x ar
+++++
tauto.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.
intros.
trivial.
split.

*****
H0 : andl (fun xn : pow => lt (fst xn) ar) xl2
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl1')
xl2 : list pow
a2 : nat
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
andl (fun xn : pow => lt (fst xn) ar) (app xl1' xl2)
+++++
idtac.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.
intros.
trivial.
split.
idtac.

*****
H0 : andl (fun xn : pow => lt (fst xn) ar) xl2
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl1')
xl2 : list pow
a2 : nat
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
andl (fun xn : pow => lt (fst xn) ar) (app xl1' xl2)
+++++
apply IH with a1.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.
intros.
trivial.
split.
idtac.
apply IH with a1.

*****
H0 : andl (fun xn : pow => lt (fst xn) ar) xl2
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl1')
xl2 : list pow
a2 : nat
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1'))
+++++
tauto.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].
simpl.
intros.
trivial.
split.
idtac.
apply IH with a1.

*****
H0 : andl (fun xn : pow => lt (fst xn) ar) xl2
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl1')
xl2 : list pow
a2 : nat
IH : forall (a2 : nat) (xl2 : list pow)\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl1')))\n (_ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a2 xl2))),\nandl (fun xn : pow => lt (fst xn) ar)\n (snd (pair (Init.Nat.mul a1 a2) (app xl1' xl2)))
xl1' : list pow
ar,a1,x,n : nat
*****
andl (fun xn : pow => lt (fst xn) ar) (snd (pair a1 xl2))
+++++
tauto.
-----
Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2, pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) -> pWF_mon ar (a1*a2, xl1++xl2).
Proof.
unfold pWF_mon.
unfold pWF_pow.
induction xl1 as [ | [x n] xl1' IH].

*****

*****

+++++
Qed.
-----
Lemma pWF'_app ar ml1 ml2 :\n  pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).

*****
ml1,ml2 : list mon
ar : nat
*****
forall (_ : pWF' ar ml1) (_ : pWF' ar ml2), pWF' ar (app ml1 ml2)
+++++
Proof.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.

*****
ml1,ml2 : list mon
ar : nat
*****
forall (_ : pWF' ar ml1) (_ : pWF' ar ml2), pWF' ar (app ml1 ml2)
+++++
induction ml1 as [ | m1 ml1' IH].
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].

*****
ml2 : list mon
ar : nat
*****
forall (_ : pWF' ar nil) (_ : pWF' ar ml2), pWF' ar (app nil ml2)
+++++
simpl.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.

*****
ml2 : list mon
ar : nat
*****
forall (_ : True) (_ : pWF' ar ml2), pWF' ar ml2
+++++
intros.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.
intros.

*****
H0 : pWF' ar ml2
H : True
ml2 : list mon
ar : nat
*****
pWF' ar ml2
+++++
trivial.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].

*****
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
forall (_ : pWF' ar (cons m1 ml1')) (_ : pWF' ar ml2), pWF' ar (app (cons m1 ml1') ml2)
+++++
simpl.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.

*****
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
forall (_ : and (pWF_mon ar m1) (pWF' ar ml1')) (_ : pWF' ar ml2), and (pWF_mon ar m1) (pWF' ar (app ml1' ml2))
+++++
intros.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.
intros.

*****
H0 : pWF' ar ml2
H : and (pWF_mon ar m1) (pWF' ar ml1')
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
and (pWF_mon ar m1) (pWF' ar (app ml1' ml2))
+++++
trivial.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.
intros.
trivial.

*****
H0 : pWF' ar ml2
H : and (pWF_mon ar m1) (pWF' ar ml1')
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
and (pWF_mon ar m1) (pWF' ar (app ml1' ml2))
+++++
split.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.
intros.
trivial.
split.

*****
H0 : pWF' ar ml2
H : and (pWF_mon ar m1) (pWF' ar ml1')
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
pWF_mon ar m1
+++++
tauto.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.
intros.
trivial.
split.

*****
H0 : pWF' ar ml2
H : and (pWF_mon ar m1) (pWF' ar ml1')
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
pWF' ar (app ml1' ml2)
+++++
idtac.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.
intros.
trivial.
split.
idtac.

*****
H0 : pWF' ar ml2
H : and (pWF_mon ar m1) (pWF' ar ml1')
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
pWF' ar (app ml1' ml2)
+++++
apply IH.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.
intros.
trivial.
split.
idtac.
apply IH.

*****
H0 : pWF' ar ml2
H : and (pWF_mon ar m1) (pWF' ar ml1')
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
pWF' ar ml1'
+++++
tauto.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].
simpl.
intros.
trivial.
split.
idtac.
apply IH.

*****
H0 : pWF' ar ml2
H : and (pWF_mon ar m1) (pWF' ar ml1')
IH : forall (_ : pWF' ar ml1') (_ : pWF' ar ml2), pWF' ar (app ml1' ml2)
ml1',ml2 : list mon
m1 : mon
ar : nat
*****
pWF' ar ml2
+++++
tauto.
-----
Lemma pWF'_app ar ml1 ml2 : pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).
Proof.
induction ml1 as [ | m1 ml1' IH].

*****

*****

+++++
Qed.
-----
Lemma pWF_nth i pl p0 :\n  andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).

*****
p0 : pol
pl : list pol
i : nat
*****
forall (_ : andl pWF pl) (_ : pWF p0), pWF (nth i pl p0)
+++++
Proof.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.

*****
p0 : pol
pl : list pol
i : nat
*****
forall (_ : andl pWF pl) (_ : pWF p0), pWF (nth i pl p0)
+++++
intros.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.

*****
H0 : pWF p0
H : andl pWF pl
p0 : pol
pl : list pol
i : nat
*****
pWF (nth i pl p0)
+++++
revert i.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.

*****
H0 : pWF p0
H : andl pWF pl
p0 : pol
pl : list pol
*****
forall i : nat, pWF (nth i pl p0)
+++++
induction pl.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.

*****
H0 : pWF p0
H : andl pWF nil
p0 : pol
*****
forall i : nat, pWF (nth i nil p0)
+++++
simpl in *.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.

*****
H0 : pWF p0
H : True
p0 : pol
*****
forall i : nat, pWF match i with | O | _ => p0 end
+++++
intros.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.

*****
i : nat
H0 : pWF p0
H : True
p0 : pol
*****
pWF match i with | O | _ => p0 end
+++++
case i.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.

*****
i : nat
H0 : pWF p0
H : True
p0 : pol
*****
pWF p0
+++++
intros.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.
intros.

*****
i : nat
H0 : pWF p0
H : True
p0 : pol
*****
pWF p0
+++++
trivial.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.

*****
i : nat
H0 : pWF p0
H : True
p0 : pol
*****
forall _ : nat, pWF p0
+++++
intros.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.
intros.

*****
i,n : nat
H0 : pWF p0
H : True
p0 : pol
*****
pWF p0
+++++
trivial.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.

*****
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : andl pWF (cons a pl)
p0 : pol
pl : list pol
a : pol
*****
forall i : nat, pWF (nth i (cons a pl) p0)
+++++
simpl in *.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.

*****
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
forall i : nat, pWF match i with | O => a | S m => nth m pl p0 end
+++++
intros.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.

*****
i : nat
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
pWF match i with | O => a | S m => nth m pl p0 end
+++++
case i.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.

*****
i : nat
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
pWF a
+++++
intros.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.
intros.

*****
i : nat
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
pWF a
+++++
trivial.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.
intros.
trivial.

*****
i : nat
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
pWF a
+++++
tauto.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.

*****
i : nat
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
forall n : nat, pWF (nth n pl p0)
+++++
intros.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.
intros.

*****
i,n : nat
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
pWF (nth n pl p0)
+++++
trivial.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.
intros.
trivial.

*****
i,n : nat
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
pWF (nth n pl p0)
+++++
apply IHpl.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.
simpl in *.
intros.
case i.
intros.
trivial.
apply IHpl.

*****
i,n : nat
IHpl : forall (_ : andl pWF pl) (i : nat), pWF (nth i pl p0)
H0 : pWF p0
H : and (pWF a) (andl pWF pl)
p0 : pol
pl : list pol
a : pol
*****
andl pWF pl
+++++
tauto.
-----
Lemma pWF_nth i pl p0 : andl pWF pl -> pWF p0 -> pWF (nth i pl p0).
Proof.
intros.
revert i.
induction pl.

*****

*****

+++++
Qed.
-----
Lemma parity_mon_correct : forall ar m l l1 l2,\n  pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).

*****

*****
forall (ar : nat) (m : mon) (l l1 l2 : list nat) (_ : pWF_mon ar m) (_ : eq (length l) ar), eq (peval_mon m (app l l1)) (peval_mon m (app l l2))
+++++
Proof.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.

*****

*****
forall (ar : nat) (m : mon) (l l1 l2 : list nat) (_ : pWF_mon ar m) (_ : eq (length l) ar), eq (peval_mon m (app l l1)) (peval_mon m (app l l2))
+++++
unfold peval_mon.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.

*****

*****
forall (ar : nat) (m : mon) (l l1 l2 : list nat) (_ : pWF_mon ar m) (_ : eq (length l) ar), eq (Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x (app l l1)) (snd m)))) (Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x (app l l2)) (snd m))))
+++++
unfold peval_pow.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.

*****

*****
forall (ar : nat) (m : mon) (l l1 l2 : list nat) (_ : pWF_mon ar m) (_ : eq (length l) ar), eq (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m))))
+++++
unfold pWF_mon.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.

*****

*****
forall (ar : nat) (m : mon) (l l1 l2 : list nat) (_ : andl (pWF_pow ar) (snd m)) (_ : eq (length l) ar), eq (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m))))
+++++
unfold pWF_pow.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (ar : nat) (m : mon) (l l1 l2 : list nat) (_ : andl (fun xn : pow => lt (fst xn) ar) (snd m)) (_ : eq (length l) ar), eq (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m))))
+++++
intros ar [a xl] l l1 l2 H1 H2.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.

*****
H2 : eq (length l) ar
H1 : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a xl))
l,l1,l2 : list nat
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd (pair a xl))))) (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd (pair a xl)))))
+++++
simpl in *.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.

*****
H2 : eq (length l) ar
H1 : andl (fun xn : pow => lt (fst xn) ar) xl
l,l1,l2 : list nat
xl : list pow
ar,a : nat
*****
eq (Init.Nat.mul a (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl))) (Init.Nat.mul a (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl)))
+++++
f_equal.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.

*****
H2 : eq (length l) ar
H1 : andl (fun xn : pow => lt (fst xn) ar) xl
l,l1,l2 : list nat
xl : list pow
ar,a : nat
*****
eq (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl)) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl))
+++++
f_equal.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.

*****
H2 : eq (length l) ar
H1 : andl (fun xn : pow => lt (fst xn) ar) xl
l,l1,l2 : list nat
xl : list pow
ar,a : nat
*****
eq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl) (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl)
+++++
induction xl as [ | [x n] xl' IH].
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].

*****
H2 : eq (length l) ar
H1 : andl (fun xn : pow => lt (fst xn) ar) nil
l,l1,l2 : list nat
ar,a : nat
*****
eq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) nil) (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) nil)
+++++
simpl in *.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.

*****
H2 : eq (length l) ar
H1 : True
l,l1,l2 : list nat
ar,a : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : andl (fun xn : pow => lt (fst xn) ar) (cons (pair x n) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
eq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (cons (pair x n) xl')) (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (cons (pair x n) xl'))
+++++
simpl in *.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
eq (cons (power (nth x (app l l1) O) n) (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')) (cons (power (nth x (app l l2) O) n) (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl'))
+++++
trivial.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
eq (cons (power (nth x (app l l1) O) n) (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')) (cons (power (nth x (app l l2) O) n) (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl'))
+++++
f_equal.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
eq (power (nth x (app l l1) O) n) (power (nth x (app l l2) O) n)
+++++
idtac.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.
idtac.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
eq (power (nth x (app l l1) O) n) (power (nth x (app l l2) O) n)
+++++
f_equal.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.
idtac.
f_equal.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
eq (nth x (app l l1) O) (nth x (app l l2) O)
+++++
rewrite !app_nth1.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.
idtac.
f_equal.
rewrite !app_nth1.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
eq (nth x l O) (nth x l O)
+++++
trivial.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.
idtac.
f_equal.
rewrite !app_nth1.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
lt x (length l)
+++++
trivial.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.
idtac.
f_equal.
rewrite !app_nth1.
trivial.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
lt x (length l)
+++++
omega.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.
idtac.
f_equal.
rewrite !app_nth1.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
lt x (length l)
+++++
trivial.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.
idtac.
f_equal.
rewrite !app_nth1.
trivial.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
lt x (length l)
+++++
omega.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
f_equal.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\neq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl')\n (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
H2 : eq (length l) ar
H1 : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
l,l1,l2 : list nat
xl' : list pow
ar,a,x,n : nat
*****
eq (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) xl') (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) xl')
+++++
tauto.
-----
Lemma parity_mon_correct : forall ar m l l1 l2, pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).
Proof.
unfold peval_mon.
unfold peval_pow.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] l l1 l2 H1 H2.
simpl in *.
f_equal.
f_equal.
induction xl as [ | [x n] xl' IH].

*****

*****

+++++
Qed.
-----
Lemma parity_correct : forall p l l1 l2,\n  pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).

*****

*****
forall (p : pol) (l l1 l2 : list nat) (_ : pWF p) (_ : eq (length l) (fst p)), eq (peval p (app l l1)) (peval p (app l l2))
+++++
Proof.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.

*****

*****
forall (p : pol) (l l1 l2 : list nat) (_ : pWF p) (_ : eq (length l) (fst p)), eq (peval p (app l l1)) (peval p (app l l2))
+++++
unfold peval.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.

*****

*****
forall (p : pol) (l l1 l2 : list nat) (_ : pWF p) (_ : eq (length l) (fst p)), eq (plusl (map (fun m : mon => peval_mon m (app l l1)) (snd p))) (plusl (map (fun m : mon => peval_mon m (app l l2)) (snd p)))
+++++
unfold peval_mon.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.

*****

*****
forall (p : pol) (l l1 l2 : list nat) (_ : pWF p) (_ : eq (length l) (fst p)), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x (app l l1)) (snd m)))) (snd p))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x (app l l2)) (snd m)))) (snd p)))
+++++
unfold peval_pow.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.

*****

*****
forall (p : pol) (l l1 l2 : list nat) (_ : pWF p) (_ : eq (length l) (fst p)), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (snd p))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) (snd p)))
+++++
unfold pWF.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.

*****

*****
forall (p : pol) (l l1 l2 : list nat) (_ : pWF' (fst p) (snd p)) (_ : eq (length l) (fst p)), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (snd p))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) (snd p)))
+++++
unfold pWF_mon.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.

*****

*****
forall (p : pol) (l l1 l2 : list nat) (_ : pWF' (fst p) (snd p)) (_ : eq (length l) (fst p)), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (snd p))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) (snd p)))
+++++
unfold pWF_pow.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (p : pol) (l l1 l2 : list nat) (_ : pWF' (fst p) (snd p)) (_ : eq (length l) (fst p)), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (snd p))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) (snd p)))
+++++
intros [ar ml] l l1 l2 H1 H2.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.

*****
H2 : eq (length l) (fst (pair ar ml))
H1 : pWF' (fst (pair ar ml)) (snd (pair ar ml))
l,l1,l2 : list nat
ml : list mon
ar : nat
*****
eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (snd (pair ar ml)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) (snd (pair ar ml))))
+++++
simpl in *.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.

*****
H2 : eq (length l) ar
H1 : pWF' ar ml
l,l1,l2 : list nat
ml : list mon
ar : nat
*****
eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) ml)) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) ml))
+++++
f_equal.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.

*****
H2 : eq (length l) ar
H1 : pWF' ar ml
l,l1,l2 : list nat
ml : list mon
ar : nat
*****
eq (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) ml) (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) ml)
+++++
induction ml as [ | m ml' IH].
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].

*****
H2 : eq (length l) ar
H1 : pWF' ar nil
l,l1,l2 : list nat
ar : nat
*****
eq (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) nil) (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) nil)
+++++
simpl in *.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].
simpl in *.

*****
H2 : eq (length l) ar
H1 : True
l,l1,l2 : list nat
ar : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].

*****
IH : forall _ : pWF' ar ml',\neq\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l1) O) (snd x))\n (snd m)))) ml')\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l2) O) (snd x))\n (snd m)))) ml')
H2 : eq (length l) ar
H1 : pWF' ar (cons m ml')
l,l1,l2 : list nat
ml' : list mon
m : mon
ar : nat
*****
eq (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (cons m ml')) (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) (cons m ml'))
+++++
simpl in *.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].
simpl in *.

*****
IH : forall _ : pWF' ar ml',\neq\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l1) O) (snd x))\n (snd m)))) ml')\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l2) O) (snd x))\n (snd m)))) ml')
H2 : eq (length l) ar
H1 : and (pWF_mon ar m) (pWF' ar ml')
l,l1,l2 : list nat
ml' : list mon
m : mon
ar : nat
*****
eq (cons (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) ml')) (cons (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) ml'))
+++++
trivial.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].
simpl in *.
trivial.

*****
IH : forall _ : pWF' ar ml',\neq\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l1) O) (snd x))\n (snd m)))) ml')\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l2) O) (snd x))\n (snd m)))) ml')
H2 : eq (length l) ar
H1 : and (pWF_mon ar m) (pWF' ar ml')
l,l1,l2 : list nat
ml' : list mon
m : mon
ar : nat
*****
eq (cons (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) ml')) (cons (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) ml'))
+++++
f_equal.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].
simpl in *.
trivial.
f_equal.

*****
IH : forall _ : pWF' ar ml',\neq\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l1) O) (snd x))\n (snd m)))) ml')\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l2) O) (snd x))\n (snd m)))) ml')
H2 : eq (length l) ar
H1 : and (pWF_mon ar m) (pWF' ar ml')
l,l1,l2 : list nat
ml' : list mon
m : mon
ar : nat
*****
eq (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m))))
+++++
idtac.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].
simpl in *.
trivial.
f_equal.
idtac.

*****
IH : forall _ : pWF' ar ml',\neq\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l1) O) (snd x))\n (snd m)))) ml')\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l2) O) (snd x))\n (snd m)))) ml')
H2 : eq (length l) ar
H1 : and (pWF_mon ar m) (pWF' ar ml')
l,l1,l2 : list nat
ml' : list mon
m : mon
ar : nat
*****
eq (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) (Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m))))
+++++
apply parity_mon_correct with ar.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].
simpl in *.
trivial.
f_equal.
idtac.
apply parity_mon_correct with ar.

*****
IH : forall _ : pWF' ar ml',\neq\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l1) O) (snd x))\n (snd m)))) ml')\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l2) O) (snd x))\n (snd m)))) ml')
H2 : eq (length l) ar
H1 : and (pWF_mon ar m) (pWF' ar ml')
l,l1,l2 : list nat
ml' : list mon
m : mon
ar : nat
*****
pWF_mon ar m
+++++
tauto.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].
simpl in *.
trivial.
f_equal.
idtac.
apply parity_mon_correct with ar.

*****
IH : forall _ : pWF' ar ml',\neq\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l1) O) (snd x))\n (snd m)))) ml')\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l2) O) (snd x))\n (snd m)))) ml')
H2 : eq (length l) ar
H1 : and (pWF_mon ar m) (pWF' ar ml')
l,l1,l2 : list nat
ml' : list mon
m : mon
ar : nat
*****
eq (length l) ar
+++++
tauto.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].
simpl in *.
trivial.
f_equal.

*****
IH : forall _ : pWF' ar ml',\neq\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l1) O) (snd x))\n (snd m)))) ml')\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map\n (fun x : pow => power (nth (fst x) (app l l2) O) (snd x))\n (snd m)))) ml')
H2 : eq (length l) ar
H1 : and (pWF_mon ar m) (pWF' ar ml')
l,l1,l2 : list nat
ml' : list mon
m : mon
ar : nat
*****
eq (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l1) O) (snd x)) (snd m)))) ml') (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) (app l l2) O) (snd x)) (snd m)))) ml')
+++++
tauto.
-----
Lemma parity_correct : forall p l l1 l2, pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar ml] l l1 l2 H1 H2.
simpl in *.
f_equal.
induction ml as [ | m ml' IH].

*****

*****

+++++
Qed.
-----
Definition pcst (ar a:nat) : pol :=\n  (ar, [(a,nil)]).
-----
Lemma parity_pcst ar a :\n  parity (pcst ar a) = ar.
-----
Lemma parity_pcst ar a : parity (pcst ar a) = ar.

*****
ar,a : nat
*****
eq (fst (pcst ar a)) ar
+++++
Proof.
-----
Lemma parity_pcst ar a : parity (pcst ar a) = ar.
Proof.

*****
ar,a : nat
*****
eq (fst (pcst ar a)) ar
+++++
trivial.
-----
Lemma parity_pcst ar a : parity (pcst ar a) = ar.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma pWF_pcst ar a : pWF (pcst ar a).
-----
Lemma pWF_pcst ar a : pWF (pcst ar a).

*****
ar,a : nat
*****
pWF (pcst ar a)
+++++
Proof.
-----
Lemma pWF_pcst ar a : pWF (pcst ar a).
Proof.

*****
ar,a : nat
*****
pWF (pcst ar a)
+++++
compute.
-----
Lemma pWF_pcst ar a : pWF (pcst ar a).
Proof.
compute.

*****
ar,a : nat
*****
and True True
+++++
intros.
-----
Lemma pWF_pcst ar a : pWF (pcst ar a).
Proof.
compute.
intros.

*****
ar,a : nat
*****
and True True
+++++
tauto.
-----
Lemma pWF_pcst ar a : pWF (pcst ar a).
Proof.
compute.
intros.
tauto.

*****

*****

+++++
Qed.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.

*****

*****
forall (ar k : nat) (l : list nat), eq (peval (pcst ar k) l) k
+++++
Proof.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.
Proof.

*****

*****
forall (ar k : nat) (l : list nat), eq (peval (pcst ar k) l) k
+++++
unfold peval.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.
Proof.
unfold peval.

*****

*****
forall (ar k : nat) (l : list nat), eq (plusl (map (fun m : mon => peval_mon m l) (snd (pcst ar k)))) k
+++++
unfold peval_mon.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.
Proof.
unfold peval.
unfold peval_mon.

*****

*****
forall (ar k : nat) (l : list nat), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l) (snd m)))) (snd (pcst ar k)))) k
+++++
unfold peval_pow.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.

*****

*****
forall (ar k : nat) (l : list nat), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pcst ar k)))) k
+++++
simpl.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
simpl.

*****

*****
forall (_ : nat) (k : nat) (_ : list nat), eq (Init.Nat.add (Init.Nat.mul k (S O)) O) k
+++++
intros.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
simpl.
intros.

*****
l : list nat
ar,k : nat
*****
eq (Init.Nat.add (Init.Nat.mul k (S O)) O) k
+++++
omega.
-----
Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
simpl.
intros.
omega.

*****

*****

+++++
Qed.
-----
Definition pproj (ar i:nat) : pol :=\n  (ar,[(1,[(i,1)])]).
-----
Lemma parity_pproj n i :\n  parity (pproj n i) = n.
-----
Lemma parity_pproj n i : parity (pproj n i) = n.

*****
n,i : nat
*****
eq (fst (pproj n i)) n
+++++
Proof.
-----
Lemma parity_pproj n i : parity (pproj n i) = n.
Proof.

*****
n,i : nat
*****
eq (fst (pproj n i)) n
+++++
trivial.
-----
Lemma parity_pproj n i : parity (pproj n i) = n.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma pWF_pproj ar i : i < ar -> pWF (pproj ar i).
-----
Lemma pWF_pproj ar i : i < ar -> pWF (pproj ar i).

*****
ar,i : nat
*****
forall _ : lt i ar, pWF (pproj ar i)
+++++
Proof.
-----
Lemma pWF_pproj ar i : i < ar -> pWF (pproj ar i).
Proof.

*****
ar,i : nat
*****
forall _ : lt i ar, pWF (pproj ar i)
+++++
compute.
-----
Lemma pWF_pproj ar i : i < ar -> pWF (pproj ar i).
Proof.
compute.

*****
ar,i : nat
*****
forall _ : le (S i) ar, and (and (le (S i) ar) True) True
+++++
intros.
-----
Lemma pWF_pproj ar i : i < ar -> pWF (pproj ar i).
Proof.
compute.
intros.

*****
H : le (S i) ar
ar,i : nat
*****
and (and (le (S i) ar) True) True
+++++
tauto.
-----
Lemma pWF_pproj ar i : i < ar -> pWF (pproj ar i).
Proof.
compute.
intros.
tauto.

*****

*****

+++++
Qed.
-----
Lemma pproj_correct : forall ar i l,\n peval (pproj ar i) l = nth i l 0.
-----
Lemma pproj_correct : forall ar i l, peval (pproj ar i) l = nth i l 0.

*****

*****
forall (ar i : nat) (l : list nat), eq (peval (pproj ar i) l) (nth i l O)
+++++
Proof.
-----
Lemma pproj_correct : forall ar i l, peval (pproj ar i) l = nth i l 0.
Proof.

*****

*****
forall (ar i : nat) (l : list nat), eq (peval (pproj ar i) l) (nth i l O)
+++++
unfold peval.
-----
Lemma pproj_correct : forall ar i l, peval (pproj ar i) l = nth i l 0.
Proof.
unfold peval.

*****

*****
forall (ar i : nat) (l : list nat), eq (plusl (map (fun m : mon => peval_mon m l) (snd (pproj ar i)))) (nth i l O)
+++++
unfold peval_mon.
-----
Lemma pproj_correct : forall ar i l, peval (pproj ar i) l = nth i l 0.
Proof.
unfold peval.
unfold peval_mon.

*****

*****
forall (ar i : nat) (l : list nat), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l) (snd m)))) (snd (pproj ar i)))) (nth i l O)
+++++
unfold peval_pow.
-----
Lemma pproj_correct : forall ar i l, peval (pproj ar i) l = nth i l 0.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.

*****

*****
forall (ar i : nat) (l : list nat), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pproj ar i)))) (nth i l O)
+++++
simpl.
-----
Lemma pproj_correct : forall ar i l, peval (pproj ar i) l = nth i l 0.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
simpl.

*****

*****
forall (_ : nat) (i : nat) (l : list nat), eq (Init.Nat.add (Init.Nat.add (Init.Nat.mul (Init.Nat.mul (nth i l O) (S O)) (S O)) O) O) (nth i l O)
+++++
intros.
-----
Lemma pproj_correct : forall ar i l, peval (pproj ar i) l = nth i l 0.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
simpl.
intros.

*****
l : list nat
ar,i : nat
*****
eq (Init.Nat.add (Init.Nat.add (Init.Nat.mul (Init.Nat.mul (nth i l O) (S O)) (S O)) O) O) (nth i l O)
+++++
omega.
-----
Lemma pproj_correct : forall ar i l, peval (pproj ar i) l = nth i l 0.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
simpl.
intros.
omega.

*****

*****

+++++
Qed.
-----
Definition pscalar_mon (n:nat)(m:mon) : mon :=\n  (n * fst m, snd m).
-----
Definition pscalar (n:nat)(p:pol) : pol :=\n  (fst p, map (pscalar_mon n) (snd p)).
-----
Lemma parity_pscalar n p :\n  parity (pscalar n p) = parity p.
-----
Lemma parity_pscalar n p : parity (pscalar n p) = parity p.

*****
p : pol
n : nat
*****
eq (fst (pscalar n p)) (fst p)
+++++
Proof.
-----
Lemma parity_pscalar n p : parity (pscalar n p) = parity p.
Proof.

*****
p : pol
n : nat
*****
eq (fst (pscalar n p)) (fst p)
+++++
trivial.
-----
Lemma parity_pscalar n p : parity (pscalar n p) = parity p.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma pWF_pscalar : forall n p,\n  pWF p -> pWF (pscalar n p).
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).

*****

*****
forall (n : nat) (p : pol) (_ : pWF p), pWF (pscalar n p)
+++++
Proof.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.

*****

*****
forall (n : nat) (p : pol) (_ : pWF p), pWF (pscalar n p)
+++++
unfold pWF.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.

*****

*****
forall (n : nat) (p : pol) (_ : pWF' (fst p) (snd p)), pWF' (fst (pscalar n p)) (snd (pscalar n p))
+++++
unfold pWF_mon.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.

*****

*****
forall (n : nat) (p : pol) (_ : pWF' (fst p) (snd p)), pWF' (fst (pscalar n p)) (snd (pscalar n p))
+++++
unfold pWF_pow.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (n : nat) (p : pol) (_ : pWF' (fst p) (snd p)), pWF' (fst (pscalar n p)) (snd (pscalar n p))
+++++
intros n [ar ml] H.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros n [ar ml] H.

*****
H : pWF' (fst (pair ar ml)) (snd (pair ar ml))
ml : list mon
n,ar : nat
*****
pWF' (fst (pscalar n (pair ar ml))) (snd (pscalar n (pair ar ml)))
+++++
induction ml.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros n [ar ml] H.
induction ml.

*****
H : pWF' (fst (pair ar nil)) (snd (pair ar nil))
n,ar : nat
*****
pWF' (fst (pscalar n (pair ar nil))) (snd (pscalar n (pair ar nil)))
+++++
simpl in *.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros n [ar ml] H.
induction ml.
simpl in *.

*****
H : True
n,ar : nat
*****
True
+++++
trivial.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros n [ar ml] H.
induction ml.

*****
IHml : forall _ : pWF' (fst (pair ar ml)) (snd (pair ar ml)),\npWF' (fst (pscalar n (pair ar ml))) (snd (pscalar n (pair ar ml)))
H : pWF' (fst (pair ar (cons a ml))) (snd (pair ar (cons a ml)))
ml : list mon
a : mon
n,ar : nat
*****
pWF' (fst (pscalar n (pair ar (cons a ml)))) (snd (pscalar n (pair ar (cons a ml))))
+++++
simpl in *.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros n [ar ml] H.
induction ml.
simpl in *.

*****
IHml : forall _ : pWF' ar ml, pWF' ar (map (pscalar_mon n) ml)
H : and (pWF_mon ar a) (pWF' ar ml)
ml : list mon
a : mon
n,ar : nat
*****
and (pWF_mon ar (pscalar_mon n a)) (pWF' ar (map (pscalar_mon n) ml))
+++++
trivial.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros n [ar ml] H.
induction ml.
simpl in *.
trivial.

*****
IHml : forall _ : pWF' ar ml, pWF' ar (map (pscalar_mon n) ml)
H : and (pWF_mon ar a) (pWF' ar ml)
ml : list mon
a : mon
n,ar : nat
*****
and (pWF_mon ar (pscalar_mon n a)) (pWF' ar (map (pscalar_mon n) ml))
+++++
tauto.
-----
Lemma pWF_pscalar : forall n p, pWF p -> pWF (pscalar n p).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros n [ar ml] H.
induction ml.

*****

*****

+++++
Qed.
-----
Lemma pscalar_mon_correct : forall n m l,\n  peval_mon (pscalar_mon n m) l = n * peval_mon m l.
-----
Lemma pscalar_mon_correct : forall n m l, peval_mon (pscalar_mon n m) l = n * peval_mon m l.

*****

*****
forall (n : nat) (m : mon) (l : list nat), eq (peval_mon (pscalar_mon n m) l) (Init.Nat.mul n (peval_mon m l))
+++++
Proof.
-----
Lemma pscalar_mon_correct : forall n m l, peval_mon (pscalar_mon n m) l = n * peval_mon m l.
Proof.

*****

*****
forall (n : nat) (m : mon) (l : list nat), eq (peval_mon (pscalar_mon n m) l) (Init.Nat.mul n (peval_mon m l))
+++++
unfold peval_mon.
-----
Lemma pscalar_mon_correct : forall n m l, peval_mon (pscalar_mon n m) l = n * peval_mon m l.
Proof.
unfold peval_mon.

*****

*****
forall (n : nat) (m : mon) (l : list nat), eq (Init.Nat.mul (fst (pscalar_mon n m)) (multl (map (fun x : pow => peval_pow x l) (snd (pscalar_mon n m))))) (Init.Nat.mul n (Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l) (snd m)))))
+++++
intros n [a xl] l.
-----
Lemma pscalar_mon_correct : forall n m l, peval_mon (pscalar_mon n m) l = n * peval_mon m l.
Proof.
unfold peval_mon.
intros n [a xl] l.

*****
l : list nat
xl : list pow
n,a : nat
*****
eq (Init.Nat.mul (fst (pscalar_mon n (pair a xl))) (multl (map (fun x : pow => peval_pow x l) (snd (pscalar_mon n (pair a xl)))))) (Init.Nat.mul n (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => peval_pow x l) (snd (pair a xl))))))
+++++
simpl.
-----
Lemma pscalar_mon_correct : forall n m l, peval_mon (pscalar_mon n m) l = n * peval_mon m l.
Proof.
unfold peval_mon.
intros n [a xl] l.
simpl.

*****
l : list nat
xl : list pow
n,a : nat
*****
eq (Init.Nat.mul (Init.Nat.mul n a) (multl (map (fun x : pow => peval_pow x l) xl))) (Init.Nat.mul n (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x l) xl))))
+++++
ring.
-----
Lemma pscalar_mon_correct : forall n m l, peval_mon (pscalar_mon n m) l = n * peval_mon m l.
Proof.
unfold peval_mon.
intros n [a xl] l.
simpl.
ring.

*****

*****

+++++
Qed.
-----
Lemma map_pscalar_mon n ml l :\n  plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) =\n  n * plusl (map (fun m => peval_mon m l) ml).
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).

*****
l : list nat
ml : list mon
n : nat
*****
eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml)) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) ml)))
+++++
Proof.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.

*****
l : list nat
ml : list mon
n : nat
*****
eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml)) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) ml)))
+++++
induction ml.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.
induction ml.

*****
l : list nat
n : nat
*****
eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) nil)) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) nil)))
+++++
simpl.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.
induction ml.
simpl.

*****
l : list nat
n : nat
*****
eq O (Init.Nat.mul n O)
+++++
trivial.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.
induction ml.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) ml)))
l : list nat
ml : list mon
a : mon
n : nat
*****
eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) (cons a ml))) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) (cons a ml))))
+++++
simpl.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.
induction ml.
simpl.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) ml)))
l : list nat
ml : list mon
a : mon
n : nat
*****
eq (Init.Nat.add (peval_mon (pscalar_mon n a) l) (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) ml))))
+++++
trivial.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.
induction ml.
simpl.
trivial.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) ml)))
l : list nat
ml : list mon
a : mon
n : nat
*****
eq (Init.Nat.add (peval_mon (pscalar_mon n a) l) (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) ml))))
+++++
rewrite pscalar_mon_correct.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.
induction ml.
simpl.
trivial.
rewrite pscalar_mon_correct.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) ml)))
l : list nat
ml : list mon
a : mon
n : nat
*****
eq (Init.Nat.add (Init.Nat.mul n (peval_mon a l)) (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) ml))))
+++++
rewrite IHml.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.
induction ml.
simpl.
trivial.
rewrite pscalar_mon_correct.
rewrite IHml.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon (pscalar_mon n m) l) ml))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) ml)))
l : list nat
ml : list mon
a : mon
n : nat
*****
eq (Init.Nat.add (Init.Nat.mul n (peval_mon a l)) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) ml)))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) ml))))
+++++
ring.
-----
Lemma map_pscalar_mon n ml l : plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) = n * plusl (map (fun m => peval_mon m l) ml).
Proof.
induction ml.

*****

*****

+++++
Qed.
-----
Lemma pscalar_correct : forall n p l,\n  peval (pscalar n p) l = n * peval p l.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.

*****

*****
forall (n : nat) (p : pol) (l : list nat), eq (peval (pscalar n p) l) (Init.Nat.mul n (peval p l))
+++++
Proof.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.

*****

*****
forall (n : nat) (p : pol) (l : list nat), eq (peval (pscalar n p) l) (Init.Nat.mul n (peval p l))
+++++
unfold peval.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.

*****

*****
forall (n : nat) (p : pol) (l : list nat), eq (plusl (map (fun m : mon => peval_mon m l) (snd (pscalar n p)))) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) (snd p))))
+++++
unfold pscalar.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.

*****

*****
forall (n : nat) (p : pol) (l : list nat), eq (plusl (map (fun m : mon => peval_mon m l) (snd (pair (fst p) (map (pscalar_mon n) (snd p)))))) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) (snd p))))
+++++
intros n [ar pl] l.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.

*****
l : list nat
pl : list mon
n,ar : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (snd (pair (fst (pair ar pl)) (map (pscalar_mon n) (snd (pair ar pl))))))) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) (snd (pair ar pl)))))
+++++
induction pl.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.

*****
l : list nat
n,ar : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (snd (pair (fst (pair ar nil)) (map (pscalar_mon n) (snd (pair ar nil))))))) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) (snd (pair ar nil)))))
+++++
simpl in *.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.
simpl in *.

*****
l : list nat
n,ar : nat
*****
eq O (Init.Nat.mul n O)
+++++
trivial.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.

*****
IHpl : eq\n (plusl\n (map (fun m : mon => peval_mon m l)\n (snd\n (pair (fst (pair ar pl))\n (map (pscalar_mon n) (snd (pair ar pl)))))))\n (Init.Nat.mul n\n (plusl (map (fun m : mon => peval_mon m l) (snd (pair ar pl)))))
l : list nat
pl : list mon
a : mon
n,ar : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (snd (pair (fst (pair ar (cons a pl))) (map (pscalar_mon n) (snd (pair ar (cons a pl)))))))) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) (snd (pair ar (cons a pl))))))
+++++
simpl in *.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.
simpl in *.

*****
IHpl : eq\n (plusl (map (fun m : mon => peval_mon m l) (map (pscalar_mon n) pl)))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) pl)))
l : list nat
pl : list mon
a : mon
n,ar : nat
*****
eq (Init.Nat.add (peval_mon (pscalar_mon n a) l) (plusl (map (fun m : mon => peval_mon m l) (map (pscalar_mon n) pl)))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) pl))))
+++++
trivial.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.
simpl in *.
trivial.

*****
IHpl : eq\n (plusl (map (fun m : mon => peval_mon m l) (map (pscalar_mon n) pl)))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) pl)))
l : list nat
pl : list mon
a : mon
n,ar : nat
*****
eq (Init.Nat.add (peval_mon (pscalar_mon n a) l) (plusl (map (fun m : mon => peval_mon m l) (map (pscalar_mon n) pl)))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) pl))))
+++++
rewrite map_map in *.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.
simpl in *.
trivial.
rewrite map_map in *.

*****
IHpl : eq (plusl (map (fun x : mon => peval_mon (pscalar_mon n x) l) pl))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) pl)))
l : list nat
pl : list mon
a : mon
n,ar : nat
*****
eq (Init.Nat.add (peval_mon (pscalar_mon n a) l) (plusl (map (fun x : mon => peval_mon (pscalar_mon n x) l) pl))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) pl))))
+++++
rewrite pscalar_mon_correct.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.
simpl in *.
trivial.
rewrite map_map in *.
rewrite pscalar_mon_correct.

*****
IHpl : eq (plusl (map (fun x : mon => peval_mon (pscalar_mon n x) l) pl))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) pl)))
l : list nat
pl : list mon
a : mon
n,ar : nat
*****
eq (Init.Nat.add (Init.Nat.mul n (peval_mon a l)) (plusl (map (fun x : mon => peval_mon (pscalar_mon n x) l) pl))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) pl))))
+++++
simpl in IHpl.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.
simpl in *.
trivial.
rewrite map_map in *.
rewrite pscalar_mon_correct.
simpl in IHpl.

*****
IHpl : eq (plusl (map (fun x : mon => peval_mon (pscalar_mon n x) l) pl))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) pl)))
l : list nat
pl : list mon
a : mon
n,ar : nat
*****
eq (Init.Nat.add (Init.Nat.mul n (peval_mon a l)) (plusl (map (fun x : mon => peval_mon (pscalar_mon n x) l) pl))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) pl))))
+++++
rewrite IHpl.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.
simpl in *.
trivial.
rewrite map_map in *.
rewrite pscalar_mon_correct.
simpl in IHpl.
rewrite IHpl.

*****
IHpl : eq (plusl (map (fun x : mon => peval_mon (pscalar_mon n x) l) pl))\n (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) pl)))
l : list nat
pl : list mon
a : mon
n,ar : nat
*****
eq (Init.Nat.add (Init.Nat.mul n (peval_mon a l)) (Init.Nat.mul n (plusl (map (fun m : mon => peval_mon m l) pl)))) (Init.Nat.mul n (Init.Nat.add (peval_mon a l) (plusl (map (fun m : mon => peval_mon m l) pl))))
+++++
ring.
-----
Lemma pscalar_correct : forall n p l, peval (pscalar n p) l = n * peval p l.
Proof.
unfold peval.
unfold pscalar.
intros n [ar pl] l.
induction pl.

*****

*****

+++++
Qed.
-----
Definition pplus (p1 p2:pol) : pol :=\n  (max (fst p1) (fst p2), snd p1 ++ snd p2).
-----
Lemma parity_pplus : forall p1 p2,\n  parity (pplus p1 p2) = max (parity p1) (parity p2).
-----
Lemma parity_pplus : forall p1 p2, parity (pplus p1 p2) = max (parity p1) (parity p2).

*****

*****
forall p1 p2 : pol, eq (fst (pplus p1 p2)) (Init.Nat.max (fst p1) (fst p2))
+++++
Proof.
-----
Lemma parity_pplus : forall p1 p2, parity (pplus p1 p2) = max (parity p1) (parity p2).
Proof.

*****

*****
forall p1 p2 : pol, eq (fst (pplus p1 p2)) (Init.Nat.max (fst p1) (fst p2))
+++++
intros [ar1 ml1] [ar2 ml2].
-----
Lemma parity_pplus : forall p1 p2, parity (pplus p1 p2) = max (parity p1) (parity p2).
Proof.
intros [ar1 ml1] [ar2 ml2].

*****
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
eq (fst (pplus (pair ar1 ml1) (pair ar2 ml2))) (Init.Nat.max (fst (pair ar1 ml1)) (fst (pair ar2 ml2)))
+++++
trivial.
-----
Lemma parity_pplus : forall p1 p2, parity (pplus p1 p2) = max (parity p1) (parity p2).
Proof.
intros [ar1 ml1] [ar2 ml2].
trivial.

*****

*****

+++++
Qed.
-----
Lemma pWF_pplus : forall p1 p2,\n  pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).

*****

*****
forall (p1 p2 : pol) (_ : pWF p1) (_ : pWF p2), pWF (pplus p1 p2)
+++++
Proof.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.

*****

*****
forall (p1 p2 : pol) (_ : pWF p1) (_ : pWF p2), pWF (pplus p1 p2)
+++++
unfold pWF.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.

*****

*****
forall (p1 p2 : pol) (_ : pWF' (fst p1) (snd p1)) (_ : pWF' (fst p2) (snd p2)), pWF' (fst (pplus p1 p2)) (snd (pplus p1 p2))
+++++
unfold pWF_mon.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.

*****

*****
forall (p1 p2 : pol) (_ : pWF' (fst p1) (snd p1)) (_ : pWF' (fst p2) (snd p2)), pWF' (fst (pplus p1 p2)) (snd (pplus p1 p2))
+++++
unfold pWF_pow.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (p1 p2 : pol) (_ : pWF' (fst p1) (snd p1)) (_ : pWF' (fst p2) (snd p2)), pWF' (fst (pplus p1 p2)) (snd (pplus p1 p2))
+++++
intros [ar1 ml1] [ar2 ml2] H1 H2.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.

*****
H2 : pWF' (fst (pair ar2 ml2)) (snd (pair ar2 ml2))
H1 : pWF' (fst (pair ar1 ml1)) (snd (pair ar1 ml1))
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
pWF' (fst (pplus (pair ar1 ml1) (pair ar2 ml2))) (snd (pplus (pair ar1 ml1) (pair ar2 ml2)))
+++++
simpl in *.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.

*****
H2 : pWF' ar2 ml2
H1 : pWF' ar1 ml1
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (app ml1 ml2)
+++++
induction ml1 as [ | m1 ml1' IH].
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].

*****
H2 : pWF' ar2 ml2
H1 : pWF' ar1 nil
ml2 : list mon
ar1,ar2 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (app nil ml2)
+++++
simpl in *.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.

*****
H2 : pWF' ar2 ml2
H1 : True
ml2 : list mon
ar1,ar2 : nat
*****
pWF' (Init.Nat.max ar1 ar2) ml2
+++++
apply pWF'_le with ar2.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
apply pWF'_le with ar2.

*****
H2 : pWF' ar2 ml2
H1 : True
ml2 : list mon
ar1,ar2 : nat
*****
le ar2 (Init.Nat.max ar1 ar2)
+++++
auto with arith.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
apply pWF'_le with ar2.

*****
H2 : pWF' ar2 ml2
H1 : True
ml2 : list mon
ar1,ar2 : nat
*****
pWF' ar2 ml2
+++++
auto with arith.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].

*****
IH : forall _ : pWF' ar1 ml1', pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
H2 : pWF' ar2 ml2
H1 : pWF' ar1 (cons m1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (app (cons m1 ml1') ml2)
+++++
simpl in *.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.

*****
IH : forall _ : pWF' ar1 ml1', pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
and (pWF_mon (Init.Nat.max ar1 ar2) m1) (pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2))
+++++
split.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
split.

*****
IH : forall _ : pWF' ar1 ml1', pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF_mon (Init.Nat.max ar1 ar2) m1
+++++
idtac.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
split.
idtac.

*****
IH : forall _ : pWF' ar1 ml1', pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF_mon (Init.Nat.max ar1 ar2) m1
+++++
apply pWF_mon_le with ar1.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
split.
idtac.
apply pWF_mon_le with ar1.

*****
IH : forall _ : pWF' ar1 ml1', pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
le ar1 (Init.Nat.max ar1 ar2)
+++++
auto with arith.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
split.
idtac.
apply pWF_mon_le with ar1.

*****
IH : forall _ : pWF' ar1 ml1', pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF_mon ar1 m1
+++++
auto with arith.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
split.
idtac.
apply pWF_mon_le with ar1.
auto with arith.

*****
IH : forall _ : pWF' ar1 ml1', pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF_mon ar1 m1
+++++
tauto.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
split.

*****
IH : forall _ : pWF' ar1 ml1', pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (app ml1' ml2)
+++++
tauto.
-----
Lemma pWF_pplus : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pplus p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH].

*****

*****

+++++
Qed.
-----
Lemma pplus_correct : forall p1 p2 l,\n peval (pplus p1 p2) l = peval p1 l + peval p2 l.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.

*****

*****
forall (p1 p2 : pol) (l : list nat), eq (peval (pplus p1 p2) l) (Init.Nat.add (peval p1 l) (peval p2 l))
+++++
Proof.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.

*****

*****
forall (p1 p2 : pol) (l : list nat), eq (peval (pplus p1 p2) l) (Init.Nat.add (peval p1 l) (peval p2 l))
+++++
unfold peval.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.

*****

*****
forall (p1 p2 : pol) (l : list nat), eq (plusl (map (fun m : mon => peval_mon m l) (snd (pplus p1 p2)))) (Init.Nat.add (plusl (map (fun m : mon => peval_mon m l) (snd p1))) (plusl (map (fun m : mon => peval_mon m l) (snd p2))))
+++++
unfold peval_mon.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.

*****

*****
forall (p1 p2 : pol) (l : list nat), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l) (snd m)))) (snd (pplus p1 p2)))) (Init.Nat.add (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l) (snd m)))) (snd p1))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l) (snd m)))) (snd p2))))
+++++
unfold peval_pow.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.

*****

*****
forall (p1 p2 : pol) (l : list nat), eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pplus p1 p2)))) (Init.Nat.add (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd p1))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd p2))))
+++++
intros [ar1 ml1] [ar2 ml2] l.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.

*****
l : list nat
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pplus (pair ar1 ml1) (pair ar2 ml2))))) (Init.Nat.add (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pair ar1 ml1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pair ar2 ml2)))))
+++++
induction ml1 as [ | m1 ml1' IH].
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].

*****
l : list nat
ml2 : list mon
ar1,ar2 : nat
*****
eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pplus (pair ar1 nil) (pair ar2 ml2))))) (Init.Nat.add (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pair ar1 nil)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pair ar2 ml2)))))
+++++
simpl in *.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].
simpl in *.

*****
l : list nat
ml2 : list mon
ar1,ar2 : nat
*****
eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml2)) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml2))
+++++
trivial.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].

*****
IH : eq\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m))))\n (snd (pplus (pair ar1 ml1') (pair ar2 ml2)))))\n (Init.Nat.add\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) (snd (pair ar1 ml1'))))\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) (snd (pair ar2 ml2)))))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pplus (pair ar1 (cons m1 ml1')) (pair ar2 ml2))))) (Init.Nat.add (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pair ar1 (cons m1 ml1'))))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (snd (pair ar2 ml2)))))
+++++
simpl in *.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].
simpl in *.

*****
IH : eq\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) (app ml1' ml2)))\n (Init.Nat.add\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml1'))\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (app ml1' ml2)))) (Init.Nat.add (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml1'))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml2)))
+++++
trivial.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
trivial.

*****
IH : eq\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) (app ml1' ml2)))\n (Init.Nat.add\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml1'))\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (app ml1' ml2)))) (Init.Nat.add (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml1'))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml2)))
+++++
unfold peval in IH.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
trivial.
unfold peval in IH.

*****
IH : eq\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) (app ml1' ml2)))\n (Init.Nat.add\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml1'))\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (app ml1' ml2)))) (Init.Nat.add (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml1'))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml2)))
+++++
unfold pplus in IH.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
trivial.
unfold peval in IH.
unfold pplus in IH.

*****
IH : eq\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) (app ml1' ml2)))\n (Init.Nat.add\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml1'))\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) (app ml1' ml2)))) (Init.Nat.add (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml1'))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml2)))
+++++
rewrite IH.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].
simpl in *.
trivial.
unfold peval in IH.
unfold pplus in IH.
rewrite IH.

*****
IH : eq\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) (app ml1' ml2)))\n (Init.Nat.add\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml1'))\n (plusl\n (map\n (fun m : mon =>\n Init.Nat.mul (fst m)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m)))) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (Init.Nat.add (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml1')) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml2)))) (Init.Nat.add (Init.Nat.add (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml1'))) (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m)))) ml2)))
+++++
ring.
-----
Lemma pplus_correct : forall p1 p2 l, peval (pplus p1 p2) l = peval p1 l + peval p2 l.
Proof.
unfold peval.
unfold peval_mon.
unfold peval_pow.
intros [ar1 ml1] [ar2 ml2] l.
induction ml1 as [ | m1 ml1' IH].

*****

*****

+++++
Qed.
-----
Definition pplusl (pl:list pol) : pol :=\n  fold_right pplus (pcst 0 0) pl.
-----
Lemma parity_pplusl : forall pl,\n  parity (pplusl pl) = maxl (map parity pl).
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).

*****

*****
forall pl : list pol, eq (fst (pplusl pl)) (maxl (map fst pl))
+++++
Proof.
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).
Proof.

*****

*****
forall pl : list pol, eq (fst (pplusl pl)) (maxl (map fst pl))
+++++
induction pl.
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).
Proof.
induction pl.

*****

*****
eq (fst (pplusl nil)) (maxl (map fst nil))
+++++
trivial.
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).
Proof.
induction pl.

*****
IHpl : eq (fst (pplusl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (fst (pplusl (cons a pl))) (maxl (map fst (cons a pl)))
+++++
trivial.
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).
Proof.
induction pl.
trivial.

*****
IHpl : eq (fst (pplusl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (fst (pplusl (cons a pl))) (maxl (map fst (cons a pl)))
+++++
simpl pplusl.
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).
Proof.
induction pl.
trivial.
simpl pplusl.

*****
IHpl : eq (fst (pplusl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (fst (pplus a (pplusl pl))) (maxl (map fst (cons a pl)))
+++++
rewrite parity_pplus.
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).
Proof.
induction pl.
trivial.
simpl pplusl.
rewrite parity_pplus.

*****
IHpl : eq (fst (pplusl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (Init.Nat.max (fst a) (fst (pplusl pl))) (maxl (map fst (cons a pl)))
+++++
rewrite IHpl.
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).
Proof.
induction pl.
trivial.
simpl pplusl.
rewrite parity_pplus.
rewrite IHpl.

*****
IHpl : eq (fst (pplusl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (Init.Nat.max (fst a) (maxl (map fst pl))) (maxl (map fst (cons a pl)))
+++++
trivial.
-----
Lemma parity_pplusl : forall pl, parity (pplusl pl) = maxl (map parity pl).
Proof.
induction pl.

*****

*****

+++++
Qed.
-----
Definition pWF_pplusl : forall pl,\n  andl pWF pl -> pWF (pplusl pl).
-----
Definition pWF_pplusl : forall pl, andl pWF pl -> pWF (pplusl pl).

*****

*****
forall (pl : list pol) (_ : andl pWF pl), pWF (pplusl pl)
+++++
Proof.
-----
Definition pWF_pplusl : forall pl, andl pWF pl -> pWF (pplusl pl).
Proof.

*****

*****
forall (pl : list pol) (_ : andl pWF pl), pWF (pplusl pl)
+++++
unfold pWF, pWF_mon, pWF_pow.
-----
Definition pWF_pplusl : forall pl, andl pWF pl -> pWF (pplusl pl).
Proof.
unfold pWF, pWF_mon, pWF_pow.

*****

*****
forall (pl : list pol) (_ : andl (fun p : pol => pWF' (fst p) (snd p)) pl), pWF' (fst (pplusl pl)) (snd (pplusl pl))
+++++
induction pl; intros;[ simpl; tauto |].
-----
Definition pWF_pplusl : forall pl, andl pWF pl -> pWF (pplusl pl).
Proof.
unfold pWF, pWF_mon, pWF_pow.
induction pl; intros;[ simpl; tauto |].

*****
H : andl (fun p : pol => pWF' (fst p) (snd p)) (cons a pl)
IHpl : forall _ : andl (fun p : pol => pWF' (fst p) (snd p)) pl,\npWF' (fst (pplusl pl)) (snd (pplusl pl))
pl : list pol
a : pol
*****
pWF' (fst (pplusl (cons a pl))) (snd (pplusl (cons a pl)))
+++++
apply pWF_pplus; simpl in *; tauto.
-----
Definition pWF_pplusl : forall pl, andl pWF pl -> pWF (pplusl pl).
Proof.
unfold pWF, pWF_mon, pWF_pow.
induction pl; intros;[ simpl; tauto |].
apply pWF_pplus; simpl in *; tauto.

*****

*****

+++++
Qed.
-----
Lemma pplusl_correct : forall pl l,\n  peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).

*****

*****
forall (pl : list pol) (l : list nat), eq (peval (pplusl pl) l) (plusl (map (fun p : pol => peval p l) pl))
+++++
Proof.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.

*****

*****
forall (pl : list pol) (l : list nat), eq (peval (pplusl pl) l) (plusl (map (fun p : pol => peval p l) pl))
+++++
induction pl.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.

*****

*****
forall l : list nat, eq (peval (pplusl nil) l) (plusl (map (fun p : pol => peval p l) nil))
+++++
simpl.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.

*****

*****
forall l : list nat, eq (peval (pcst O O) l) O
+++++
intros.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.

*****
l : list nat
*****
eq (peval (pcst O O) l) O
+++++
trivial.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.

*****
IHpl : forall l : list nat,\neq (peval (pplusl pl) l) (plusl (map (fun p : pol => peval p l) pl))
pl : list pol
a : pol
*****
forall l : list nat, eq (peval (pplusl (cons a pl)) l) (plusl (map (fun p : pol => peval p l) (cons a pl)))
+++++
simpl.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.

*****
IHpl : forall l : list nat,\neq (peval (pplusl pl) l) (plusl (map (fun p : pol => peval p l) pl))
pl : list pol
a : pol
*****
forall l : list nat, eq (peval (pplus a (pplusl pl)) l) (Init.Nat.add (peval a l) (plusl (map (fun p : pol => peval p l) pl)))
+++++
intros.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.

*****
l : list nat
IHpl : forall l : list nat,\neq (peval (pplusl pl) l) (plusl (map (fun p : pol => peval p l) pl))
pl : list pol
a : pol
*****
eq (peval (pplus a (pplusl pl)) l) (Init.Nat.add (peval a l) (plusl (map (fun p : pol => peval p l) pl)))
+++++
trivial.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.
trivial.

*****
l : list nat
IHpl : forall l : list nat,\neq (peval (pplusl pl) l) (plusl (map (fun p : pol => peval p l) pl))
pl : list pol
a : pol
*****
eq (peval (pplus a (pplusl pl)) l) (Init.Nat.add (peval a l) (plusl (map (fun p : pol => peval p l) pl)))
+++++
rewrite pplus_correct.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.
trivial.
rewrite pplus_correct.

*****
l : list nat
IHpl : forall l : list nat,\neq (peval (pplusl pl) l) (plusl (map (fun p : pol => peval p l) pl))
pl : list pol
a : pol
*****
eq (Init.Nat.add (peval a l) (peval (pplusl pl) l)) (Init.Nat.add (peval a l) (plusl (map (fun p : pol => peval p l) pl)))
+++++
rewrite IHpl.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.
trivial.
rewrite pplus_correct.
rewrite IHpl.

*****
l : list nat
IHpl : forall l : list nat,\neq (peval (pplusl pl) l) (plusl (map (fun p : pol => peval p l) pl))
pl : list pol
a : pol
*****
eq (Init.Nat.add (peval a l) (plusl (map (fun p : pol => peval p l) pl))) (Init.Nat.add (peval a l) (plusl (map (fun p : pol => peval p l) pl)))
+++++
trivial.
-----
Lemma pplusl_correct : forall pl l, peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).
Proof.
induction pl.

*****

*****

+++++
Qed.
-----
Lemma peval_nth_pplus : forall pl l i n,\n  peval (nth i pl (pcst n 0)) l <=\n  peval (pplusl pl) l.
-----
Lemma peval_nth_pplus : forall pl l i n, peval (nth i pl (pcst n 0)) l <= peval (pplusl pl) l.

*****

*****
forall (pl : list pol) (l : list nat) (i n : nat), le (peval (nth i pl (pcst n O)) l) (peval (pplusl pl) l)
+++++
Proof.
-----
Lemma peval_nth_pplus : forall pl l i n, peval (nth i pl (pcst n 0)) l <= peval (pplusl pl) l.
Proof.

*****

*****
forall (pl : list pol) (l : list nat) (i n : nat), le (peval (nth i pl (pcst n O)) l) (peval (pplusl pl) l)
+++++
induction pl; simpl; intros; case i; trivial; rewrite pplus_correct; [ omega | ].
-----
Lemma peval_nth_pplus : forall pl l i n, peval (nth i pl (pcst n 0)) l <= peval (pplusl pl) l.
Proof.
induction pl; simpl; intros; case i; trivial; rewrite pplus_correct; [ omega | ].

*****
i,n : nat
l : list nat
IHpl : forall (l : list nat) (i n : nat),\nle (peval (nth i pl (pcst n O)) l) (peval (pplusl pl) l)
pl : list pol
a : pol
*****
forall n0 : nat, le (peval (nth n0 pl (pcst n O)) l) (Init.Nat.add (peval a l) (peval (pplusl pl) l))
+++++
intros; eapply le_trans;[ apply IHpl | ].
-----
Lemma peval_nth_pplus : forall pl l i n, peval (nth i pl (pcst n 0)) l <= peval (pplusl pl) l.
Proof.
induction pl; simpl; intros; case i; trivial; rewrite pplus_correct; [ omega | ].
intros; eapply le_trans;[ apply IHpl | ].

*****
i,n,n0 : nat
l : list nat
IHpl : forall (l : list nat) (i n : nat),\nle (peval (nth i pl (pcst n O)) l) (peval (pplusl pl) l)
pl : list pol
a : pol
*****
le (peval (pplusl pl) l) (Init.Nat.add (peval a l) (peval (pplusl pl) l))
+++++
omega.
-----
Lemma peval_nth_pplus : forall pl l i n, peval (nth i pl (pcst n 0)) l <= peval (pplusl pl) l.
Proof.
induction pl; simpl; intros; case i; trivial; rewrite pplus_correct; [ omega | ].
intros; eapply le_trans;[ apply IHpl | ].
omega.

*****

*****

+++++
Qed.
-----
Definition pmult_mon (m12:mon*mon) : mon :=\n  (fst (fst m12) * fst (snd m12), snd (fst m12) ++  snd (snd m12)).
-----
Definition pmult (p1 p2:pol) : pol :=\n  (max (fst p1) (fst p2), map pmult_mon (list_prod (snd p1) (snd p2))).
-----
Lemma parity_pmult : forall p1 p2,\n  parity (pmult p1 p2) = max (parity p1) (parity p2).
-----
Lemma parity_pmult : forall p1 p2, parity (pmult p1 p2) = max (parity p1) (parity p2).

*****

*****
forall p1 p2 : pol, eq (fst (pmult p1 p2)) (Init.Nat.max (fst p1) (fst p2))
+++++
Proof.
-----
Lemma parity_pmult : forall p1 p2, parity (pmult p1 p2) = max (parity p1) (parity p2).
Proof.

*****

*****
forall p1 p2 : pol, eq (fst (pmult p1 p2)) (Init.Nat.max (fst p1) (fst p2))
+++++
intros [ar1 ml1] [ar2 ml2].
-----
Lemma parity_pmult : forall p1 p2, parity (pmult p1 p2) = max (parity p1) (parity p2).
Proof.
intros [ar1 ml1] [ar2 ml2].

*****
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
eq (fst (pmult (pair ar1 ml1) (pair ar2 ml2))) (Init.Nat.max (fst (pair ar1 ml1)) (fst (pair ar2 ml2)))
+++++
trivial.
-----
Lemma parity_pmult : forall p1 p2, parity (pmult p1 p2) = max (parity p1) (parity p2).
Proof.
intros [ar1 ml1] [ar2 ml2].
trivial.

*****

*****

+++++
Qed.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2,\n  pWF_mon ar1 m1 -> pWF_mon ar2 m2 ->\n  pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).

*****

*****
forall (ar1 : nat) (m1 : mon) (ar2 : nat) (m2 : mon) (_ : pWF_mon ar1 m1) (_ : pWF_mon ar2 m2), pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair m1 m2))
+++++
Proof.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.

*****

*****
forall (ar1 : nat) (m1 : mon) (ar2 : nat) (m2 : mon) (_ : pWF_mon ar1 m1) (_ : pWF_mon ar2 m2), pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair m1 m2))
+++++
intros ar1 [a1 xl1] ar2 [a2 xl2].
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].

*****
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
forall (_ : pWF_mon ar1 (pair a1 xl1)) (_ : pWF_mon ar2 (pair a2 xl2)), pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair (pair a1 xl1) (pair a2 xl2)))
+++++
simpl pmult_mon.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.

*****
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
forall (_ : pWF_mon ar1 (pair a1 xl1)) (_ : pWF_mon ar2 (pair a2 xl2)), pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair (pair a1 xl1) (pair a2 xl2)))
+++++
intros.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.
intros.

*****
H0 : pWF_mon ar2 (pair a2 xl2)
H : pWF_mon ar1 (pair a1 xl1)
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair (pair a1 xl1) (pair a2 xl2)))
+++++
apply pWF_mon_app.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.
intros.
apply pWF_mon_app.

*****
H0 : pWF_mon ar2 (pair a2 xl2)
H : pWF_mon ar1 (pair a1 xl1)
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
pWF_mon (Init.Nat.max ar1 ar2) (pair (fst (fst (pair (pair a1 xl1) (pair a2 xl2)))) (snd (fst (pair (pair a1 xl1) (pair a2 xl2)))))
+++++
apply pWF_mon_le with ar1.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.
intros.
apply pWF_mon_app.
apply pWF_mon_le with ar1.

*****
H0 : pWF_mon ar2 (pair a2 xl2)
H : pWF_mon ar1 (pair a1 xl1)
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
le ar1 (Init.Nat.max ar1 ar2)
+++++
auto with arith.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.
intros.
apply pWF_mon_app.
apply pWF_mon_le with ar1.

*****
H0 : pWF_mon ar2 (pair a2 xl2)
H : pWF_mon ar1 (pair a1 xl1)
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
pWF_mon ar1 (pair (fst (fst (pair (pair a1 xl1) (pair a2 xl2)))) (snd (fst (pair (pair a1 xl1) (pair a2 xl2)))))
+++++
auto with arith.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.
intros.
apply pWF_mon_app.

*****
H0 : pWF_mon ar2 (pair a2 xl2)
H : pWF_mon ar1 (pair a1 xl1)
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
pWF_mon (Init.Nat.max ar1 ar2) (pair (fst (snd (pair (pair a1 xl1) (pair a2 xl2)))) (snd (snd (pair (pair a1 xl1) (pair a2 xl2)))))
+++++
apply pWF_mon_le with ar2.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.
intros.
apply pWF_mon_app.
apply pWF_mon_le with ar2.

*****
H0 : pWF_mon ar2 (pair a2 xl2)
H : pWF_mon ar1 (pair a1 xl1)
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
le ar2 (Init.Nat.max ar1 ar2)
+++++
auto with arith.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.
intros.
apply pWF_mon_app.
apply pWF_mon_le with ar2.

*****
H0 : pWF_mon ar2 (pair a2 xl2)
H : pWF_mon ar1 (pair a1 xl1)
xl2 : list pow
ar2,a2 : nat
xl1 : list pow
ar1,a1 : nat
*****
pWF_mon ar2 (pair (fst (snd (pair (pair a1 xl1) (pair a2 xl2)))) (snd (snd (pair (pair a1 xl1) (pair a2 xl2)))))
+++++
auto with arith.
-----
Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2, pWF_mon ar1 m1 -> pWF_mon ar2 m2 -> pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).
Proof.
intros ar1 [a1 xl1] ar2 [a2 xl2].
simpl pmult_mon.
intros.
apply pWF_mon_app.

*****

*****

+++++
Qed.
-----
Lemma pWF_pmult : forall p1 p2,\n  pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).

*****

*****
forall (p1 p2 : pol) (_ : pWF p1) (_ : pWF p2), pWF (pmult p1 p2)
+++++
Proof.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.

*****

*****
forall (p1 p2 : pol) (_ : pWF p1) (_ : pWF p2), pWF (pmult p1 p2)
+++++
unfold pWF.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.

*****

*****
forall (p1 p2 : pol) (_ : pWF' (fst p1) (snd p1)) (_ : pWF' (fst p2) (snd p2)), pWF' (fst (pmult p1 p2)) (snd (pmult p1 p2))
+++++
unfold pWF_mon.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.

*****

*****
forall (p1 p2 : pol) (_ : pWF' (fst p1) (snd p1)) (_ : pWF' (fst p2) (snd p2)), pWF' (fst (pmult p1 p2)) (snd (pmult p1 p2))
+++++
unfold pWF_pow.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (p1 p2 : pol) (_ : pWF' (fst p1) (snd p1)) (_ : pWF' (fst p2) (snd p2)), pWF' (fst (pmult p1 p2)) (snd (pmult p1 p2))
+++++
intros [ar1 ml1] [ar2 ml2] H1 H2.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.

*****
H2 : pWF' (fst (pair ar2 ml2)) (snd (pair ar2 ml2))
H1 : pWF' (fst (pair ar1 ml1)) (snd (pair ar1 ml1))
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
pWF' (fst (pmult (pair ar1 ml1) (pair ar2 ml2))) (snd (pmult (pair ar1 ml1) (pair ar2 ml2)))
+++++
simpl in *.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.

*****
H2 : pWF' ar2 ml2
H1 : pWF' ar1 ml1
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1 ml2))
+++++
induction ml1 as [ | m1 ml1' IH1].
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].

*****
H2 : pWF' ar2 ml2
H1 : pWF' ar1 nil
ml2 : list mon
ar1,ar2 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod nil ml2))
+++++
simpl in *.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.

*****
H2 : pWF' ar2 ml2
H1 : True
ml2 : list mon
ar1,ar2 : nat
*****
True
+++++
intros.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.

*****
H2 : pWF' ar2 ml2
H1 : True
ml2 : list mon
ar1,ar2 : nat
*****
True
+++++
trivial.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : pWF' ar1 (cons m1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod (cons m1 ml1') ml2))
+++++
simpl in *.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map pmult_mon (app (map (fun y : mon => pair m1 y) ml2) (list_prod ml1' ml2)))
+++++
intros.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map pmult_mon (app (map (fun y : mon => pair m1 y) ml2) (list_prod ml1' ml2)))
+++++
trivial.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map pmult_mon (app (map (fun y : mon => pair m1 y) ml2) (list_prod ml1' ml2)))
+++++
rewrite map_app.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (app (map pmult_mon (map (fun y : mon => pair m1 y) ml2)) (map pmult_mon (list_prod ml1' ml2)))
+++++
rewrite map_map.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (app (map (fun x : mon => pmult_mon (pair m1 x)) ml2) (map pmult_mon (list_prod ml1' ml2)))
+++++
apply pWF'_app.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) ml2)
+++++
idtac.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) ml2)
+++++
clear IH1.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.

*****
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) ml2)
+++++
induction ml2 as [ | m2 ml2' IH2].
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].

*****
H2 : pWF' ar2 nil
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) nil)
+++++
simpl in *.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.

*****
H2 : True
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
True
+++++
intros.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.
intros.

*****
H2 : True
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
True
+++++
trivial.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : pWF' ar2 (cons m2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) (cons m2 ml2'))
+++++
simpl in *.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : and (pWF_mon ar2 m2) (pWF' ar2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
and (pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair m1 m2))) (pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) ml2'))
+++++
intros.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.
intros.

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : and (pWF_mon ar2 m2) (pWF' ar2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
and (pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair m1 m2))) (pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) ml2'))
+++++
trivial.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.
intros.
trivial.

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : and (pWF_mon ar2 m2) (pWF' ar2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
and (pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair m1 m2))) (pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) ml2'))
+++++
split.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.
intros.
trivial.
split.

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : and (pWF_mon ar2 m2) (pWF' ar2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair m1 m2))
+++++
idtac.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.
intros.
trivial.
split.
idtac.

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : and (pWF_mon ar2 m2) (pWF' ar2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF_mon (Init.Nat.max ar1 ar2) (pmult_mon (pair m1 m2))
+++++
apply pWF_pmult_mon.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.
intros.
trivial.
split.
idtac.
apply pWF_pmult_mon.

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : and (pWF_mon ar2 m2) (pWF' ar2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF_mon ar1 m1
+++++
tauto.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.
intros.
trivial.
split.
idtac.
apply pWF_pmult_mon.

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : and (pWF_mon ar2 m2) (pWF' ar2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF_mon ar2 m2
+++++
tauto.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.
idtac.
clear IH1.
induction ml2 as [ | m2 ml2' IH2].
simpl in *.
intros.
trivial.
split.

*****
IH2 : forall _ : pWF' ar2 ml2',\npWF' (Init.Nat.max ar1 ar2)\n (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
H2 : and (pWF_mon ar2 m2) (pWF' ar2 ml2')
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2' : list mon
m2 : mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map (fun x : mon => pmult_mon (pair m1 x)) ml2')
+++++
tauto.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].
simpl in *.
intros.
trivial.
rewrite map_app.
rewrite map_map.
apply pWF'_app.

*****
IH1 : forall _ : pWF' ar1 ml1',\npWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
H2 : pWF' ar2 ml2
H1 : and (pWF_mon ar1 m1) (pWF' ar1 ml1')
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
pWF' (Init.Nat.max ar1 ar2) (map pmult_mon (list_prod ml1' ml2))
+++++
tauto.
-----
Lemma pWF_pmult : forall p1 p2, pWF p1 -> pWF p2 -> pWF (pmult p1 p2).
Proof.
unfold pWF.
unfold pWF_mon.
unfold pWF_pow.
intros [ar1 ml1] [ar2 ml2] H1 H2.
simpl in *.
induction ml1 as [ | m1 ml1' IH1].

*****

*****

+++++
Qed.
-----
Lemma pmult_mon_correct : forall m12 l,\n  peval_mon (pmult_mon m12) l =\n  peval_mon (fst m12) l * peval_mon (snd m12) l.
-----
Lemma pmult_mon_correct : forall m12 l, peval_mon (pmult_mon m12) l = peval_mon (fst m12) l * peval_mon (snd m12) l.

*****

*****
forall (m12 : prod mon mon) (l : list nat), eq (peval_mon (pmult_mon m12) l) (Init.Nat.mul (peval_mon (fst m12) l) (peval_mon (snd m12) l))
+++++
Proof.
-----
Lemma pmult_mon_correct : forall m12 l, peval_mon (pmult_mon m12) l = peval_mon (fst m12) l * peval_mon (snd m12) l.
Proof.

*****

*****
forall (m12 : prod mon mon) (l : list nat), eq (peval_mon (pmult_mon m12) l) (Init.Nat.mul (peval_mon (fst m12) l) (peval_mon (snd m12) l))
+++++
unfold peval_mon, peval_pow.
-----
Lemma pmult_mon_correct : forall m12 l, peval_mon (pmult_mon m12) l = peval_mon (fst m12) l * peval_mon (snd m12) l.
Proof.
unfold peval_mon, peval_pow.

*****

*****
forall (m12 : prod mon mon) (l : list nat), eq (Init.Nat.mul (fst (pmult_mon m12)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd (pmult_mon m12))))) (Init.Nat.mul (Init.Nat.mul (fst (fst m12)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd (fst m12))))) (Init.Nat.mul (fst (snd m12)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd (snd m12))))))
+++++
intros [[a1 xl1] [a2 xl2]] l; simpl.
-----
Lemma pmult_mon_correct : forall m12 l, peval_mon (pmult_mon m12) l = peval_mon (fst m12) l * peval_mon (snd m12) l.
Proof.
unfold peval_mon, peval_pow.
intros [[a1 xl1] [a2 xl2]] l; simpl.

*****
l : list nat
xl2 : list pow
a2 : nat
xl1 : list pow
a1 : nat
*****
eq (Init.Nat.mul (Init.Nat.mul a1 a2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 xl2)))) (Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul a2 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2))))
+++++
induction xl1 as [ | x1 xl1' IH]; simpl;[ ring | ring [IH] ].
-----
Lemma pmult_mon_correct : forall m12 l, peval_mon (pmult_mon m12) l = peval_mon (fst m12) l * peval_mon (snd m12) l.
Proof.
unfold peval_mon, peval_pow.
intros [[a1 xl1] [a2 xl2]] l; simpl.
induction xl1 as [ | x1 xl1' IH]; simpl;[ ring | ring [IH] ].

*****

*****

+++++
Qed.
-----
Lemma map_pmult_mon : forall m1 ml2 l,\n map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 =\n map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.

*****

*****
forall (m1 : mon) (ml2 : list mon) (l : list nat), eq (map (fun m2 : mon => peval_mon (pmult_mon (pair m1 m2)) l) ml2) (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)
+++++
Proof.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.

*****

*****
forall (m1 : mon) (ml2 : list mon) (l : list nat), eq (map (fun m2 : mon => peval_mon (pmult_mon (pair m1 m2)) l) ml2) (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)
+++++
unfold peval_mon.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.

*****

*****
forall (m1 : mon) (ml2 : list mon) (l : list nat), eq (map (fun m2 : mon => Init.Nat.mul (fst (pmult_mon (pair m1 m2))) (multl (map (fun x : pow => peval_pow x l) (snd (pmult_mon (pair m1 m2)))))) ml2) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul (fst m1) (multl (map (fun x : pow => peval_pow x l) (snd m1)))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => peval_pow x l) (snd m2))))) ml2)
+++++
unfold peval_pow.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.

*****

*****
forall (m1 : mon) (ml2 : list mon) (l : list nat), eq (map (fun m2 : mon => Init.Nat.mul (fst (pmult_mon (pair m1 m2))) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd (pmult_mon (pair m1 m2)))))) ml2) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul (fst m1) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m1)))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2)
+++++
intros [a1 xl1] ml2 l.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.

*****
l : list nat
ml2 : list mon
xl1 : list pow
a1 : nat
*****
eq (map (fun m2 : mon => Init.Nat.mul (fst (pmult_mon (pair (pair a1 xl1) m2))) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd (pmult_mon (pair (pair a1 xl1) m2)))))) ml2) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul (fst (pair a1 xl1)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd (pair a1 xl1))))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2)
+++++
simpl.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.

*****
l : list nat
ml2 : list mon
xl1 : list pow
a1 : nat
*****
eq (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (fst m2)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 (snd m2))))) ml2) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2)
+++++
induction ml2 as [ | [a2 xl2] ml2' IH].
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].

*****
l : list nat
xl1 : list pow
a1 : nat
*****
eq (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (fst m2)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 (snd m2))))) nil) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) nil)
+++++
simpl.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].
simpl.

*****
l : list nat
xl1 : list pow
a1 : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].

*****
IH : eq\n (map\n (fun m2 : mon =>\n Init.Nat.mul (Init.Nat.mul a1 (fst m2))\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (app xl1 (snd m2))))) ml2')\n (map\n (fun m2 : mon =>\n Init.Nat.mul\n (Init.Nat.mul a1\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)))\n (Init.Nat.mul (fst m2)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m2))))) ml2')
l : list nat
ml2' : list mon
xl2 : list pow
a2 : nat
xl1 : list pow
a1 : nat
*****
eq (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (fst m2)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 (snd m2))))) (cons (pair a2 xl2) ml2')) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) (cons (pair a2 xl2) ml2'))
+++++
simpl.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].
simpl.

*****
IH : eq\n (map\n (fun m2 : mon =>\n Init.Nat.mul (Init.Nat.mul a1 (fst m2))\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (app xl1 (snd m2))))) ml2')\n (map\n (fun m2 : mon =>\n Init.Nat.mul\n (Init.Nat.mul a1\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)))\n (Init.Nat.mul (fst m2)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m2))))) ml2')
l : list nat
ml2' : list mon
xl2 : list pow
a2 : nat
xl1 : list pow
a1 : nat
*****
eq (cons (Init.Nat.mul (Init.Nat.mul a1 a2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (fst m2)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 (snd m2))))) ml2')) (cons (Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul a2 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2'))
+++++
trivial.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].
simpl.
trivial.

*****
IH : eq\n (map\n (fun m2 : mon =>\n Init.Nat.mul (Init.Nat.mul a1 (fst m2))\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (app xl1 (snd m2))))) ml2')\n (map\n (fun m2 : mon =>\n Init.Nat.mul\n (Init.Nat.mul a1\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)))\n (Init.Nat.mul (fst m2)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m2))))) ml2')
l : list nat
ml2' : list mon
xl2 : list pow
a2 : nat
xl1 : list pow
a1 : nat
*****
eq (cons (Init.Nat.mul (Init.Nat.mul a1 a2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (fst m2)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 (snd m2))))) ml2')) (cons (Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul a2 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2'))
+++++
rewrite IH.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].
simpl.
trivial.
rewrite IH.

*****
IH : eq\n (map\n (fun m2 : mon =>\n Init.Nat.mul (Init.Nat.mul a1 (fst m2))\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (app xl1 (snd m2))))) ml2')\n (map\n (fun m2 : mon =>\n Init.Nat.mul\n (Init.Nat.mul a1\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)))\n (Init.Nat.mul (fst m2)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m2))))) ml2')
l : list nat
ml2' : list mon
xl2 : list pow
a2 : nat
xl1 : list pow
a1 : nat
*****
eq (cons (Init.Nat.mul (Init.Nat.mul a1 a2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (app xl1 xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2')) (cons (Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul a2 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2'))
+++++
rewrite map_app.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].
simpl.
trivial.
rewrite IH.
rewrite map_app.

*****
IH : eq\n (map\n (fun m2 : mon =>\n Init.Nat.mul (Init.Nat.mul a1 (fst m2))\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (app xl1 (snd m2))))) ml2')\n (map\n (fun m2 : mon =>\n Init.Nat.mul\n (Init.Nat.mul a1\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)))\n (Init.Nat.mul (fst m2)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m2))))) ml2')
l : list nat
ml2' : list mon
xl2 : list pow
a2 : nat
xl1 : list pow
a1 : nat
*****
eq (cons (Init.Nat.mul (Init.Nat.mul a1 a2) (multl (app (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1) (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2')) (cons (Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul a2 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2'))
+++++
rewrite multl_app.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].
simpl.
trivial.
rewrite IH.
rewrite map_app.
rewrite multl_app.

*****
IH : eq\n (map\n (fun m2 : mon =>\n Init.Nat.mul (Init.Nat.mul a1 (fst m2))\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (app xl1 (snd m2))))) ml2')\n (map\n (fun m2 : mon =>\n Init.Nat.mul\n (Init.Nat.mul a1\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)))\n (Init.Nat.mul (fst m2)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m2))))) ml2')
l : list nat
ml2' : list mon
xl2 : list pow
a2 : nat
xl1 : list pow
a1 : nat
*****
eq (cons (Init.Nat.mul (Init.Nat.mul a1 a2) (Init.Nat.mul (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2')) (cons (Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul a2 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2)))) (map (fun m2 : mon => Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul (fst m2) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) (snd m2))))) ml2'))
+++++
f_equal.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].
simpl.
trivial.
rewrite IH.
rewrite map_app.
rewrite multl_app.
f_equal.

*****
IH : eq\n (map\n (fun m2 : mon =>\n Init.Nat.mul (Init.Nat.mul a1 (fst m2))\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (app xl1 (snd m2))))) ml2')\n (map\n (fun m2 : mon =>\n Init.Nat.mul\n (Init.Nat.mul a1\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)))\n (Init.Nat.mul (fst m2)\n (multl\n (map (fun x : pow => power (nth (fst x) l O) (snd x))\n (snd m2))))) ml2')
l : list nat
ml2' : list mon
xl2 : list pow
a2 : nat
xl1 : list pow
a1 : nat
*****
eq (Init.Nat.mul (Init.Nat.mul a1 a2) (Init.Nat.mul (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1)) (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2)))) (Init.Nat.mul (Init.Nat.mul a1 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl1))) (Init.Nat.mul a2 (multl (map (fun x : pow => power (nth (fst x) l O) (snd x)) xl2))))
+++++
ring.
-----
Lemma map_pmult_mon : forall m1 ml2 l, map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 = map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.
Proof.
unfold peval_mon.
unfold peval_pow.
intros [a1 xl1] ml2 l.
simpl.
induction ml2 as [ | [a2 xl2] ml2' IH].

*****

*****

+++++
Qed.
-----
Lemma pmult_correct : forall p1 p2 l,\n peval (pmult p1 p2) l = peval p1 l * peval p2 l.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.

*****

*****
forall (p1 p2 : pol) (l : list nat), eq (peval (pmult p1 p2) l) (Init.Nat.mul (peval p1 l) (peval p2 l))
+++++
Proof.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.

*****

*****
forall (p1 p2 : pol) (l : list nat), eq (peval (pmult p1 p2) l) (Init.Nat.mul (peval p1 l) (peval p2 l))
+++++
unfold peval.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.

*****

*****
forall (p1 p2 : pol) (l : list nat), eq (plusl (map (fun m : mon => peval_mon m l) (snd (pmult p1 p2)))) (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) (snd p1))) (plusl (map (fun m : mon => peval_mon m l) (snd p2))))
+++++
intros [ar1 ml1] [ar2 ml2] l.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.

*****
l : list nat
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (snd (pmult (pair ar1 ml1) (pair ar2 ml2))))) (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) (snd (pair ar1 ml1)))) (plusl (map (fun m : mon => peval_mon m l) (snd (pair ar2 ml2)))))
+++++
simpl.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.

*****
l : list nat
ml2 : list mon
ar2 : nat
ml1 : list mon
ar1 : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (map pmult_mon (list_prod ml1 ml2)))) (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1)) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
induction ml1 as [ | m1 ml1' IH].
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].

*****
l : list nat
ml2 : list mon
ar1,ar2 : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (map pmult_mon (list_prod nil ml2)))) (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) nil)) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
simpl.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.

*****
l : list nat
ml2 : list mon
ar1,ar2 : nat
*****
eq O O
+++++
trivial.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].

*****
IH : eq\n (plusl\n (map (fun m : mon => peval_mon m l)\n (map pmult_mon (list_prod ml1' ml2))))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (map pmult_mon (list_prod (cons m1 ml1') ml2)))) (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) (cons m1 ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
simpl.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.

*****
IH : eq\n (plusl\n (map (fun m : mon => peval_mon m l)\n (map pmult_mon (list_prod ml1' ml2))))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (map pmult_mon (app (map (fun y : mon => pair m1 y) ml2) (list_prod ml1' ml2))))) (Init.Nat.mul (Init.Nat.add (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
trivial.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.

*****
IH : eq\n (plusl\n (map (fun m : mon => peval_mon m l)\n (map pmult_mon (list_prod ml1' ml2))))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (map pmult_mon (app (map (fun y : mon => pair m1 y) ml2) (list_prod ml1' ml2))))) (Init.Nat.mul (Init.Nat.add (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite !map_app.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.

*****
IH : eq\n (plusl\n (map (fun m : mon => peval_mon m l)\n (map pmult_mon (list_prod ml1' ml2))))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (app (map (fun m : mon => peval_mon m l) (map pmult_mon (map (fun y : mon => pair m1 y) ml2))) (map (fun m : mon => peval_mon m l) (map pmult_mon (list_prod ml1' ml2))))) (Init.Nat.mul (Init.Nat.add (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite !map_map.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.

*****
IH : eq\n (plusl\n (map (fun m : mon => peval_mon m l)\n (map pmult_mon (list_prod ml1' ml2))))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (app (map (fun x : mon => peval_mon (pmult_mon (pair m1 x)) l) ml2) (map (fun x : prod mon mon => peval_mon (pmult_mon x) l) (list_prod ml1' ml2)))) (Init.Nat.mul (Init.Nat.add (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite map_pmult_mon.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.
rewrite map_pmult_mon.

*****
IH : eq\n (plusl\n (map (fun m : mon => peval_mon m l)\n (map pmult_mon (list_prod ml1' ml2))))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (app (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2) (map (fun x : prod mon mon => peval_mon (pmult_mon x) l) (list_prod ml1' ml2)))) (Init.Nat.mul (Init.Nat.add (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite plusl_app.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.
rewrite map_pmult_mon.
rewrite plusl_app.

*****
IH : eq\n (plusl\n (map (fun m : mon => peval_mon m l)\n (map pmult_mon (list_prod ml1' ml2))))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (plusl (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)) (plusl (map (fun x : prod mon mon => peval_mon (pmult_mon x) l) (list_prod ml1' ml2)))) (Init.Nat.mul (Init.Nat.add (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite map_map in IH.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.
rewrite map_pmult_mon.
rewrite plusl_app.
rewrite map_map in IH.

*****
IH : eq\n (plusl\n (map (fun x : prod mon mon => peval_mon (pmult_mon x) l)\n (list_prod ml1' ml2)))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (plusl (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)) (plusl (map (fun x : prod mon mon => peval_mon (pmult_mon x) l) (list_prod ml1' ml2)))) (Init.Nat.mul (Init.Nat.add (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite IH.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.
rewrite map_pmult_mon.
rewrite plusl_app.
rewrite map_map in IH.
rewrite IH.

*****
IH : eq\n (plusl\n (map (fun x : prod mon mon => peval_mon (pmult_mon x) l)\n (list_prod ml1' ml2)))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (plusl (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)) (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1')) (plusl (map (fun m : mon => peval_mon m l) ml2)))) (Init.Nat.mul (Init.Nat.add (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml1'))) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite mult_plus_distr_r.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.
rewrite map_pmult_mon.
rewrite plusl_app.
rewrite map_map in IH.
rewrite IH.
rewrite mult_plus_distr_r.

*****
IH : eq\n (plusl\n (map (fun x : prod mon mon => peval_mon (pmult_mon x) l)\n (list_prod ml1' ml2)))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (Init.Nat.add (plusl (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)) (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1')) (plusl (map (fun m : mon => peval_mon m l) ml2)))) (Nat.add (Nat.mul (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml2))) (Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1')) (plusl (map (fun m : mon => peval_mon m l) ml2))))
+++++
f_equal.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.
rewrite map_pmult_mon.
rewrite plusl_app.
rewrite map_map in IH.
rewrite IH.
rewrite mult_plus_distr_r.
f_equal.

*****
IH : eq\n (plusl\n (map (fun x : prod mon mon => peval_mon (pmult_mon x) l)\n (list_prod ml1' ml2)))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)) (Nat.mul (peval_mon m1 l) (plusl (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite multl_plus_distr_l.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.
rewrite map_pmult_mon.
rewrite plusl_app.
rewrite map_map in IH.
rewrite IH.
rewrite mult_plus_distr_r.
f_equal.
rewrite multl_plus_distr_l.

*****
IH : eq\n (plusl\n (map (fun x : prod mon mon => peval_mon (pmult_mon x) l)\n (list_prod ml1' ml2)))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)) (plusl (map (fun m : nat => Init.Nat.mul (peval_mon m1 l) m) (map (fun m : mon => peval_mon m l) ml2)))
+++++
rewrite map_map.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].
simpl.
trivial.
rewrite !map_app.
rewrite !map_map.
rewrite map_pmult_mon.
rewrite plusl_app.
rewrite map_map in IH.
rewrite IH.
rewrite mult_plus_distr_r.
f_equal.
rewrite multl_plus_distr_l.
rewrite map_map.

*****
IH : eq\n (plusl\n (map (fun x : prod mon mon => peval_mon (pmult_mon x) l)\n (list_prod ml1' ml2)))\n (Init.Nat.mul (plusl (map (fun m : mon => peval_mon m l) ml1'))\n (plusl (map (fun m : mon => peval_mon m l) ml2)))
l : list nat
ml2 : list mon
ar2 : nat
ml1' : list mon
m1 : mon
ar1 : nat
*****
eq (plusl (map (fun m2 : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon m2 l)) ml2)) (plusl (map (fun x : mon => Init.Nat.mul (peval_mon m1 l) (peval_mon x l)) ml2))
+++++
trivial.
-----
Lemma pmult_correct : forall p1 p2 l, peval (pmult p1 p2) l = peval p1 l * peval p2 l.
Proof.
unfold peval.
intros [ar1 ml1] [ar2 ml2] l.
simpl.
induction ml1 as [ | m1 ml1' IH].

*****

*****

+++++
Qed.
-----
Definition pmultl (pl:list pol) : pol :=\n  fold_right pmult (pcst 0 1) pl.
-----
Lemma parity_pmultl pl :\n  parity (pmultl pl) = maxl (map parity pl).
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).

*****
pl : list pol
*****
eq (fst (pmultl pl)) (maxl (map fst pl))
+++++
Proof.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.

*****
pl : list pol
*****
eq (fst (pmultl pl)) (maxl (map fst pl))
+++++
induction pl.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.
induction pl.

*****

*****
eq (fst (pmultl nil)) (maxl (map fst nil))
+++++
simpl pmultl.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.
induction pl.
simpl pmultl.

*****

*****
eq (fst (pcst O (S O))) (maxl (map fst nil))
+++++
trivial.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.
induction pl.

*****
IHpl : eq (fst (pmultl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (fst (pmultl (cons a pl))) (maxl (map fst (cons a pl)))
+++++
simpl pmultl.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.
induction pl.
simpl pmultl.

*****
IHpl : eq (fst (pmultl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (fst (pmult a (pmultl pl))) (maxl (map fst (cons a pl)))
+++++
trivial.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.
induction pl.
simpl pmultl.
trivial.

*****
IHpl : eq (fst (pmultl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (fst (pmult a (pmultl pl))) (maxl (map fst (cons a pl)))
+++++
rewrite parity_pmult.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.
induction pl.
simpl pmultl.
trivial.
rewrite parity_pmult.

*****
IHpl : eq (fst (pmultl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (Init.Nat.max (fst a) (fst (pmultl pl))) (maxl (map fst (cons a pl)))
+++++
rewrite IHpl.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.
induction pl.
simpl pmultl.
trivial.
rewrite parity_pmult.
rewrite IHpl.

*****
IHpl : eq (fst (pmultl pl)) (maxl (map fst pl))
pl : list pol
a : pol
*****
eq (Init.Nat.max (fst a) (maxl (map fst pl))) (maxl (map fst (cons a pl)))
+++++
trivial.
-----
Lemma parity_pmultl pl : parity (pmultl pl) = maxl (map parity pl).
Proof.
induction pl.

*****

*****

+++++
Qed.
-----
Definition pWF_pmultl pl :\n  andl pWF pl -> pWF (pmultl pl).
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).

*****
pl : list pol
*****
forall _ : andl pWF pl, pWF (pmultl pl)
+++++
Proof.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.

*****
pl : list pol
*****
forall _ : andl pWF pl, pWF (pmultl pl)
+++++
induction pl.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.

*****

*****
forall _ : andl pWF nil, pWF (pmultl nil)
+++++
simpl pmultl.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.
simpl pmultl.

*****

*****
forall _ : andl pWF nil, pWF (pcst O (S O))
+++++
intros.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.
simpl pmultl.
intros.

*****
H : andl pWF nil
*****
pWF (pcst O (S O))
+++++
apply pWF_pcst.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.

*****
IHpl : forall _ : andl pWF pl, pWF (pmultl pl)
pl : list pol
a : pol
*****
forall _ : andl pWF (cons a pl), pWF (pmultl (cons a pl))
+++++
simpl pmultl.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.
simpl pmultl.

*****
IHpl : forall _ : andl pWF pl, pWF (pmultl pl)
pl : list pol
a : pol
*****
forall _ : andl pWF (cons a pl), pWF (pmult a (pmultl pl))
+++++
intros.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.
simpl pmultl.
intros.

*****
H : andl pWF (cons a pl)
IHpl : forall _ : andl pWF pl, pWF (pmultl pl)
pl : list pol
a : pol
*****
pWF (pmult a (pmultl pl))
+++++
apply pWF_pmult.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.
simpl pmultl.
intros.
apply pWF_pmult.

*****
H : andl pWF (cons a pl)
IHpl : forall _ : andl pWF pl, pWF (pmultl pl)
pl : list pol
a : pol
*****
pWF a
+++++
simpl in *.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.
simpl pmultl.
intros.
apply pWF_pmult.
simpl in *.

*****
H : and (pWF a) (andl pWF pl)
IHpl : forall _ : andl pWF pl, pWF (pmultl pl)
pl : list pol
a : pol
*****
pWF a
+++++
tauto.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.
simpl pmultl.
intros.
apply pWF_pmult.

*****
H : andl pWF (cons a pl)
IHpl : forall _ : andl pWF pl, pWF (pmultl pl)
pl : list pol
a : pol
*****
pWF (pmultl pl)
+++++
simpl in *.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.
simpl pmultl.
intros.
apply pWF_pmult.
simpl in *.

*****
H : and (pWF a) (andl pWF pl)
IHpl : forall _ : andl pWF pl, pWF (pmultl pl)
pl : list pol
a : pol
*****
pWF (pmultl pl)
+++++
tauto.
-----
Definition pWF_pmultl pl : andl pWF pl -> pWF (pmultl pl).
Proof.
induction pl.

*****

*****

+++++
Qed.
-----
Lemma pmultl_correct pl l :\n  peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).

*****
l : list nat
pl : list pol
*****
eq (peval (pmultl pl) l) (multl (map (fun p : pol => peval p l) pl))
+++++
Proof.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.

*****
l : list nat
pl : list pol
*****
eq (peval (pmultl pl) l) (multl (map (fun p : pol => peval p l) pl))
+++++
induction pl.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.

*****
l : list nat
*****
eq (peval (pmultl nil) l) (multl (map (fun p : pol => peval p l) nil))
+++++
simpl.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.

*****
l : list nat
*****
eq (peval (pcst O (S O)) l) (S O)
+++++
intros.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.

*****
l : list nat
*****
eq (peval (pcst O (S O)) l) (S O)
+++++
trivial.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.

*****
IHpl : eq (peval (pmultl pl) l) (multl (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
a : pol
*****
eq (peval (pmultl (cons a pl)) l) (multl (map (fun p : pol => peval p l) (cons a pl)))
+++++
simpl.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.

*****
IHpl : eq (peval (pmultl pl) l) (multl (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
a : pol
*****
eq (peval (pmult a (pmultl pl)) l) (Init.Nat.mul (peval a l) (multl (map (fun p : pol => peval p l) pl)))
+++++
intros.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.

*****
IHpl : eq (peval (pmultl pl) l) (multl (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
a : pol
*****
eq (peval (pmult a (pmultl pl)) l) (Init.Nat.mul (peval a l) (multl (map (fun p : pol => peval p l) pl)))
+++++
trivial.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.
trivial.

*****
IHpl : eq (peval (pmultl pl) l) (multl (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
a : pol
*****
eq (peval (pmult a (pmultl pl)) l) (Init.Nat.mul (peval a l) (multl (map (fun p : pol => peval p l) pl)))
+++++
rewrite pmult_correct.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.
trivial.
rewrite pmult_correct.

*****
IHpl : eq (peval (pmultl pl) l) (multl (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
a : pol
*****
eq (Init.Nat.mul (peval a l) (peval (pmultl pl) l)) (Init.Nat.mul (peval a l) (multl (map (fun p : pol => peval p l) pl)))
+++++
rewrite IHpl.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.
simpl.
intros.
trivial.
rewrite pmult_correct.
rewrite IHpl.

*****
IHpl : eq (peval (pmultl pl) l) (multl (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
a : pol
*****
eq (Init.Nat.mul (peval a l) (multl (map (fun p : pol => peval p l) pl))) (Init.Nat.mul (peval a l) (multl (map (fun p : pol => peval p l) pl)))
+++++
trivial.
-----
Lemma pmultl_correct pl l : peval (pmultl pl) l = multl (map (fun p => peval p l) pl).
Proof.
induction pl.

*****

*****

+++++
Qed.
-----
Fixpoint ppower (p:pol)(n:nat) : pol :=\n  match n with\n  | 0 => pcst (fst p) 1\n  | S n' => pmult p (ppower p n')\n  end.
-----
Lemma parity_ppower p n :\n  parity (ppower p n) = parity p.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.

*****
n : nat
p : pol
*****
eq (fst (ppower p n)) (fst p)
+++++
Proof.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.

*****
n : nat
p : pol
*****
eq (fst (ppower p n)) (fst p)
+++++
induction n.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.
induction n.

*****
p : pol
*****
eq (fst (ppower p O)) (fst p)
+++++
simpl ppower.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.
induction n.
simpl ppower.

*****
p : pol
*****
eq (fst (pcst (fst p) (S O))) (fst p)
+++++
trivial.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.
induction n.

*****
IHn : eq (fst (ppower p n)) (fst p)
n : nat
p : pol
*****
eq (fst (ppower p (S n))) (fst p)
+++++
simpl ppower.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.
induction n.
simpl ppower.

*****
IHn : eq (fst (ppower p n)) (fst p)
n : nat
p : pol
*****
eq (fst (pmult p (ppower p n))) (fst p)
+++++
trivial.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.
induction n.
simpl ppower.
trivial.

*****
IHn : eq (fst (ppower p n)) (fst p)
n : nat
p : pol
*****
eq (fst (pmult p (ppower p n))) (fst p)
+++++
rewrite parity_pmult.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.
induction n.
simpl ppower.
trivial.
rewrite parity_pmult.

*****
IHn : eq (fst (ppower p n)) (fst p)
n : nat
p : pol
*****
eq (Init.Nat.max (fst p) (fst (ppower p n))) (fst p)
+++++
rewrite IHn.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.
induction n.
simpl ppower.
trivial.
rewrite parity_pmult.
rewrite IHn.

*****
IHn : eq (fst (ppower p n)) (fst p)
n : nat
p : pol
*****
eq (Init.Nat.max (fst p) (fst p)) (fst p)
+++++
auto with arith.
-----
Lemma parity_ppower p n : parity (ppower p n) = parity p.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma pWF_ppower p n :\n  pWF p -> pWF (ppower p n).
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).

*****
n : nat
p : pol
*****
forall _ : pWF p, pWF (ppower p n)
+++++
Proof.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.

*****
n : nat
p : pol
*****
forall _ : pWF p, pWF (ppower p n)
+++++
induction n.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.

*****
p : pol
*****
forall _ : pWF p, pWF (ppower p O)
+++++
simpl ppower.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.
simpl ppower.

*****
p : pol
*****
forall _ : pWF p, pWF (pcst (fst p) (S O))
+++++
intros.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.
simpl ppower.
intros.

*****
H : pWF p
p : pol
*****
pWF (pcst (fst p) (S O))
+++++
apply pWF_pcst.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.

*****
IHn : forall _ : pWF p, pWF (ppower p n)
n : nat
p : pol
*****
forall _ : pWF p, pWF (ppower p (S n))
+++++
simpl ppower.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.
simpl ppower.

*****
IHn : forall _ : pWF p, pWF (ppower p n)
n : nat
p : pol
*****
forall _ : pWF p, pWF (pmult p (ppower p n))
+++++
intros.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.
simpl ppower.
intros.

*****
H : pWF p
IHn : forall _ : pWF p, pWF (ppower p n)
n : nat
p : pol
*****
pWF (pmult p (ppower p n))
+++++
apply pWF_pmult.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.
simpl ppower.
intros.
apply pWF_pmult.

*****
H : pWF p
IHn : forall _ : pWF p, pWF (ppower p n)
n : nat
p : pol
*****
pWF p
+++++
tauto.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.
simpl ppower.
intros.
apply pWF_pmult.

*****
H : pWF p
IHn : forall _ : pWF p, pWF (ppower p n)
n : nat
p : pol
*****
pWF (ppower p n)
+++++
tauto.
-----
Lemma pWF_ppower p n : pWF p -> pWF (ppower p n).
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Lemma ppower_correct p n l :\n  peval (ppower p n) l = power (peval p l) n.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.

*****
l : list nat
n : nat
p : pol
*****
eq (peval (ppower p n) l) (power (peval p l) n)
+++++
Proof.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.

*****
l : list nat
n : nat
p : pol
*****
eq (peval (ppower p n) l) (power (peval p l) n)
+++++
induction n.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.

*****
l : list nat
p : pol
*****
eq (peval (ppower p O) l) (power (peval p l) O)
+++++
simpl.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.
simpl.

*****
l : list nat
p : pol
*****
eq (peval (pcst (fst p) (S O)) l) (S O)
+++++
intros.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.
simpl.
intros.

*****
l : list nat
p : pol
*****
eq (peval (pcst (fst p) (S O)) l) (S O)
+++++
trivial.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.

*****
IHn : eq (peval (ppower p n) l) (power (peval p l) n)
l : list nat
n : nat
p : pol
*****
eq (peval (ppower p (S n)) l) (power (peval p l) (S n))
+++++
simpl.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.
simpl.

*****
IHn : eq (peval (ppower p n) l) (power (peval p l) n)
l : list nat
n : nat
p : pol
*****
eq (peval (pmult p (ppower p n)) l) (Init.Nat.mul (peval p l) (power (peval p l) n))
+++++
intros.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.
simpl.
intros.

*****
IHn : eq (peval (ppower p n) l) (power (peval p l) n)
l : list nat
n : nat
p : pol
*****
eq (peval (pmult p (ppower p n)) l) (Init.Nat.mul (peval p l) (power (peval p l) n))
+++++
trivial.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.
simpl.
intros.
trivial.

*****
IHn : eq (peval (ppower p n) l) (power (peval p l) n)
l : list nat
n : nat
p : pol
*****
eq (peval (pmult p (ppower p n)) l) (Init.Nat.mul (peval p l) (power (peval p l) n))
+++++
rewrite pmult_correct.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.
simpl.
intros.
trivial.
rewrite pmult_correct.

*****
IHn : eq (peval (ppower p n) l) (power (peval p l) n)
l : list nat
n : nat
p : pol
*****
eq (Init.Nat.mul (peval p l) (peval (ppower p n) l)) (Init.Nat.mul (peval p l) (power (peval p l) n))
+++++
rewrite IHn.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.
simpl.
intros.
trivial.
rewrite pmult_correct.
rewrite IHn.

*****
IHn : eq (peval (ppower p n) l) (power (peval p l) n)
l : list nat
n : nat
p : pol
*****
eq (Init.Nat.mul (peval p l) (power (peval p l) n)) (Init.Nat.mul (peval p l) (power (peval p l) n))
+++++
trivial.
-----
Lemma ppower_correct p n l : peval (ppower p n) l = power (peval p l) n.
Proof.
induction n.

*****

*****

+++++
Qed.
-----
Definition pcomp_pow' (xn:pow)(pl:list pol) : pol :=\n  ppower (nth (fst xn) pl (pcst 0 0)) (snd xn).
-----
Definition pcomp_pow (xn:pow)(pl:list pol) : pol :=\n  (maxl (map parity pl), snd (pcomp_pow' xn pl)).
-----
Definition pcomp_mon' (m:mon)(pl:list pol) : pol :=\n  pscalar (fst m) (pmultl (map (fun xn => pcomp_pow xn pl) (snd m))).
-----
Definition pcomp_mon (m:mon)(pl:list pol) : pol :=\n  (maxl (map parity pl), snd (pcomp_mon' m pl)).
-----
Definition pcomp' (p:pol)(pl:list pol) : pol :=\n  pplusl (map (fun m => pcomp_mon m pl) (snd p)).
-----
Definition pcomp (p:pol)(pl:list pol) : pol :=\n  (maxl (map parity pl), snd (pcomp' p pl)).
-----
Lemma parity_pcomp_pow : forall xn pl,\n  parity (pcomp_pow xn pl) = maxl (map parity pl).
-----
Lemma parity_pcomp_pow : forall xn pl, parity (pcomp_pow xn pl) = maxl (map parity pl).

*****

*****
forall (xn : pow) (pl : list pol), eq (fst (pcomp_pow xn pl)) (maxl (map fst pl))
+++++
Proof.
-----
Lemma parity_pcomp_pow : forall xn pl, parity (pcomp_pow xn pl) = maxl (map parity pl).
Proof.

*****

*****
forall (xn : pow) (pl : list pol), eq (fst (pcomp_pow xn pl)) (maxl (map fst pl))
+++++
unfold pcomp_pow.
-----
Lemma parity_pcomp_pow : forall xn pl, parity (pcomp_pow xn pl) = maxl (map parity pl).
Proof.
unfold pcomp_pow.

*****

*****
forall (xn : pow) (pl : list pol), eq (fst (pair (maxl (map fst pl)) (snd (pcomp_pow' xn pl)))) (maxl (map fst pl))
+++++
intros [x n] pl.
-----
Lemma parity_pcomp_pow : forall xn pl, parity (pcomp_pow xn pl) = maxl (map parity pl).
Proof.
unfold pcomp_pow.
intros [x n] pl.

*****
pl : list pol
x,n : nat
*****
eq (fst (pair (maxl (map fst pl)) (snd (pcomp_pow' (pair x n) pl)))) (maxl (map fst pl))
+++++
simpl.
-----
Lemma parity_pcomp_pow : forall xn pl, parity (pcomp_pow xn pl) = maxl (map parity pl).
Proof.
unfold pcomp_pow.
intros [x n] pl.
simpl.

*****
pl : list pol
x,n : nat
*****
eq (maxl (map fst pl)) (maxl (map fst pl))
+++++
case_eq (ppower (nth x pl (pcst 0 0)) n).
-----
Lemma parity_pcomp_pow : forall xn pl, parity (pcomp_pow xn pl) = maxl (map parity pl).
Proof.
unfold pcomp_pow.
intros [x n] pl.
simpl.
case_eq (ppower (nth x pl (pcst 0 0)) n).

*****
pl : list pol
x,n : nat
*****
forall (n0 : nat) (l : list mon) (_ : eq (ppower (nth x pl (pcst O O)) n) (pair n0 l)), eq (maxl (map fst pl)) (maxl (map fst pl))
+++++
trivial.
-----
Lemma parity_pcomp_pow : forall xn pl, parity (pcomp_pow xn pl) = maxl (map parity pl).
Proof.
unfold pcomp_pow.
intros [x n] pl.
simpl.
case_eq (ppower (nth x pl (pcst 0 0)) n).
trivial.

*****

*****

+++++
Qed.
-----
Lemma map_parity_pcomp_pow xl pl :\n  map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.
-----
Lemma map_parity_pcomp_pow xl pl : map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.

*****
pl : list pol
xl : list pow
*****
eq (map (fun xn : pow => fst (pcomp_pow xn pl)) xl) (map (fun _ : pow => maxl (map fst pl)) xl)
+++++
Proof.
-----
Lemma map_parity_pcomp_pow xl pl : map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.
Proof.

*****
pl : list pol
xl : list pow
*****
eq (map (fun xn : pow => fst (pcomp_pow xn pl)) xl) (map (fun _ : pow => maxl (map fst pl)) xl)
+++++
destruct xl.
-----
Lemma map_parity_pcomp_pow xl pl : map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.
Proof.
destruct xl.

*****
pl : list pol
*****
eq (map (fun xn : pow => fst (pcomp_pow xn pl)) nil) (map (fun _ : pow => maxl (map fst pl)) nil)
+++++
simpl.
-----
Lemma map_parity_pcomp_pow xl pl : map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.
Proof.
destruct xl.
simpl.

*****
pl : list pol
*****
eq nil nil
+++++
trivial.
-----
Lemma map_parity_pcomp_pow xl pl : map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.
Proof.
destruct xl.

*****
pl : list pol
xl : list pow
p : pow
*****
eq (map (fun xn : pow => fst (pcomp_pow xn pl)) (cons p xl)) (map (fun _ : pow => maxl (map fst pl)) (cons p xl))
+++++
simpl.
-----
Lemma map_parity_pcomp_pow xl pl : map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.
Proof.
destruct xl.
simpl.

*****
pl : list pol
xl : list pow
p : pow
*****
eq (cons (maxl (map fst pl)) (map (fun _ : pow => maxl (map fst pl)) xl)) (cons (maxl (map fst pl)) (map (fun _ : pow => maxl (map fst pl)) xl))
+++++
trivial.
-----
Lemma map_parity_pcomp_pow xl pl : map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.
Proof.
destruct xl.

*****

*****

+++++
Qed.
-----
Lemma parity_pcomp_mon' : forall m pl,\n  parity (pcomp_mon' m pl) <= maxl (map parity pl).
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).

*****

*****
forall (m : mon) (pl : list pol), le (fst (pcomp_mon' m pl)) (maxl (map fst pl))
+++++
Proof.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.

*****

*****
forall (m : mon) (pl : list pol), le (fst (pcomp_mon' m pl)) (maxl (map fst pl))
+++++
intros [a xl] pl.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.

*****
pl : list pol
xl : list pow
a : nat
*****
le (fst (pcomp_mon' (pair a xl) pl)) (maxl (map fst pl))
+++++
simpl.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.

*****
pl : list pol
xl : list pow
a : nat
*****
le (fst (pmultl (map (fun xn : pow => pcomp_pow xn pl) xl))) (maxl (map fst pl))
+++++
rewrite parity_pmultl.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.
rewrite parity_pmultl.

*****
pl : list pol
xl : list pow
a : nat
*****
le (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) xl))) (maxl (map fst pl))
+++++
induction xl.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.
rewrite parity_pmultl.
induction xl.

*****
pl : list pol
a : nat
*****
le (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) nil))) (maxl (map fst pl))
+++++
simpl.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.
rewrite parity_pmultl.
induction xl.
simpl.

*****
pl : list pol
a : nat
*****
le O (maxl (map fst pl))
+++++
omega.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.
rewrite parity_pmultl.
induction xl.

*****
IHxl : le (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) xl)))\n (maxl (map fst pl))
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
le (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) (cons a0 xl)))) (maxl (map fst pl))
+++++
simpl.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.
rewrite parity_pmultl.
induction xl.
simpl.

*****
IHxl : le (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) xl)))\n (maxl (map fst pl))
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
le (Init.Nat.max (maxl (map fst pl)) (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) xl)))) (maxl (map fst pl))
+++++
apply Nat.max_lub.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.
rewrite parity_pmultl.
induction xl.
simpl.
apply Nat.max_lub.

*****
IHxl : le (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) xl)))\n (maxl (map fst pl))
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
le (maxl (map fst pl)) (maxl (map fst pl))
+++++
trivial.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.
rewrite parity_pmultl.
induction xl.
simpl.
apply Nat.max_lub.

*****
IHxl : le (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) xl)))\n (maxl (map fst pl))
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
le (maxl (map fst (map (fun xn : pow => pcomp_pow xn pl) xl))) (maxl (map fst pl))
+++++
trivial.
-----
Lemma parity_pcomp_mon' : forall m pl, parity (pcomp_mon' m pl) <= maxl (map parity pl).
Proof.
intros [a xl] pl.
simpl.
rewrite parity_pmultl.
induction xl.

*****

*****

+++++
Qed.
-----
Lemma parity_pcomp_mon : forall m pl,\n  parity (pcomp_mon m pl) = maxl (map parity pl).
-----
Lemma parity_pcomp_mon : forall m pl, parity (pcomp_mon m pl) = maxl (map parity pl).

*****

*****
forall (m : mon) (pl : list pol), eq (fst (pcomp_mon m pl)) (maxl (map fst pl))
+++++
Proof.
-----
Lemma parity_pcomp_mon : forall m pl, parity (pcomp_mon m pl) = maxl (map parity pl).
Proof.

*****

*****
forall (m : mon) (pl : list pol), eq (fst (pcomp_mon m pl)) (maxl (map fst pl))
+++++
unfold pcomp_mon.
-----
Lemma parity_pcomp_mon : forall m pl, parity (pcomp_mon m pl) = maxl (map parity pl).
Proof.
unfold pcomp_mon.

*****

*****
forall (m : mon) (pl : list pol), eq (fst (pair (maxl (map fst pl)) (snd (pcomp_mon' m pl)))) (maxl (map fst pl))
+++++
intros [a xl] pl.
-----
Lemma parity_pcomp_mon : forall m pl, parity (pcomp_mon m pl) = maxl (map parity pl).
Proof.
unfold pcomp_mon.
intros [a xl] pl.

*****
pl : list pol
xl : list pow
a : nat
*****
eq (fst (pair (maxl (map fst pl)) (snd (pcomp_mon' (pair a xl) pl)))) (maxl (map fst pl))
+++++
simpl.
-----
Lemma parity_pcomp_mon : forall m pl, parity (pcomp_mon m pl) = maxl (map parity pl).
Proof.
unfold pcomp_mon.
intros [a xl] pl.
simpl.

*****
pl : list pol
xl : list pow
a : nat
*****
eq (maxl (map fst pl)) (maxl (map fst pl))
+++++
trivial.
-----
Lemma parity_pcomp_mon : forall m pl, parity (pcomp_mon m pl) = maxl (map parity pl).
Proof.
unfold pcomp_mon.
intros [a xl] pl.
simpl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma parity_pcomp p pl :\n  parity (pcomp p pl) = maxl (map parity pl).
-----
Lemma parity_pcomp p pl : parity (pcomp p pl) = maxl (map parity pl).

*****
pl : list pol
p : pol
*****
eq (fst (pcomp p pl)) (maxl (map fst pl))
+++++
Proof.
-----
Lemma parity_pcomp p pl : parity (pcomp p pl) = maxl (map parity pl).
Proof.

*****
pl : list pol
p : pol
*****
eq (fst (pcomp p pl)) (maxl (map fst pl))
+++++
unfold pcomp.
-----
Lemma parity_pcomp p pl : parity (pcomp p pl) = maxl (map parity pl).
Proof.
unfold pcomp.

*****
pl : list pol
p : pol
*****
eq (fst (pair (maxl (map fst pl)) (snd (pcomp' p pl)))) (maxl (map fst pl))
+++++
intros.
-----
Lemma parity_pcomp p pl : parity (pcomp p pl) = maxl (map parity pl).
Proof.
unfold pcomp.
intros.

*****
pl : list pol
p : pol
*****
eq (fst (pair (maxl (map fst pl)) (snd (pcomp' p pl)))) (maxl (map fst pl))
+++++
case (pcomp' p pl).
-----
Lemma parity_pcomp p pl : parity (pcomp p pl) = maxl (map parity pl).
Proof.
unfold pcomp.
intros.
case (pcomp' p pl).

*****
pl : list pol
p : pol
*****
forall (n : nat) (l : list mon), eq (fst (pair (maxl (map fst pl)) (snd (pair n l)))) (maxl (map fst pl))
+++++
trivial.
-----
Lemma parity_pcomp p pl : parity (pcomp p pl) = maxl (map parity pl).
Proof.
unfold pcomp.
intros.
case (pcomp' p pl).
trivial.

*****

*****

+++++
Qed.
-----
Lemma pWF_pcomp_pow' : forall xn pl,\n  andl pWF pl -> pWF (pcomp_pow' xn pl).
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).

*****

*****
forall (xn : pow) (pl : list pol) (_ : andl pWF pl), pWF (pcomp_pow' xn pl)
+++++
Proof.
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).
Proof.

*****

*****
forall (xn : pow) (pl : list pol) (_ : andl pWF pl), pWF (pcomp_pow' xn pl)
+++++
intros [x n] pl H.
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).
Proof.
intros [x n] pl H.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
pWF (pcomp_pow' (pair x n) pl)
+++++
simpl.
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).
Proof.
intros [x n] pl H.
simpl.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
pWF (pcomp_pow' (pair x n) pl)
+++++
apply pWF_ppower.
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).
Proof.
intros [x n] pl H.
simpl.
apply pWF_ppower.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
pWF (nth (fst (pair x n)) pl (pcst O O))
+++++
apply pWF_nth.
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).
Proof.
intros [x n] pl H.
simpl.
apply pWF_ppower.
apply pWF_nth.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
andl pWF pl
+++++
trivial.
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).
Proof.
intros [x n] pl H.
simpl.
apply pWF_ppower.
apply pWF_nth.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
pWF (pcst O O)
+++++
trivial.
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).
Proof.
intros [x n] pl H.
simpl.
apply pWF_ppower.
apply pWF_nth.
trivial.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
pWF (pcst O O)
+++++
apply pWF_pcst.
-----
Lemma pWF_pcomp_pow' : forall xn pl, andl pWF pl -> pWF (pcomp_pow' xn pl).
Proof.
intros [x n] pl H.
simpl.
apply pWF_ppower.
apply pWF_nth.

*****

*****

+++++
Qed.
-----
Lemma pWF_pcomp_pow : forall xn pl,\n  andl pWF pl -> pWF (pcomp_pow xn pl).
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).

*****

*****
forall (xn : pow) (pl : list pol) (_ : andl pWF pl), pWF (pcomp_pow xn pl)
+++++
Proof.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.

*****

*****
forall (xn : pow) (pl : list pol) (_ : andl pWF pl), pWF (pcomp_pow xn pl)
+++++
intros [x n] pl H.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
pWF (pcomp_pow (pair x n) pl)
+++++
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
le (fst (pcomp_pow' (pair x n) pl)) (fst (pcomp_pow (pair x n) pl))
+++++
rewrite parity_pcomp_pow.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
le (fst (pcomp_pow' (pair x n) pl)) (maxl (map fst pl))
+++++
unfold pcomp_pow'.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
le (fst (ppower (nth (fst (pair x n)) pl (pcst O O)) (snd (pair x n)))) (maxl (map fst pl))
+++++
rewrite parity_ppower.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.
rewrite parity_ppower.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
le (fst (nth (fst (pair x n)) pl (pcst O O))) (maxl (map fst pl))
+++++
destruct (le_lt_dec (length pl) x).
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.
rewrite parity_ppower.
destruct (le_lt_dec (length pl) x).

*****
l : le (length pl) x
H : andl pWF pl
pl : list pol
x,n : nat
*****
le (fst (nth (fst (pair x n)) pl (pcst O O))) (maxl (map fst pl))
+++++
rewrite nth_overflow.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.
rewrite parity_ppower.
destruct (le_lt_dec (length pl) x).
rewrite nth_overflow.

*****
l : le (length pl) x
H : andl pWF pl
pl : list pol
x,n : nat
*****
le (fst (pcst O O)) (maxl (map fst pl))
+++++
auto with arith.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.
rewrite parity_ppower.
destruct (le_lt_dec (length pl) x).
rewrite nth_overflow.

*****
l : le (length pl) x
H : andl pWF pl
pl : list pol
x,n : nat
*****
le (length pl) (fst (pair x n))
+++++
auto with arith.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.
rewrite parity_ppower.
destruct (le_lt_dec (length pl) x).

*****
l : lt x (length pl)
H : andl pWF pl
pl : list pol
x,n : nat
*****
le (fst (nth (fst (pair x n)) pl (pcst O O))) (maxl (map fst pl))
+++++
apply in_le_maxl.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.
rewrite parity_ppower.
destruct (le_lt_dec (length pl) x).
apply in_le_maxl.

*****
l : lt x (length pl)
H : andl pWF pl
pl : list pol
x,n : nat
*****
In (fst (nth (fst (pair x n)) pl (pcst O O))) (map fst pl)
+++++
apply in_map.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.
rewrite parity_ppower.
destruct (le_lt_dec (length pl) x).
apply in_le_maxl.
apply in_map.

*****
l : lt x (length pl)
H : andl pWF pl
pl : list pol
x,n : nat
*****
In (nth (fst (pair x n)) pl (pcst O O)) pl
+++++
apply nth_In.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
rewrite parity_pcomp_pow.
unfold pcomp_pow'.
rewrite parity_ppower.
destruct (le_lt_dec (length pl) x).
apply in_le_maxl.
apply in_map.
apply nth_In.

*****
l : lt x (length pl)
H : andl pWF pl
pl : list pol
x,n : nat
*****
lt (fst (pair x n)) (length pl)
+++++
trivial.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
pWF' (fst (pcomp_pow' (pair x n) pl)) (snd (pcomp_pow (pair x n) pl))
+++++
apply pWF_pcomp_pow'.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).
apply pWF_pcomp_pow'.

*****
H : andl pWF pl
pl : list pol
x,n : nat
*****
andl pWF pl
+++++
trivial.
-----
Lemma pWF_pcomp_pow : forall xn pl, andl pWF pl -> pWF (pcomp_pow xn pl).
Proof.
intros [x n] pl H.
apply pWF'_le with (ar1 := fst (pcomp_pow' (x, n) pl)).

*****

*****

+++++
Qed.
-----
Lemma pWF_pcomp_mon' : forall m pl,\n  andl pWF pl -> pWF (pcomp_mon' m pl).
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).

*****

*****
forall (m : mon) (pl : list pol) (_ : andl pWF pl), pWF (pcomp_mon' m pl)
+++++
Proof.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.

*****

*****
forall (m : mon) (pl : list pol) (_ : andl pWF pl), pWF (pcomp_mon' m pl)
+++++
unfold pWF.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.

*****

*****
forall (m : mon) (pl : list pol) (_ : andl (fun p : pol => pWF' (fst p) (snd p)) pl), pWF' (fst (pcomp_mon' m pl)) (snd (pcomp_mon' m pl))
+++++
unfold pWF'.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.

*****

*****
forall (m : mon) (pl : list pol) (_ : andl (fun p : pol => andl (pWF_mon (fst p)) (snd p)) pl), andl (pWF_mon (fst (pcomp_mon' m pl))) (snd (pcomp_mon' m pl))
+++++
unfold pWF_mon.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.

*****

*****
forall (m : mon) (pl : list pol) (_ : andl (fun p : pol => andl (fun m0 : mon => andl (pWF_pow (fst p)) (snd m0)) (snd p)) pl), andl (fun m0 : mon => andl (pWF_pow (fst (pcomp_mon' m pl))) (snd m0)) (snd (pcomp_mon' m pl))
+++++
unfold pWF_pow.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (m : mon) (pl : list pol) (_ : andl (fun p : pol => andl (fun m0 : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m0)) (snd p)) pl), andl (fun m0 : mon => andl (fun xn : pow => lt (fst xn) (fst (pcomp_mon' m pl))) (snd m0)) (snd (pcomp_mon' m pl))
+++++
intros [a xl] pl H.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl : list pow
a : nat
*****
andl (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst (pcomp_mon' (pair a xl) pl))) (snd m)) (snd (pcomp_mon' (pair a xl) pl))
+++++
induction xl as [ | [x n] xl' IH].
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
a : nat
*****
andl (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst (pcomp_mon' (pair a nil) pl))) (snd m)) (snd (pcomp_mon' (pair a nil) pl))
+++++
simpl.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
simpl.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
a : nat
*****
and True True
+++++
tauto.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].

*****
IH : andl\n (fun m : mon =>\n andl\n (fun xn : pow => lt (fst xn) (fst (pcomp_mon' (pair a xl') pl)))\n (snd m)) (snd (pcomp_mon' (pair a xl') pl))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a,x,n : nat
*****
andl (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst (pcomp_mon' (pair a (cons (pair x n) xl')) pl))) (snd m)) (snd (pcomp_mon' (pair a (cons (pair x n) xl')) pl))
+++++
apply pWF_pscalar.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.

*****
IH : andl\n (fun m : mon =>\n andl\n (fun xn : pow => lt (fst xn) (fst (pcomp_mon' (pair a xl') pl)))\n (snd m)) (snd (pcomp_mon' (pair a xl') pl))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a,x,n : nat
*****
pWF (pmultl (map (fun xn : pow => pcomp_pow xn pl) (snd (pair a (cons (pair x n) xl')))))
+++++
apply pWF_pmultl.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.

*****
IH : andl\n (fun m : mon =>\n andl\n (fun xn : pow => lt (fst xn) (fst (pcomp_mon' (pair a xl') pl)))\n (snd m)) (snd (pcomp_mon' (pair a xl') pl))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a,x,n : nat
*****
andl pWF (map (fun xn : pow => pcomp_pow xn pl) (snd (pair a (cons (pair x n) xl'))))
+++++
clear IH.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a,x,n : nat
*****
andl pWF (map (fun xn : pow => pcomp_pow xn pl) (snd (pair a (cons (pair x n) xl'))))
+++++
induction xl'.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
a,x,n : nat
*****
andl pWF (map (fun xn : pow => pcomp_pow xn pl) (snd (pair a (cons (pair x n) nil))))
+++++
simpl in *.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
a,x,n : nat
*****
and (pWF (pcomp_pow (pair x n) pl)) True
+++++
split.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
a,x,n : nat
*****
pWF (pcomp_pow (pair x n) pl)
+++++
trivial.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.
trivial.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
a,x,n : nat
*****
pWF (pcomp_pow (pair x n) pl)
+++++
apply pWF_pcomp_pow.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.
trivial.
apply pWF_pcomp_pow.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
a,x,n : nat
*****
andl pWF pl
+++++
trivial.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.

*****
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
a,x,n : nat
*****
True
+++++
trivial.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.

*****
IHxl' : andl pWF\n (map (fun xn : pow => pcomp_pow xn pl)\n (snd (pair a (cons (pair x n) xl'))))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a0 : pow
a,x,n : nat
*****
andl pWF (map (fun xn : pow => pcomp_pow xn pl) (snd (pair a (cons (pair x n) (cons a0 xl')))))
+++++
simpl in *.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.

*****
IHxl' : and (pWF (pcomp_pow (pair x n) pl))\n (andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl'))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a0 : pow
a,x,n : nat
*****
and (pWF (pcomp_pow (pair x n) pl)) (and (pWF (pcomp_pow a0 pl)) (andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl')))
+++++
split.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.

*****
IHxl' : and (pWF (pcomp_pow (pair x n) pl))\n (andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl'))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a0 : pow
a,x,n : nat
*****
pWF (pcomp_pow (pair x n) pl)
+++++
tauto.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.

*****
IHxl' : and (pWF (pcomp_pow (pair x n) pl))\n (andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl'))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a0 : pow
a,x,n : nat
*****
and (pWF (pcomp_pow a0 pl)) (andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl'))
+++++
split.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.
split.

*****
IHxl' : and (pWF (pcomp_pow (pair x n) pl))\n (andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl'))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a0 : pow
a,x,n : nat
*****
pWF (pcomp_pow a0 pl)
+++++
apply pWF_pcomp_pow.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.
split.
apply pWF_pcomp_pow.

*****
IHxl' : and (pWF (pcomp_pow (pair x n) pl))\n (andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl'))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a0 : pow
a,x,n : nat
*****
andl pWF pl
+++++
trivial.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].
apply pWF_pscalar.
apply pWF_pmultl.
clear IH.
induction xl'.
simpl in *.
split.
split.

*****
IHxl' : and (pWF (pcomp_pow (pair x n) pl))\n (andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl'))
H : andl\n (fun p : pol =>\n andl\n (fun m : mon => andl (fun xn : pow => lt (fst xn) (fst p)) (snd m))\n (snd p)) pl
pl : list pol
xl' : list pow
a0 : pow
a,x,n : nat
*****
andl pWF (map (fun xn : pow => pcomp_pow xn pl) xl')
+++++
apply IHxl'.
-----
Lemma pWF_pcomp_mon' : forall m pl, andl pWF pl -> pWF (pcomp_mon' m pl).
Proof.
unfold pWF.
unfold pWF'.
unfold pWF_mon.
unfold pWF_pow.
intros [a xl] pl H.
induction xl as [ | [x n] xl' IH].

*****

*****

+++++
Qed.
-----
Lemma pWF_pcomp_mon : forall m pl,\n  andl pWF pl -> pWF (pcomp_mon m pl).
-----
Lemma pWF_pcomp_mon : forall m pl, andl pWF pl -> pWF (pcomp_mon m pl).

*****

*****
forall (m : mon) (pl : list pol) (_ : andl pWF pl), pWF (pcomp_mon m pl)
+++++
Proof.
-----
Lemma pWF_pcomp_mon : forall m pl, andl pWF pl -> pWF (pcomp_mon m pl).
Proof.

*****

*****
forall (m : mon) (pl : list pol) (_ : andl pWF pl), pWF (pcomp_mon m pl)
+++++
intros [a xl] pl H.
-----
Lemma pWF_pcomp_mon : forall m pl, andl pWF pl -> pWF (pcomp_mon m pl).
Proof.
intros [a xl] pl H.

*****
H : andl pWF pl
pl : list pol
xl : list pow
a : nat
*****
pWF (pcomp_mon (pair a xl) pl)
+++++
apply pWF'_le with (ar1 := fst (pcomp_mon' (a, xl) pl)).
-----
Lemma pWF_pcomp_mon : forall m pl, andl pWF pl -> pWF (pcomp_mon m pl).
Proof.
intros [a xl] pl H.
apply pWF'_le with (ar1 := fst (pcomp_mon' (a, xl) pl)).

*****
H : andl pWF pl
pl : list pol
xl : list pow
a : nat
*****
le (fst (pcomp_mon' (pair a xl) pl)) (fst (pcomp_mon (pair a xl) pl))
+++++
apply parity_pcomp_mon'.
-----
Lemma pWF_pcomp_mon : forall m pl, andl pWF pl -> pWF (pcomp_mon m pl).
Proof.
intros [a xl] pl H.
apply pWF'_le with (ar1 := fst (pcomp_mon' (a, xl) pl)).

*****
H : andl pWF pl
pl : list pol
xl : list pow
a : nat
*****
pWF' (fst (pcomp_mon' (pair a xl) pl)) (snd (pcomp_mon (pair a xl) pl))
+++++
apply pWF_pcomp_mon'.
-----
Lemma pWF_pcomp_mon : forall m pl, andl pWF pl -> pWF (pcomp_mon m pl).
Proof.
intros [a xl] pl H.
apply pWF'_le with (ar1 := fst (pcomp_mon' (a, xl) pl)).
apply pWF_pcomp_mon'.

*****
H : andl pWF pl
pl : list pol
xl : list pow
a : nat
*****
andl pWF pl
+++++
trivial.
-----
Lemma pWF_pcomp_mon : forall m pl, andl pWF pl -> pWF (pcomp_mon m pl).
Proof.
intros [a xl] pl H.
apply pWF'_le with (ar1 := fst (pcomp_mon' (a, xl) pl)).

*****

*****

+++++
Qed.
-----
Lemma pWF_pcomp' : forall p pl,\n  andl pWF pl -> pWF (pcomp' p pl).
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).

*****

*****
forall (p : pol) (pl : list pol) (_ : andl pWF pl), pWF (pcomp' p pl)
+++++
Proof.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.

*****

*****
forall (p : pol) (pl : list pol) (_ : andl pWF pl), pWF (pcomp' p pl)
+++++
intros [ar ml] pl H.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
pWF (pcomp' (pair ar ml) pl)
+++++
simpl.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
pWF (pcomp' (pair ar ml) pl)
+++++
apply pWF_pplusl.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
andl pWF (map (fun m : mon => pcomp_mon m pl) (snd (pair ar ml)))
+++++
induction ml.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.

*****
H : andl pWF pl
pl : list pol
ar : nat
*****
andl pWF (map (fun m : mon => pcomp_mon m pl) (snd (pair ar nil)))
+++++
simpl in *.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.
simpl in *.

*****
H : andl pWF pl
pl : list pol
ar : nat
*****
True
+++++
trivial.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.

*****
IHml : andl pWF (map (fun m : mon => pcomp_mon m pl) (snd (pair ar ml)))
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
andl pWF (map (fun m : mon => pcomp_mon m pl) (snd (pair ar (cons a ml))))
+++++
simpl in *.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.
simpl in *.

*****
IHml : andl pWF (map (fun m : mon => pcomp_mon m pl) ml)
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
and (pWF (pcomp_mon a pl)) (andl pWF (map (fun m : mon => pcomp_mon m pl) ml))
+++++
trivial.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.
simpl in *.
trivial.

*****
IHml : andl pWF (map (fun m : mon => pcomp_mon m pl) ml)
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
and (pWF (pcomp_mon a pl)) (andl pWF (map (fun m : mon => pcomp_mon m pl) ml))
+++++
split.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.
simpl in *.
trivial.
split.

*****
IHml : andl pWF (map (fun m : mon => pcomp_mon m pl) ml)
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
pWF (pcomp_mon a pl)
+++++
trivial.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.
simpl in *.
trivial.
split.
trivial.

*****
IHml : andl pWF (map (fun m : mon => pcomp_mon m pl) ml)
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
pWF (pcomp_mon a pl)
+++++
apply pWF_pcomp_mon.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.
simpl in *.
trivial.
split.
trivial.
apply pWF_pcomp_mon.

*****
IHml : andl pWF (map (fun m : mon => pcomp_mon m pl) ml)
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
andl pWF pl
+++++
trivial.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.
simpl in *.
trivial.
split.

*****
IHml : andl pWF (map (fun m : mon => pcomp_mon m pl) ml)
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
andl pWF (map (fun m : mon => pcomp_mon m pl) ml)
+++++
trivial.
-----
Lemma pWF_pcomp' : forall p pl, andl pWF pl -> pWF (pcomp' p pl).
Proof.
intros [ar ml] pl H.
simpl.
apply pWF_pplusl.
induction ml.

*****

*****

+++++
Qed.
-----
Lemma pWF_pcomp : forall p pl,\n  andl pWF pl -> pWF (pcomp p pl).
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).

*****

*****
forall (p : pol) (pl : list pol) (_ : andl pWF pl), pWF (pcomp p pl)
+++++
Proof.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.

*****

*****
forall (p : pol) (pl : list pol) (_ : andl pWF pl), pWF (pcomp p pl)
+++++
intros [ar ml] pl H.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
pWF (pcomp (pair ar ml) pl)
+++++
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
le (fst (pcomp' (pair ar ml) pl)) (fst (pcomp (pair ar ml) pl))
+++++
rewrite parity_pcomp.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
le (fst (pcomp' (pair ar ml) pl)) (maxl (map fst pl))
+++++
unfold pcomp'.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
le (fst (pplusl (map (fun m : mon => pcomp_mon m pl) (snd (pair ar ml))))) (maxl (map fst pl))
+++++
rewrite parity_pplusl.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.
rewrite parity_pplusl.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
le (maxl (map fst (map (fun m : mon => pcomp_mon m pl) (snd (pair ar ml))))) (maxl (map fst pl))
+++++
rewrite map_map.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.
rewrite parity_pplusl.
rewrite map_map.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
le (maxl (map (fun x : mon => fst (pcomp_mon x pl)) (snd (pair ar ml)))) (maxl (map fst pl))
+++++
induction ml.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.
rewrite parity_pplusl.
rewrite map_map.
induction ml.

*****
H : andl pWF pl
pl : list pol
ar : nat
*****
le (maxl (map (fun x : mon => fst (pcomp_mon x pl)) (snd (pair ar nil)))) (maxl (map fst pl))
+++++
simpl.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.
rewrite parity_pplusl.
rewrite map_map.
induction ml.
simpl.

*****
H : andl pWF pl
pl : list pol
ar : nat
*****
le O (maxl (map fst pl))
+++++
omega.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.
rewrite parity_pplusl.
rewrite map_map.
induction ml.

*****
IHml : le\n (maxl (map (fun x : mon => fst (pcomp_mon x pl)) (snd (pair ar ml))))\n (maxl (map fst pl))
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
le (maxl (map (fun x : mon => fst (pcomp_mon x pl)) (snd (pair ar (cons a ml))))) (maxl (map fst pl))
+++++
simpl.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.
rewrite parity_pplusl.
rewrite map_map.
induction ml.
simpl.

*****
IHml : le\n (maxl (map (fun x : mon => fst (pcomp_mon x pl)) (snd (pair ar ml))))\n (maxl (map fst pl))
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
le (Init.Nat.max (maxl (map fst pl)) (maxl (map (fun _ : mon => maxl (map fst pl)) ml))) (maxl (map fst pl))
+++++
apply Nat.max_lub.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.
rewrite parity_pplusl.
rewrite map_map.
induction ml.
simpl.
apply Nat.max_lub.

*****
IHml : le\n (maxl (map (fun x : mon => fst (pcomp_mon x pl)) (snd (pair ar ml))))\n (maxl (map fst pl))
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
le (maxl (map fst pl)) (maxl (map fst pl))
+++++
trivial.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
rewrite parity_pcomp.
unfold pcomp'.
rewrite parity_pplusl.
rewrite map_map.
induction ml.
simpl.
apply Nat.max_lub.

*****
IHml : le\n (maxl (map (fun x : mon => fst (pcomp_mon x pl)) (snd (pair ar ml))))\n (maxl (map fst pl))
H : andl pWF pl
pl : list pol
ml : list mon
a : mon
ar : nat
*****
le (maxl (map (fun _ : mon => maxl (map fst pl)) ml)) (maxl (map fst pl))
+++++
trivial.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
pWF' (fst (pcomp' (pair ar ml) pl)) (snd (pcomp (pair ar ml) pl))
+++++
apply pWF_pcomp'.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).
apply pWF_pcomp'.

*****
H : andl pWF pl
pl : list pol
ml : list mon
ar : nat
*****
andl pWF pl
+++++
trivial.
-----
Lemma pWF_pcomp : forall p pl, andl pWF pl -> pWF (pcomp p pl).
Proof.
intros [ar ml] pl H.
apply pWF'_le with (ar1 := fst (pcomp' (ar, ml) pl)).

*****

*****

+++++
Qed.
-----
Lemma pcomp_pow'_correct : forall xn pl l,\n  peval (pcomp_pow' xn pl) l =\n  power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
-----
Lemma pcomp_pow'_correct : forall xn pl l, peval (pcomp_pow' xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).

*****

*****
forall (xn : pow) (pl : list pol) (l : list nat), eq (peval (pcomp_pow' xn pl) l) (power (peval (nth (fst xn) pl (pcst O O)) l) (snd xn))
+++++
Proof.
-----
Lemma pcomp_pow'_correct : forall xn pl l, peval (pcomp_pow' xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
Proof.

*****

*****
forall (xn : pow) (pl : list pol) (l : list nat), eq (peval (pcomp_pow' xn pl) l) (power (peval (nth (fst xn) pl (pcst O O)) l) (snd xn))
+++++
intros [x n] pl l.
-----
Lemma pcomp_pow'_correct : forall xn pl l, peval (pcomp_pow' xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
Proof.
intros [x n] pl l.

*****
l : list nat
pl : list pol
x,n : nat
*****
eq (peval (pcomp_pow' (pair x n) pl) l) (power (peval (nth (fst (pair x n)) pl (pcst O O)) l) (snd (pair x n)))
+++++
simpl.
-----
Lemma pcomp_pow'_correct : forall xn pl l, peval (pcomp_pow' xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
Proof.
intros [x n] pl l.
simpl.

*****
l : list nat
pl : list pol
x,n : nat
*****
eq (peval (pcomp_pow' (pair x n) pl) l) (power (peval (nth x pl (pcst O O)) l) n)
+++++
apply ppower_correct.
-----
Lemma pcomp_pow'_correct : forall xn pl l, peval (pcomp_pow' xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
Proof.
intros [x n] pl l.
simpl.
apply ppower_correct.

*****

*****

+++++
Qed.
-----
Lemma pcomp_pow_correct xn pl l :\n  peval (pcomp_pow xn pl) l =\n  power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
-----
Lemma pcomp_pow_correct xn pl l : peval (pcomp_pow xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).

*****
l : list nat
pl : list pol
xn : pow
*****
eq (peval (pcomp_pow xn pl) l) (power (peval (nth (fst xn) pl (pcst O O)) l) (snd xn))
+++++
Proof.
-----
Lemma pcomp_pow_correct xn pl l : peval (pcomp_pow xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
Proof.

*****
l : list nat
pl : list pol
xn : pow
*****
eq (peval (pcomp_pow xn pl) l) (power (peval (nth (fst xn) pl (pcst O O)) l) (snd xn))
+++++
intros.
-----
Lemma pcomp_pow_correct xn pl l : peval (pcomp_pow xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
Proof.
intros.

*****
l : list nat
pl : list pol
xn : pow
*****
eq (peval (pcomp_pow xn pl) l) (power (peval (nth (fst xn) pl (pcst O O)) l) (snd xn))
+++++
unfold pcomp_pow.
-----
Lemma pcomp_pow_correct xn pl l : peval (pcomp_pow xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
Proof.
intros.
unfold pcomp_pow.

*****
l : list nat
pl : list pol
xn : pow
*****
eq (peval (pair (maxl (map fst pl)) (snd (pcomp_pow' xn pl))) l) (power (peval (nth (fst xn) pl (pcst O O)) l) (snd xn))
+++++
apply pcomp_pow'_correct.
-----
Lemma pcomp_pow_correct xn pl l : peval (pcomp_pow xn pl) l = power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).
Proof.
intros.
unfold pcomp_pow.
apply pcomp_pow'_correct.

*****

*****

+++++
Qed.
-----
Lemma pcomp_mon'_correct : forall m pl l,\n  peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).

*****

*****
forall (m : mon) (pl : list pol) (l : list nat), eq (peval (pcomp_mon' m pl) l) (peval_mon m (map (fun p : pol => peval p l) pl))
+++++
Proof.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.

*****

*****
forall (m : mon) (pl : list pol) (l : list nat), eq (peval (pcomp_mon' m pl) l) (peval_mon m (map (fun p : pol => peval p l) pl))
+++++
intros [a xl] pl l.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.

*****
l : list nat
pl : list pol
xl : list pow
a : nat
*****
eq (peval (pcomp_mon' (pair a xl) pl) l) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
+++++
induction xl.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.

*****
l : list nat
pl : list pol
a : nat
*****
eq (peval (pcomp_mon' (pair a nil) pl) l) (peval_mon (pair a nil) (map (fun p : pol => peval p l) pl))
+++++
unfold peval.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold peval.

*****
l : list nat
pl : list pol
a : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (snd (pcomp_mon' (pair a nil) pl)))) (peval_mon (pair a nil) (map (fun p : pol => plusl (map (fun m : mon => peval_mon m l) (snd p))) pl))
+++++
unfold peval_mon.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold peval.
unfold peval_mon.

*****
l : list nat
pl : list pol
a : nat
*****
eq (plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x l) (snd m)))) (snd (pcomp_mon' (pair a nil) pl)))) (Init.Nat.mul (fst (pair a nil)) (multl (map (fun x : pow => peval_pow x (map (fun p : pol => plusl (map (fun m : mon => Init.Nat.mul (fst m) (multl (map (fun x0 : pow => peval_pow x0 l) (snd m)))) (snd p))) pl)) (snd (pair a nil)))))
+++++
simpl.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold peval.
unfold peval_mon.
simpl.

*****
l : list nat
pl : list pol
a : nat
*****
eq (Init.Nat.add (Init.Nat.mul (Init.Nat.mul a (S O)) (S O)) O) (Init.Nat.mul a (S O))
+++++
ring.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.

*****
IHxl : eq (peval (pcomp_mon' (pair a xl) pl) l)\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (peval (pcomp_mon' (pair a (cons a0 xl)) pl) l) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
unfold pcomp_mon' in *.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.

*****
IHxl : eq\n (peval\n (pscalar (fst (pair a xl))\n (pmultl\n (map (fun xn : pow => pcomp_pow xn pl) (snd (pair a xl)))))\n l) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (peval (pscalar (fst (pair a (cons a0 xl))) (pmultl (map (fun xn : pow => pcomp_pow xn pl) (snd (pair a (cons a0 xl)))))) l) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
simpl in *.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.

*****
IHxl : eq\n (peval\n (pscalar a (pmultl (map (fun xn : pow => pcomp_pow xn pl) xl))) l)\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (peval (pscalar a (pmult (pcomp_pow a0 pl) (pmultl (map (fun xn : pow => pcomp_pow xn pl) xl)))) l) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite pscalar_correct in *.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.

*****
IHxl : eq\n (Init.Nat.mul a\n (peval (pmultl (map (fun xn : pow => pcomp_pow xn pl) xl)) l))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Init.Nat.mul a (peval (pmult (pcomp_pow a0 pl) (pmultl (map (fun xn : pow => pcomp_pow xn pl) xl))) l)) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite pmult_correct in *.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.

*****
IHxl : eq\n (Init.Nat.mul a\n (peval (pmultl (map (fun xn : pow => pcomp_pow xn pl) xl)) l))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (peval (pcomp_pow a0 pl) l) (peval (pmultl (map (fun xn : pow => pcomp_pow xn pl) xl)) l))) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite pmultl_correct in *.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (peval (pcomp_pow a0 pl) l) (multl (map (fun p : pol => peval p l) (map (fun xn : pow => pcomp_pow xn pl) xl))))) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite mult_assoc.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (Nat.mul a (peval (pcomp_pow a0 pl) l)) (multl (map (fun p : pol => peval p l) (map (fun xn : pow => pcomp_pow xn pl) xl)))) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite (mult_comm a).
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (Nat.mul (peval (pcomp_pow a0 pl) l) a) (multl (map (fun p : pol => peval p l) (map (fun xn : pow => pcomp_pow xn pl) xl)))) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite <- mult_assoc.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (peval (pcomp_pow a0 pl) l) (Nat.mul a (multl (map (fun p : pol => peval p l) (map (fun xn : pow => pcomp_pow xn pl) xl))))) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite IHxl.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite IHxl.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (peval (pcomp_pow a0 pl) l) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite pcomp_pow_correct.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite IHxl.
rewrite pcomp_pow_correct.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (power (peval (nth (fst a0) pl (pcst O O)) l) (snd a0)) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
rewrite peval_nth.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite IHxl.
rewrite pcomp_pow_correct.
rewrite peval_nth.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (power (nth (fst a0) (map (fun p : pol => peval p l) pl) (peval (pcst O O) l)) (snd a0)) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))) (peval_mon (pair a (cons a0 xl)) (map (fun p : pol => peval p l) pl))
+++++
destruct a0 as [x n].
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite IHxl.
rewrite pcomp_pow_correct.
rewrite peval_nth.
destruct a0 as [x n].

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a,x,n : nat
*****
eq (Nat.mul (power (nth (fst (pair x n)) (map (fun p : pol => peval p l) pl) (peval (pcst O O) l)) (snd (pair x n))) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))) (peval_mon (pair a (cons (pair x n) xl)) (map (fun p : pol => peval p l) pl))
+++++
unfold peval_mon.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite IHxl.
rewrite pcomp_pow_correct.
rewrite peval_nth.
destruct a0 as [x n].
unfold peval_mon.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a,x,n : nat
*****
eq (Nat.mul (power (nth (fst (pair x n)) (map (fun p : pol => peval p l) pl) (peval (pcst O O) l)) (snd (pair x n))) (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => peval_pow x (map (fun p : pol => peval p l) pl)) (snd (pair a xl)))))) (Init.Nat.mul (fst (pair a (cons (pair x n) xl))) (multl (map (fun x : pow => peval_pow x (map (fun p : pol => peval p l) pl)) (snd (pair a (cons (pair x n) xl))))))
+++++
unfold peval_pow.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite IHxl.
rewrite pcomp_pow_correct.
rewrite peval_nth.
destruct a0 as [x n].
unfold peval_mon.
unfold peval_pow.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a,x,n : nat
*****
eq (Nat.mul (power (nth (fst (pair x n)) (map (fun p : pol => peval p l) pl) (peval (pcst O O) l)) (snd (pair x n))) (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => power (nth (fst x) (map (fun p : pol => peval p l) pl) O) (snd x)) (snd (pair a xl)))))) (Init.Nat.mul (fst (pair a (cons (pair x n) xl))) (multl (map (fun x : pow => power (nth (fst x) (map (fun p : pol => peval p l) pl) O) (snd x)) (snd (pair a (cons (pair x n) xl))))))
+++++
rewrite pcst_correct.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite IHxl.
rewrite pcomp_pow_correct.
rewrite peval_nth.
destruct a0 as [x n].
unfold peval_mon.
unfold peval_pow.
rewrite pcst_correct.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a,x,n : nat
*****
eq (Nat.mul (power (nth (fst (pair x n)) (map (fun p : pol => peval p l) pl) O) (snd (pair x n))) (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => power (nth (fst x) (map (fun p : pol => peval p l) pl) O) (snd x)) (snd (pair a xl)))))) (Init.Nat.mul (fst (pair a (cons (pair x n) xl))) (multl (map (fun x : pow => power (nth (fst x) (map (fun p : pol => peval p l) pl) O) (snd x)) (snd (pair a (cons (pair x n) xl))))))
+++++
simpl.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.
unfold pcomp_mon' in *.
simpl in *.
rewrite pscalar_correct in *.
rewrite pmult_correct in *.
rewrite pmultl_correct in *.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite IHxl.
rewrite pcomp_pow_correct.
rewrite peval_nth.
destruct a0 as [x n].
unfold peval_mon.
unfold peval_pow.
rewrite pcst_correct.
simpl.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl\n (map (fun p : pol => peval p l)\n (map (fun xn : pow => pcomp_pow xn pl) xl))))\n (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
l : list nat
pl : list pol
xl : list pow
a,x,n : nat
*****
eq (Nat.mul (power (nth x (map (fun p : pol => peval p l) pl) O) n) (Init.Nat.mul a (multl (map (fun x : pow => power (nth (fst x) (map (fun p : pol => peval p l) pl) O) (snd x)) xl)))) (Init.Nat.mul a (Init.Nat.mul (power (nth x (map (fun p : pol => peval p l) pl) O) n) (multl (map (fun x : pow => power (nth (fst x) (map (fun p : pol => peval p l) pl) O) (snd x)) xl))))
+++++
ring.
-----
Lemma pcomp_mon'_correct : forall m pl l, peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
induction xl.

*****

*****

+++++
Qed.
-----
Lemma pcomp_mon_correct : forall m pl l,\n  peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).
-----
Lemma pcomp_mon_correct : forall m pl l, peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).

*****

*****
forall (m : mon) (pl : list pol) (l : list nat), eq (peval (pcomp_mon m pl) l) (peval_mon m (map (fun p : pol => peval p l) pl))
+++++
Proof.
-----
Lemma pcomp_mon_correct : forall m pl l, peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.

*****

*****
forall (m : mon) (pl : list pol) (l : list nat), eq (peval (pcomp_mon m pl) l) (peval_mon m (map (fun p : pol => peval p l) pl))
+++++
intros [a xl] pl l.
-----
Lemma pcomp_mon_correct : forall m pl l, peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.

*****
l : list nat
pl : list pol
xl : list pow
a : nat
*****
eq (peval (pcomp_mon (pair a xl) pl) l) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
+++++
unfold pcomp_mon.
-----
Lemma pcomp_mon_correct : forall m pl l, peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
unfold pcomp_mon.

*****
l : list nat
pl : list pol
xl : list pow
a : nat
*****
eq (peval (pair (maxl (map fst pl)) (snd (pcomp_mon' (pair a xl) pl))) l) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
+++++
rewrite peval_parity.
-----
Lemma pcomp_mon_correct : forall m pl l, peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
unfold pcomp_mon.
rewrite peval_parity.

*****
l : list nat
pl : list pol
xl : list pow
a : nat
*****
eq (peval (pcomp_mon' (pair a xl) pl) l) (peval_mon (pair a xl) (map (fun p : pol => peval p l) pl))
+++++
apply pcomp_mon'_correct.
-----
Lemma pcomp_mon_correct : forall m pl l, peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).
Proof.
intros [a xl] pl l.
unfold pcomp_mon.
rewrite peval_parity.
apply pcomp_mon'_correct.

*****

*****

+++++
Qed.
-----
Lemma pcomp'_correct : forall p pl l,\n  peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).

*****

*****
forall (p : pol) (pl : list pol) (l : list nat), eq (peval (pcomp' p pl) l) (peval p (map (fun p' : pol => peval p' l) pl))
+++++
Proof.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.

*****

*****
forall (p : pol) (pl : list pol) (l : list nat), eq (peval (pcomp' p pl) l) (peval p (map (fun p' : pol => peval p' l) pl))
+++++
unfold pcomp'.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.

*****

*****
forall (p : pol) (pl : list pol) (l : list nat), eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) (snd p))) l) (peval p (map (fun p' : pol => peval p' l) pl))
+++++
intros [ar ml] pl l.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.

*****
l : list nat
pl : list pol
ml : list mon
ar : nat
*****
eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) (snd (pair ar ml)))) l) (peval (pair ar ml) (map (fun p' : pol => peval p' l) pl))
+++++
induction ml.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.

*****
l : list nat
pl : list pol
ar : nat
*****
eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) (snd (pair ar nil)))) l) (peval (pair ar nil) (map (fun p' : pol => peval p' l) pl))
+++++
simpl in *.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.
simpl in *.

*****
l : list nat
pl : list pol
ar : nat
*****
eq (peval (pcst O O) l) (peval (pair ar nil) (map (fun p' : pol => peval p' l) pl))
+++++
trivial.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.

*****
IHml : eq\n (peval\n (pplusl (map (fun m : mon => pcomp_mon m pl) (snd (pair ar ml))))\n l) (peval (pair ar ml) (map (fun p' : pol => peval p' l) pl))
l : list nat
pl : list pol
ml : list mon
a : mon
ar : nat
*****
eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) (snd (pair ar (cons a ml))))) l) (peval (pair ar (cons a ml)) (map (fun p' : pol => peval p' l) pl))
+++++
simpl in *.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.
simpl in *.

*****
IHml : eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) ml)) l)\n (peval (pair ar ml) (map (fun p' : pol => peval p' l) pl))
l : list nat
pl : list pol
ml : list mon
a : mon
ar : nat
*****
eq (peval (pplus (pcomp_mon a pl) (pplusl (map (fun m : mon => pcomp_mon m pl) ml))) l) (peval (pair ar (cons a ml)) (map (fun p' : pol => peval p' l) pl))
+++++
trivial.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.
simpl in *.
trivial.

*****
IHml : eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) ml)) l)\n (peval (pair ar ml) (map (fun p' : pol => peval p' l) pl))
l : list nat
pl : list pol
ml : list mon
a : mon
ar : nat
*****
eq (peval (pplus (pcomp_mon a pl) (pplusl (map (fun m : mon => pcomp_mon m pl) ml))) l) (peval (pair ar (cons a ml)) (map (fun p' : pol => peval p' l) pl))
+++++
rewrite pplus_correct.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.
simpl in *.
trivial.
rewrite pplus_correct.

*****
IHml : eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) ml)) l)\n (peval (pair ar ml) (map (fun p' : pol => peval p' l) pl))
l : list nat
pl : list pol
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (peval (pcomp_mon a pl) l) (peval (pplusl (map (fun m : mon => pcomp_mon m pl) ml)) l)) (peval (pair ar (cons a ml)) (map (fun p' : pol => peval p' l) pl))
+++++
rewrite pcomp_mon_correct.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcomp_mon_correct.

*****
IHml : eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) ml)) l)\n (peval (pair ar ml) (map (fun p' : pol => peval p' l) pl))
l : list nat
pl : list pol
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (peval_mon a (map (fun p : pol => peval p l) pl)) (peval (pplusl (map (fun m : mon => pcomp_mon m pl) ml)) l)) (peval (pair ar (cons a ml)) (map (fun p' : pol => peval p' l) pl))
+++++
rewrite IHml.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.
simpl in *.
trivial.
rewrite pplus_correct.
rewrite pcomp_mon_correct.
rewrite IHml.

*****
IHml : eq (peval (pplusl (map (fun m : mon => pcomp_mon m pl) ml)) l)\n (peval (pair ar ml) (map (fun p' : pol => peval p' l) pl))
l : list nat
pl : list pol
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (peval_mon a (map (fun p : pol => peval p l) pl)) (peval (pair ar ml) (map (fun p' : pol => peval p' l) pl))) (peval (pair ar (cons a ml)) (map (fun p' : pol => peval p' l) pl))
+++++
trivial.
-----
Lemma pcomp'_correct : forall p pl l, peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).
Proof.
unfold pcomp'.
intros [ar ml] pl l.
induction ml.

*****

*****

+++++
Qed.
-----
Lemma pcomp_correct p pl l :\n  peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).
-----
Lemma pcomp_correct p pl l : peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).

*****
l : list nat
pl : list pol
p : pol
*****
eq (peval (pcomp p pl) l) (peval p (map (fun p : pol => peval p l) pl))
+++++
Proof.
-----
Lemma pcomp_correct p pl l : peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).
Proof.

*****
l : list nat
pl : list pol
p : pol
*****
eq (peval (pcomp p pl) l) (peval p (map (fun p : pol => peval p l) pl))
+++++
intros.
-----
Lemma pcomp_correct p pl l : peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).
Proof.
intros.

*****
l : list nat
pl : list pol
p : pol
*****
eq (peval (pcomp p pl) l) (peval p (map (fun p : pol => peval p l) pl))
+++++
unfold pcomp.
-----
Lemma pcomp_correct p pl l : peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).
Proof.
intros.
unfold pcomp.

*****
l : list nat
pl : list pol
p : pol
*****
eq (peval (pair (maxl (map fst pl)) (snd (pcomp' p pl))) l) (peval p (map (fun p : pol => peval p l) pl))
+++++
rewrite peval_parity.
-----
Lemma pcomp_correct p pl l : peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).
Proof.
intros.
unfold pcomp.
rewrite peval_parity.

*****
l : list nat
pl : list pol
p : pol
*****
eq (peval (pcomp' p pl) l) (peval p (map (fun p : pol => peval p l) pl))
+++++
apply pcomp'_correct.
-----
Lemma pcomp_correct p pl l : peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).
Proof.
intros.
unfold pcomp.
rewrite peval_parity.
apply pcomp'_correct.

*****

*****

+++++
Qed.
-----
Definition pshift_pow (xn:pow) : pow :=\n  (S (fst xn), snd xn).
-----
Definition pshift_mon (m:mon) : mon :=\n  (fst m, map pshift_pow (snd m)).
-----
Definition pshift (p:pol) : pol :=\n  (S (fst p), map pshift_mon (snd p)).
-----
Lemma parity_pshift : forall p,\n  parity (pshift p) = S (parity p).
-----
Lemma parity_pshift : forall p, parity (pshift p) = S (parity p).

*****

*****
forall p : pol, eq (fst (pshift p)) (S (fst p))
+++++
Proof.
-----
Lemma parity_pshift : forall p, parity (pshift p) = S (parity p).
Proof.

*****

*****
forall p : pol, eq (fst (pshift p)) (S (fst p))
+++++
intros [ar ml].
-----
Lemma parity_pshift : forall p, parity (pshift p) = S (parity p).
Proof.
intros [ar ml].

*****
ml : list mon
ar : nat
*****
eq (fst (pshift (pair ar ml))) (S (fst (pair ar ml)))
+++++
trivial.
-----
Lemma parity_pshift : forall p, parity (pshift p) = S (parity p).
Proof.
intros [ar ml].
trivial.

*****

*****

+++++
Qed.
-----
Lemma pWF_pshift_mon : forall ar m,\n  pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).

*****

*****
forall (ar : nat) (m : mon) (_ : pWF_mon ar m), pWF_mon (S ar) (pshift_mon m)
+++++
Proof.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.

*****

*****
forall (ar : nat) (m : mon) (_ : pWF_mon ar m), pWF_mon (S ar) (pshift_mon m)
+++++
unfold pWF_mon.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.

*****

*****
forall (ar : nat) (m : mon) (_ : andl (pWF_pow ar) (snd m)), andl (pWF_pow (S ar)) (snd (pshift_mon m))
+++++
unfold pWF_pow.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.

*****

*****
forall (ar : nat) (m : mon) (_ : andl (fun xn : pow => lt (fst xn) ar) (snd m)), andl (fun xn : pow => lt (fst xn) (S ar)) (snd (pshift_mon m))
+++++
intros ar [a xl] H.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.

*****
H : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
andl (fun xn : pow => lt (fst xn) (S ar)) (snd (pshift_mon (pair a xl)))
+++++
simpl.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.

*****
H : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a xl))
xl : list pow
ar,a : nat
*****
andl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl)
+++++
induction xl as [ | [x n] xl' IH].
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.
induction xl as [ | [x n] xl' IH].

*****
H : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a nil))
ar,a : nat
*****
andl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow nil)
+++++
simpl in *.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.
induction xl as [ | [x n] xl' IH].
simpl in *.

*****
H : True
ar,a : nat
*****
True
+++++
trivial.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.
induction xl as [ | [x n] xl' IH].

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) (snd (pair a xl')),\nandl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl')
H : andl (fun xn : pow => lt (fst xn) ar)\n (snd (pair a (cons (pair x n) xl')))
xl' : list pow
ar,a,x,n : nat
*****
andl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow (cons (pair x n) xl'))
+++++
simpl in *.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.
induction xl as [ | [x n] xl' IH].
simpl in *.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\nandl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl')
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
xl' : list pow
ar,a,x,n : nat
*****
and (lt (S x) (S ar)) (andl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl'))
+++++
trivial.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\nandl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl')
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
xl' : list pow
ar,a,x,n : nat
*****
and (lt (S x) (S ar)) (andl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl'))
+++++
split.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
split.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\nandl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl')
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
xl' : list pow
ar,a,x,n : nat
*****
lt (S x) (S ar)
+++++
omega.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.
induction xl as [ | [x n] xl' IH].
simpl in *.
trivial.
split.

*****
IH : forall _ : andl (fun xn : pow => lt (fst xn) ar) xl',\nandl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl')
H : and (lt x ar) (andl (fun xn : pow => lt (fst xn) ar) xl')
xl' : list pow
ar,a,x,n : nat
*****
andl (fun xn : pow => lt (fst xn) (S ar)) (map pshift_pow xl')
+++++
tauto.
-----
Lemma pWF_pshift_mon : forall ar m, pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).
Proof.
unfold pWF_mon.
unfold pWF_pow.
intros ar [a xl] H.
simpl.
induction xl as [ | [x n] xl' IH].

*****

*****

+++++
Qed.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).

*****

*****
forall (p : pol) (_ : pWF p), pWF (pshift p)
+++++
Proof.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.

*****

*****
forall (p : pol) (_ : pWF p), pWF (pshift p)
+++++
unfold pWF.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.

*****

*****
forall (p : pol) (_ : pWF' (fst p) (snd p)), pWF' (fst (pshift p)) (snd (pshift p))
+++++
intros [ar ml] H.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.

*****
H : pWF' (fst (pair ar ml)) (snd (pair ar ml))
ml : list mon
ar : nat
*****
pWF' (fst (pshift (pair ar ml))) (snd (pshift (pair ar ml)))
+++++
simpl.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.

*****
H : pWF' (fst (pair ar ml)) (snd (pair ar ml))
ml : list mon
ar : nat
*****
pWF' (S ar) (map pshift_mon ml)
+++++
induction ml.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.

*****
H : pWF' (fst (pair ar nil)) (snd (pair ar nil))
ar : nat
*****
pWF' (S ar) (map pshift_mon nil)
+++++
simpl in *.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.
simpl in *.

*****
H : True
ar : nat
*****
True
+++++
trivial.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.

*****
IHml : forall _ : pWF' (fst (pair ar ml)) (snd (pair ar ml)),\npWF' (S ar) (map pshift_mon ml)
H : pWF' (fst (pair ar (cons a ml))) (snd (pair ar (cons a ml)))
ml : list mon
a : mon
ar : nat
*****
pWF' (S ar) (map pshift_mon (cons a ml))
+++++
simpl in *.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.
simpl in *.

*****
IHml : forall _ : pWF' ar ml, pWF' (S ar) (map pshift_mon ml)
H : and (pWF_mon ar a) (pWF' ar ml)
ml : list mon
a : mon
ar : nat
*****
and (pWF_mon (S ar) (pshift_mon a)) (pWF' (S ar) (map pshift_mon ml))
+++++
trivial.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.
simpl in *.
trivial.

*****
IHml : forall _ : pWF' ar ml, pWF' (S ar) (map pshift_mon ml)
H : and (pWF_mon ar a) (pWF' ar ml)
ml : list mon
a : mon
ar : nat
*****
and (pWF_mon (S ar) (pshift_mon a)) (pWF' (S ar) (map pshift_mon ml))
+++++
split.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.
simpl in *.
trivial.
split.

*****
IHml : forall _ : pWF' ar ml, pWF' (S ar) (map pshift_mon ml)
H : and (pWF_mon ar a) (pWF' ar ml)
ml : list mon
a : mon
ar : nat
*****
pWF_mon (S ar) (pshift_mon a)
+++++
idtac.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.
simpl in *.
trivial.
split.
idtac.

*****
IHml : forall _ : pWF' ar ml, pWF' (S ar) (map pshift_mon ml)
H : and (pWF_mon ar a) (pWF' ar ml)
ml : list mon
a : mon
ar : nat
*****
pWF_mon (S ar) (pshift_mon a)
+++++
apply pWF_pshift_mon.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.
simpl in *.
trivial.
split.
idtac.
apply pWF_pshift_mon.

*****
IHml : forall _ : pWF' ar ml, pWF' (S ar) (map pshift_mon ml)
H : and (pWF_mon ar a) (pWF' ar ml)
ml : list mon
a : mon
ar : nat
*****
pWF_mon ar a
+++++
tauto.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.
simpl in *.
trivial.
split.

*****
IHml : forall _ : pWF' ar ml, pWF' (S ar) (map pshift_mon ml)
H : and (pWF_mon ar a) (pWF' ar ml)
ml : list mon
a : mon
ar : nat
*****
pWF' (S ar) (map pshift_mon ml)
+++++
tauto.
-----
Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).
Proof.
unfold pWF.
intros [ar ml] H.
simpl.
induction ml.

*****

*****

+++++
Qed.
-----
Lemma pshift_pow_correct : forall xn l,\n  peval_pow (pshift_pow xn) l = peval_pow xn (tl l).
-----
Lemma pshift_pow_correct : forall xn l, peval_pow (pshift_pow xn) l = peval_pow xn (tl l).

*****

*****
forall (xn : pow) (l : list nat), eq (peval_pow (pshift_pow xn) l) (peval_pow xn (tl l))
+++++
Proof.
-----
Lemma pshift_pow_correct : forall xn l, peval_pow (pshift_pow xn) l = peval_pow xn (tl l).
Proof.

*****

*****
forall (xn : pow) (l : list nat), eq (peval_pow (pshift_pow xn) l) (peval_pow xn (tl l))
+++++
unfold peval_pow.
-----
Lemma pshift_pow_correct : forall xn l, peval_pow (pshift_pow xn) l = peval_pow xn (tl l).
Proof.
unfold peval_pow.

*****

*****
forall (xn : pow) (l : list nat), eq (power (nth (fst (pshift_pow xn)) l O) (snd (pshift_pow xn))) (power (nth (fst xn) (tl l) O) (snd xn))
+++++
intros [x n] l.
-----
Lemma pshift_pow_correct : forall xn l, peval_pow (pshift_pow xn) l = peval_pow xn (tl l).
Proof.
unfold peval_pow.
intros [x n] l.

*****
l : list nat
x,n : nat
*****
eq (power (nth (fst (pshift_pow (pair x n))) l O) (snd (pshift_pow (pair x n)))) (power (nth (fst (pair x n)) (tl l) O) (snd (pair x n)))
+++++
simpl.
-----
Lemma pshift_pow_correct : forall xn l, peval_pow (pshift_pow xn) l = peval_pow xn (tl l).
Proof.
unfold peval_pow.
intros [x n] l.
simpl.

*****
l : list nat
x,n : nat
*****
eq (power (nth (S x) l O) n) (power (nth x (tl l) O) n)
+++++
f_equal.
-----
Lemma pshift_pow_correct : forall xn l, peval_pow (pshift_pow xn) l = peval_pow xn (tl l).
Proof.
unfold peval_pow.
intros [x n] l.
simpl.
f_equal.

*****
l : list nat
x,n : nat
*****
eq (nth (S x) l O) (nth x (tl l) O)
+++++
rewrite nth_S_tl.
-----
Lemma pshift_pow_correct : forall xn l, peval_pow (pshift_pow xn) l = peval_pow xn (tl l).
Proof.
unfold peval_pow.
intros [x n] l.
simpl.
f_equal.
rewrite nth_S_tl.

*****
l : list nat
x,n : nat
*****
eq (nth (S x) l O) (nth (S x) l O)
+++++
trivial.
-----
Lemma pshift_pow_correct : forall xn l, peval_pow (pshift_pow xn) l = peval_pow xn (tl l).
Proof.
unfold peval_pow.
intros [x n] l.
simpl.
f_equal.
rewrite nth_S_tl.
trivial.

*****

*****

+++++
Qed.
-----
Lemma pshift_mon_correct : forall m l,\n  peval_mon (pshift_mon m) l = peval_mon m (tl l).
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).

*****

*****
forall (m : mon) (l : list nat), eq (peval_mon (pshift_mon m) l) (peval_mon m (tl l))
+++++
Proof.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.

*****

*****
forall (m : mon) (l : list nat), eq (peval_mon (pshift_mon m) l) (peval_mon m (tl l))
+++++
unfold peval_mon.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.

*****

*****
forall (m : mon) (l : list nat), eq (Init.Nat.mul (fst (pshift_mon m)) (multl (map (fun x : pow => peval_pow x l) (snd (pshift_mon m))))) (Init.Nat.mul (fst m) (multl (map (fun x : pow => peval_pow x (tl l)) (snd m))))
+++++
intros [a xl] l.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.

*****
l : list nat
xl : list pow
a : nat
*****
eq (Init.Nat.mul (fst (pshift_mon (pair a xl))) (multl (map (fun x : pow => peval_pow x l) (snd (pshift_mon (pair a xl)))))) (Init.Nat.mul (fst (pair a xl)) (multl (map (fun x : pow => peval_pow x (tl l)) (snd (pair a xl)))))
+++++
induction xl.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.

*****
l : list nat
a : nat
*****
eq (Init.Nat.mul (fst (pshift_mon (pair a nil))) (multl (map (fun x : pow => peval_pow x l) (snd (pshift_mon (pair a nil)))))) (Init.Nat.mul (fst (pair a nil)) (multl (map (fun x : pow => peval_pow x (tl l)) (snd (pair a nil)))))
+++++
simpl in *.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.
simpl in *.

*****
l : list nat
a : nat
*****
eq (Init.Nat.mul a (S O)) (Init.Nat.mul a (S O))
+++++
trivial.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.

*****
IHxl : eq\n (Init.Nat.mul (fst (pshift_mon (pair a xl)))\n (multl\n (map (fun x : pow => peval_pow x l)\n (snd (pshift_mon (pair a xl))))))\n (Init.Nat.mul (fst (pair a xl))\n (multl (map (fun x : pow => peval_pow x (tl l)) (snd (pair a xl)))))
l : list nat
xl : list pow
a0 : pow
a : nat
*****
eq (Init.Nat.mul (fst (pshift_mon (pair a (cons a0 xl)))) (multl (map (fun x : pow => peval_pow x l) (snd (pshift_mon (pair a (cons a0 xl))))))) (Init.Nat.mul (fst (pair a (cons a0 xl))) (multl (map (fun x : pow => peval_pow x (tl l)) (snd (pair a (cons a0 xl))))))
+++++
simpl in *.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.
simpl in *.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))\n (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (tl l)) xl)))
l : list nat
xl : list pow
a0 : pow
a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (peval_pow (pshift_pow a0) l) (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (tl l)) (multl (map (fun x : pow => peval_pow x (tl l)) xl))))
+++++
trivial.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.
simpl in *.
trivial.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))\n (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (tl l)) xl)))
l : list nat
xl : list pow
a0 : pow
a : nat
*****
eq (Init.Nat.mul a (Init.Nat.mul (peval_pow (pshift_pow a0) l) (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (tl l)) (multl (map (fun x : pow => peval_pow x (tl l)) xl))))
+++++
rewrite mult_assoc.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.
simpl in *.
trivial.
rewrite mult_assoc.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))\n (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (tl l)) xl)))
l : list nat
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (Nat.mul a (peval_pow (pshift_pow a0) l)) (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl)))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (tl l)) (multl (map (fun x : pow => peval_pow x (tl l)) xl))))
+++++
rewrite (mult_comm a).
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.
simpl in *.
trivial.
rewrite mult_assoc.
rewrite (mult_comm a).

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))\n (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (tl l)) xl)))
l : list nat
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (Nat.mul (peval_pow (pshift_pow a0) l) a) (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl)))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (tl l)) (multl (map (fun x : pow => peval_pow x (tl l)) xl))))
+++++
rewrite <- mult_assoc.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.
simpl in *.
trivial.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))\n (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (tl l)) xl)))
l : list nat
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (peval_pow (pshift_pow a0) l) (Nat.mul a (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (tl l)) (multl (map (fun x : pow => peval_pow x (tl l)) xl))))
+++++
rewrite pshift_pow_correct.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.
simpl in *.
trivial.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite pshift_pow_correct.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))\n (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (tl l)) xl)))
l : list nat
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (peval_pow a0 (tl l)) (Nat.mul a (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (tl l)) (multl (map (fun x : pow => peval_pow x (tl l)) xl))))
+++++
rewrite IHxl.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.
simpl in *.
trivial.
rewrite mult_assoc.
rewrite (mult_comm a).
rewrite <- mult_assoc.
rewrite pshift_pow_correct.
rewrite IHxl.

*****
IHxl : eq\n (Init.Nat.mul a\n (multl (map (fun x : pow => peval_pow x l) (map pshift_pow xl))))\n (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (tl l)) xl)))
l : list nat
xl : list pow
a0 : pow
a : nat
*****
eq (Nat.mul (peval_pow a0 (tl l)) (Init.Nat.mul a (multl (map (fun x : pow => peval_pow x (tl l)) xl)))) (Init.Nat.mul a (Init.Nat.mul (peval_pow a0 (tl l)) (multl (map (fun x : pow => peval_pow x (tl l)) xl))))
+++++
ring.
-----
Lemma pshift_mon_correct : forall m l, peval_mon (pshift_mon m) l = peval_mon m (tl l).
Proof.
unfold peval_mon.
intros [a xl] l.
induction xl.

*****

*****

+++++
Qed.
-----
Lemma pshift_correct : forall p l,\n  peval (pshift p) l = peval p (tl l).
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).

*****

*****
forall (p : pol) (l : list nat), eq (peval (pshift p) l) (peval p (tl l))
+++++
Proof.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.

*****

*****
forall (p : pol) (l : list nat), eq (peval (pshift p) l) (peval p (tl l))
+++++
unfold peval.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.

*****

*****
forall (p : pol) (l : list nat), eq (plusl (map (fun m : mon => peval_mon m l) (snd (pshift p)))) (plusl (map (fun m : mon => peval_mon m (tl l)) (snd p)))
+++++
intros [ar ml] l.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.

*****
l : list nat
ml : list mon
ar : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (snd (pshift (pair ar ml))))) (plusl (map (fun m : mon => peval_mon m (tl l)) (snd (pair ar ml))))
+++++
induction ml.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.
induction ml.

*****
l : list nat
ar : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (snd (pshift (pair ar nil))))) (plusl (map (fun m : mon => peval_mon m (tl l)) (snd (pair ar nil))))
+++++
simpl in *.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.
induction ml.
simpl in *.

*****
l : list nat
ar : nat
*****
eq O O
+++++
trivial.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.
induction ml.

*****
IHml : eq\n (plusl\n (map (fun m : mon => peval_mon m l) (snd (pshift (pair ar ml)))))\n (plusl (map (fun m : mon => peval_mon m (tl l)) (snd (pair ar ml))))
l : list nat
ml : list mon
a : mon
ar : nat
*****
eq (plusl (map (fun m : mon => peval_mon m l) (snd (pshift (pair ar (cons a ml)))))) (plusl (map (fun m : mon => peval_mon m (tl l)) (snd (pair ar (cons a ml)))))
+++++
simpl in *.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.
induction ml.
simpl in *.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon m l) (map pshift_mon ml)))\n (plusl (map (fun m : mon => peval_mon m (tl l)) ml))
l : list nat
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (peval_mon (pshift_mon a) l) (plusl (map (fun m : mon => peval_mon m l) (map pshift_mon ml)))) (Init.Nat.add (peval_mon a (tl l)) (plusl (map (fun m : mon => peval_mon m (tl l)) ml)))
+++++
trivial.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.
induction ml.
simpl in *.
trivial.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon m l) (map pshift_mon ml)))\n (plusl (map (fun m : mon => peval_mon m (tl l)) ml))
l : list nat
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (peval_mon (pshift_mon a) l) (plusl (map (fun m : mon => peval_mon m l) (map pshift_mon ml)))) (Init.Nat.add (peval_mon a (tl l)) (plusl (map (fun m : mon => peval_mon m (tl l)) ml)))
+++++
rewrite pshift_mon_correct.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.
induction ml.
simpl in *.
trivial.
rewrite pshift_mon_correct.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon m l) (map pshift_mon ml)))\n (plusl (map (fun m : mon => peval_mon m (tl l)) ml))
l : list nat
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (peval_mon a (tl l)) (plusl (map (fun m : mon => peval_mon m l) (map pshift_mon ml)))) (Init.Nat.add (peval_mon a (tl l)) (plusl (map (fun m : mon => peval_mon m (tl l)) ml)))
+++++
rewrite IHml.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.
induction ml.
simpl in *.
trivial.
rewrite pshift_mon_correct.
rewrite IHml.

*****
IHml : eq (plusl (map (fun m : mon => peval_mon m l) (map pshift_mon ml)))\n (plusl (map (fun m : mon => peval_mon m (tl l)) ml))
l : list nat
ml : list mon
a : mon
ar : nat
*****
eq (Init.Nat.add (peval_mon a (tl l)) (plusl (map (fun m : mon => peval_mon m (tl l)) ml))) (Init.Nat.add (peval_mon a (tl l)) (plusl (map (fun m : mon => peval_mon m (tl l)) ml)))
+++++
trivial.
-----
Lemma pshift_correct : forall p l, peval (pshift p) l = peval p (tl l).
Proof.
unfold peval.
intros [ar ml] l.
induction ml.

*****

*****

+++++
Qed.
-----
Definition psum (start len : nat) : pol :=\n  pplus (pcst (start+len) 0) (pplusl (map (pproj (start+len)) (seq start len))).
-----
Lemma psum_correct start len l :\n  peval (psum start len) l = \n  plusl (map (fun i => nth i l 0) (seq start len)).
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).

*****
l : list nat
start,len : nat
*****
eq (peval (psum start len) l) (plusl (map (fun i : nat => nth i l O) (seq start len)))
+++++
Proof.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.

*****
l : list nat
start,len : nat
*****
eq (peval (psum start len) l) (plusl (map (fun i : nat => nth i l O) (seq start len)))
+++++
intros.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.

*****
l : list nat
start,len : nat
*****
eq (peval (psum start len) l) (plusl (map (fun i : nat => nth i l O) (seq start len)))
+++++
unfold psum.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.

*****
l : list nat
start,len : nat
*****
eq (peval (pplus (pcst (Init.Nat.add start len) O) (pplusl (map (pproj (Init.Nat.add start len)) (seq start len)))) l) (plusl (map (fun i : nat => nth i l O) (seq start len)))
+++++
rewrite pplus_correct.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.

*****
l : list nat
start,len : nat
*****
eq (Init.Nat.add (peval (pcst (Init.Nat.add start len) O) l) (peval (pplusl (map (pproj (Init.Nat.add start len)) (seq start len))) l)) (plusl (map (fun i : nat => nth i l O) (seq start len)))
+++++
rewrite pcst_correct.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.

*****
l : list nat
start,len : nat
*****
eq (Init.Nat.add O (peval (pplusl (map (pproj (Init.Nat.add start len)) (seq start len))) l)) (plusl (map (fun i : nat => nth i l O) (seq start len)))
+++++
rewrite pplusl_correct.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.

*****
l : list nat
start,len : nat
*****
eq (Init.Nat.add O (plusl (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) (seq start len))))) (plusl (map (fun i : nat => nth i l O) (seq start len)))
+++++
simpl.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.

*****
l : list nat
start,len : nat
*****
eq (plusl (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) (seq start len)))) (plusl (map (fun i : nat => nth i l O) (seq start len)))
+++++
f_equal.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.

*****
l : list nat
start,len : nat
*****
eq (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) (seq start len))) (map (fun i : nat => nth i l O) (seq start len))
+++++
induction (seq start len).
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).

*****
l : list nat
start,len : nat
*****
eq (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) nil)) (map (fun i : nat => nth i l O) nil)
+++++
simpl.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).
simpl.

*****
l : list nat
start,len : nat
*****
eq nil nil
+++++
intros.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).
simpl.
intros.

*****
l : list nat
start,len : nat
*****
eq nil nil
+++++
trivial.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).

*****
IHl0 : eq\n (map (fun p : pol => peval p l)\n (map (pproj (Init.Nat.add start len)) l0))\n (map (fun i : nat => nth i l O) l0)
l0 : list nat
a : nat
l : list nat
start,len : nat
*****
eq (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) (cons a l0))) (map (fun i : nat => nth i l O) (cons a l0))
+++++
simpl.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).
simpl.

*****
IHl0 : eq\n (map (fun p : pol => peval p l)\n (map (pproj (Init.Nat.add start len)) l0))\n (map (fun i : nat => nth i l O) l0)
l0 : list nat
a : nat
l : list nat
start,len : nat
*****
eq (cons (peval (pproj (Init.Nat.add start len) a) l) (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) l0))) (cons (nth a l O) (map (fun i : nat => nth i l O) l0))
+++++
intros.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).
simpl.
intros.

*****
IHl0 : eq\n (map (fun p : pol => peval p l)\n (map (pproj (Init.Nat.add start len)) l0))\n (map (fun i : nat => nth i l O) l0)
l0 : list nat
a : nat
l : list nat
start,len : nat
*****
eq (cons (peval (pproj (Init.Nat.add start len) a) l) (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) l0))) (cons (nth a l O) (map (fun i : nat => nth i l O) l0))
+++++
trivial.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).
simpl.
intros.
trivial.

*****
IHl0 : eq\n (map (fun p : pol => peval p l)\n (map (pproj (Init.Nat.add start len)) l0))\n (map (fun i : nat => nth i l O) l0)
l0 : list nat
a : nat
l : list nat
start,len : nat
*****
eq (cons (peval (pproj (Init.Nat.add start len) a) l) (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) l0))) (cons (nth a l O) (map (fun i : nat => nth i l O) l0))
+++++
rewrite pproj_correct.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).
simpl.
intros.
trivial.
rewrite pproj_correct.

*****
IHl0 : eq\n (map (fun p : pol => peval p l)\n (map (pproj (Init.Nat.add start len)) l0))\n (map (fun i : nat => nth i l O) l0)
l0 : list nat
a : nat
l : list nat
start,len : nat
*****
eq (cons (nth a l O) (map (fun p : pol => peval p l) (map (pproj (Init.Nat.add start len)) l0))) (cons (nth a l O) (map (fun i : nat => nth i l O) l0))
+++++
congruence.
-----
Lemma psum_correct start len l : peval (psum start len) l = plusl (map (fun i => nth i l 0) (seq start len)).
Proof.
intros.
unfold psum.
rewrite pplus_correct.
rewrite pcst_correct.
rewrite pplusl_correct.
simpl.
f_equal.
induction (seq start len).

*****

*****

+++++
Qed.
-----
Lemma pWF_psum start len : pWF (psum start len).
-----
Lemma pWF_psum start len : pWF (psum start len).

*****
start,len : nat
*****
pWF (psum start len)
+++++
Proof.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.

*****
start,len : nat
*****
pWF (psum start len)
+++++
intros.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.

*****
start,len : nat
*****
pWF (psum start len)
+++++
unfold psum.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.

*****
start,len : nat
*****
pWF (pplus (pcst (Init.Nat.add start len) O) (pplusl (map (pproj (Init.Nat.add start len)) (seq start len))))
+++++
apply pWF_pplus.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.

*****
start,len : nat
*****
pWF (pcst (Init.Nat.add start len) O)
+++++
apply pWF_pcst.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.

*****
start,len : nat
*****
pWF (pplusl (map (pproj (Init.Nat.add start len)) (seq start len)))
+++++
apply pWF_pplusl.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.
apply pWF_pplusl.

*****
start,len : nat
*****
andl pWF (map (pproj (Init.Nat.add start len)) (seq start len))
+++++
rewrite <- forall_andl.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.
apply pWF_pplusl.
rewrite <- forall_andl.

*****
start,len : nat
*****
forall (x : pol) (_ : In x (map (pproj (Init.Nat.add start len)) (seq start len))), pWF x
+++++
intros.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.
apply pWF_pplusl.
rewrite <- forall_andl.
intros.

*****
H : In x (map (pproj (Init.Nat.add start len)) (seq start len))
x : pol
start,len : nat
*****
pWF x
+++++
rewrite in_map_iff in H.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.
apply pWF_pplusl.
rewrite <- forall_andl.
intros.
rewrite in_map_iff in H.

*****
H : ex\n (fun x0 : nat =>\n and (eq (pproj (Init.Nat.add start len) x0) x)\n (In x0 (seq start len)))
x : pol
start,len : nat
*****
pWF x
+++++
destruct H as (y & H1 & H2).
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.
apply pWF_pplusl.
rewrite <- forall_andl.
intros.
rewrite in_map_iff in H.
destruct H as (y & H1 & H2).

*****
H2 : In y (seq start len)
H1 : eq (pproj (Init.Nat.add start len) y) x
y : nat
x : pol
start,len : nat
*****
pWF x
+++++
subst.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.
apply pWF_pplusl.
rewrite <- forall_andl.
intros.
rewrite in_map_iff in H.
destruct H as (y & H1 & H2).
subst.

*****
H2 : In y (seq start len)
start,len,y : nat
*****
pWF (pproj (Init.Nat.add start len) y)
+++++
apply pWF_pproj.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.
apply pWF_pplusl.
rewrite <- forall_andl.
intros.
rewrite in_map_iff in H.
destruct H as (y & H1 & H2).
subst.
apply pWF_pproj.

*****
H2 : In y (seq start len)
start,len,y : nat
*****
lt y (Init.Nat.add start len)
+++++
rewrite in_seq_iff in H2.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.
apply pWF_pplusl.
rewrite <- forall_andl.
intros.
rewrite in_map_iff in H.
destruct H as (y & H1 & H2).
subst.
apply pWF_pproj.
rewrite in_seq_iff in H2.

*****
H2 : and (le start y) (lt y (Init.Nat.add start len))
start,len,y : nat
*****
lt y (Init.Nat.add start len)
+++++
tauto.
-----
Lemma pWF_psum start len : pWF (psum start len).
Proof.
intros.
unfold psum.
apply pWF_pplus.

*****

*****

+++++
Qed.
-----
Lemma parity_psum start len : \n  parity (psum start len) = start + len.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.

*****
start,len : nat
*****
eq (fst (psum start len)) (Init.Nat.add start len)
+++++
Proof.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.

*****
start,len : nat
*****
eq (fst (psum start len)) (Init.Nat.add start len)
+++++
intros.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.

*****
start,len : nat
*****
eq (fst (psum start len)) (Init.Nat.add start len)
+++++
unfold psum.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.

*****
start,len : nat
*****
eq (fst (pplus (pcst (Init.Nat.add start len) O) (pplusl (map (pproj (Init.Nat.add start len)) (seq start len))))) (Init.Nat.add start len)
+++++
rewrite parity_pplus.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.

*****
start,len : nat
*****
eq (Init.Nat.max (fst (pcst (Init.Nat.add start len) O)) (fst (pplusl (map (pproj (Init.Nat.add start len)) (seq start len))))) (Init.Nat.add start len)
+++++
rewrite parity_pcst.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.

*****
start,len : nat
*****
eq (Init.Nat.max (Init.Nat.add start len) (fst (pplusl (map (pproj (Init.Nat.add start len)) (seq start len))))) (Init.Nat.add start len)
+++++
rewrite parity_pplusl.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.

*****
start,len : nat
*****
eq (Init.Nat.max (Init.Nat.add start len) (maxl (map fst (map (pproj (Init.Nat.add start len)) (seq start len))))) (Init.Nat.add start len)
+++++
rewrite max_l.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.

*****
start,len : nat
*****
eq (Init.Nat.add start len) (Init.Nat.add start len)
+++++
trivial.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.

*****
start,len : nat
*****
le (maxl (map fst (map (pproj (Init.Nat.add start len)) (seq start len)))) (Init.Nat.add start len)
+++++
trivial.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.
trivial.

*****
start,len : nat
*****
le (maxl (map fst (map (pproj (Init.Nat.add start len)) (seq start len)))) (Init.Nat.add start len)
+++++
apply maxl_map.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.
trivial.
apply maxl_map.

*****
start,len : nat
*****
forall (x : prod nat (list mon)) (_ : In x (map (pproj (Init.Nat.add start len)) (seq start len))), eq (fst x) (Init.Nat.add start len)
+++++
intros p H.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.
trivial.
apply maxl_map.
intros p H.

*****
H : In p (map (pproj (Init.Nat.add start len)) (seq start len))
p : prod nat (list mon)
start,len : nat
*****
eq (fst p) (Init.Nat.add start len)
+++++
rewrite in_map_iff in H.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.
trivial.
apply maxl_map.
intros p H.
rewrite in_map_iff in H.

*****
H : ex\n (fun x : nat =>\n and (eq (pproj (Init.Nat.add start len) x) p) (In x (seq start len)))
p : prod nat (list mon)
start,len : nat
*****
eq (fst p) (Init.Nat.add start len)
+++++
destruct H as (x & H & _).
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.
trivial.
apply maxl_map.
intros p H.
rewrite in_map_iff in H.
destruct H as (x & H & _).

*****
H : eq (pproj (Init.Nat.add start len) x) p
x : nat
p : prod nat (list mon)
start,len : nat
*****
eq (fst p) (Init.Nat.add start len)
+++++
subst.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.
trivial.
apply maxl_map.
intros p H.
rewrite in_map_iff in H.
destruct H as (x & H & _).
subst.

*****
start,len,x : nat
*****
eq (fst (pproj (Init.Nat.add start len) x)) (Init.Nat.add start len)
+++++
trivial.
-----
Lemma parity_psum start len : parity (psum start len) = start + len.
Proof.
intros.
unfold psum.
rewrite parity_pplus.
rewrite parity_pcst.
rewrite parity_pplusl.
rewrite max_l.

*****

*****

+++++
Qed.
-----
Ltac pWF :=\n  match goal with\n  | |- pWF (pcst _ _) => apply pWF_pcst\n  | |- pWF (pproj _ _) => apply pWF_pproj; try omega\n  | |- pWF (pscalar _ _) => apply pWF_pscalar; pWF\n  | |- pWF (pplus _ _) => apply pWF_pplus; pWF\n  | |- pWF (pplusl _) => apply pWF_pplusl; rewrite <- forall_andl; intros; pWF\n  | |- pWF (pmult _ _) => apply pWF_pmult; pWF\n  | |- pWF (pmultl _) => apply pWF_pmultl; rewrite <- forall_andl; intros; pWF\n  | |- pWF (ppower _ _) => apply pWF_ppower; pWF\n  | |- pWF (pcomp _ _) => apply pWF_pcomp; rewrite <- forall_andl; intros; pWF\n  | |- pWF (pshift _) => apply pWF_pshift; pWF\n  | |- pWF (psum _ _) => apply pWF_psum\n  | |- _ => idtac\n  end.
-----
Definition deg_mon (m:mon) : nat :=\n  plusl (map (@snd _ _) (snd m)).
-----
Definition deg (p:pol) : nat :=\n  maxl (map deg_mon (snd p)).
-----
