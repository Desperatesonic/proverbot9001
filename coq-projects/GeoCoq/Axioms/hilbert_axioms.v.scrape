From Coq Require Export Setoid.
-----
Class Hilbert_neutral_dimensionless :=\n{\n Point : Type;\n Line  : Type;\n Plane : Type;\n EqL   : Line -> Line -> Prop;\n EqL_Equiv : Equivalence EqL;\n EqP   : Plane -> Plane -> Prop;\n EqP_Equiv : Equivalence EqP;\n IncidL : Point -> Line -> Prop;\n IncidP : Point -> Plane -> Prop;\n\n IncidL_morphism :\n   forall P l m, IncidL P l -> EqL l m -> IncidL P m;\n IncidL_dec : forall P l, IncidL P l \/ ~ IncidL P l;\n IncidP_morphism :\n   forall M p q, IncidP M p -> EqP p q -> IncidP M q;\n IncidP_dec : forall M p, IncidP M p \/ ~ IncidP M p;\n eq_dec_pointsH : forall A B : Point, A=B \/ ~ A=B;\n\n \n line_existence :\n   forall A B, A <> B -> exists l, IncidL A l /\ IncidL B l;\n line_uniqueness :\n   forall A B l m,\n     A <> B ->\n     IncidL A l -> IncidL B l -> IncidL A m -> IncidL B m ->\n     EqL l m;\n two_points_on_line :\n   forall l,\n     { A : Point & { B | IncidL B l /\ IncidL A l /\ A <> B}};\n ColH :=\n   fun A B C => exists l, IncidL A l /\ IncidL B l /\ IncidL C l;\n PP : Point;\n PQ : Point;\n PR : Point;\n lower_dim_2 : PP <> PQ /\ PQ <> PR /\ PP <> PR /\ ~ ColH PP PQ PR;\n plane_existence :\n   forall A B C, ~ ColH A B C -> exists p, IncidP A p /\ IncidP B p /\ IncidP C p;\n one_point_on_plane :\n   forall p,\n     { A | IncidP A p };\n plane_uniqueness :\n   forall A B C p q,\n     ~ ColH A B C ->\n     IncidP A p -> IncidP B p -> IncidP C p -> IncidP A q -> IncidP B q -> IncidP C q ->\n     EqP p q;\n IncidLP :=\n   fun l p => forall A, IncidL A l -> IncidP A p;\n line_on_plane :\n   forall A B l p,\n     A <> B ->\n     IncidL A l -> IncidL B l -> IncidP A p -> IncidP B p ->\n     IncidLP l p;\n\n \n BetH   : Point -> Point -> Point -> Prop;\n between_diff : forall A B C, BetH A B C -> A <> C;\n between_col :  forall A B C, BetH A B C -> ColH A B C;\n between_comm : forall A B C, BetH A B C -> BetH C B A;\n between_out :  forall A B, A <> B -> exists C, BetH A B C;\n between_only_one : forall A B C, BetH A B C -> ~ BetH B C A;\n cut :=\n   fun l A B => ~ IncidL A l /\ ~ IncidL B l /\\n                exists I, IncidL I l /\ BetH A I B;\n pasch :\n   forall A B C l p,\n     ~ ColH A B C ->\n     IncidP A p -> IncidP B p -> IncidP C p -> IncidLP l p -> ~ IncidL C l -> cut l A B ->\n     cut l A C \/ cut l B C;\n\n \n CongH : Point -> Point -> Point -> Point -> Prop;\n cong_permr : forall A B C D, CongH A B C D -> CongH A B D C;\n outH :=\n   fun P A B => BetH P A B \/ BetH P B A \/ (P <> A /\ A = B);\n cong_existence :\n   forall A B A' P l,\n     A <> B -> A' <> P ->\n     IncidL A' l -> IncidL P l ->\n     exists B', IncidL B' l /\ outH A' P B' /\ CongH A' B' A B;\n cong_pseudo_transitivity :\n   forall A B C D E F,\n     CongH A B C D -> CongH A B E F -> CongH C D E F;\n disjoint := fun A B C D => ~ exists P, BetH A P B /\ BetH C P D;\n addition :\n   forall A B C A' B' C',\n     ColH A B C -> ColH A' B' C' ->\n     disjoint A B B C -> disjoint A' B' B' C' ->\n     CongH A B A' B' -> CongH B C B' C' ->\n     CongH A C A' C';\n CongaH :\n   Point -> Point -> Point -> Point -> Point -> Point -> Prop;\n conga_refl : forall A B C, ~ ColH A B C -> CongaH A B C A B C;\n conga_comm : forall A B C, ~ ColH A B C -> CongaH A B C C B A;\n conga_permlr :\n   forall A B C D E F, CongaH A B C D E F -> CongaH C B A F E D;\n same_side := fun A B l => exists P, cut l A P /\ cut l B P;\n same_side' :=\n   fun A B X Y =>\n     X <> Y /\\n     forall l, IncidL X l -> IncidL Y l -> same_side A B l;\n conga_out_conga :\n   forall A B C D E F A' C' D' F',\n    CongaH A B C D E F ->\n    outH B A A' -> outH B C C' -> outH E D D' -> outH E F F' ->\n    CongaH A' B C' D' E F';\n cong_4_existence :\n   forall A B C O X P,\n     ~ ColH P O X -> ~ ColH A B C ->\n     exists Y, CongaH A B C X O Y /\ same_side' P Y O X;\n cong_4_uniqueness :\n   forall A B C O P X Y Y',\n     ~ ColH P O X  -> ~ ColH A B C ->\n     CongaH A B C X O Y -> CongaH A B C X O Y' ->\n     same_side' P Y O X -> same_side' P Y' O X ->\n     outH O Y Y';\n cong_5 :\n   forall A B C A' B' C',\n     ~ ColH A B C -> ~ ColH A' B' C' ->\n     CongH A B A' B' -> CongH A C A' C' ->\n     CongaH B A C B' A' C' ->\n     CongaH A B C A' B' C'\n}.
-----
Class Hilbert_neutral_2D `(Hi : Hilbert_neutral_dimensionless) :=\n{\n pasch_2D :\n   forall A B C l,\n     ~ ColH A B C -> ~ IncidL C l -> cut l A B ->\n     cut l A C \/ cut l B C\n}.
-----
Class Hilbert_neutral_3D `(Hi : Hilbert_neutral_dimensionless) :=\n{\n plane_intersection :\n   forall A p q,\n     IncidP A p -> IncidP A q -> exists B, IncidP B p /\ IncidP B q /\ A <> B;\n HS1 : Point;\n HS2 : Point;\n HS3 : Point;\n HS4 : Point;\n lower_dim_3 : ~ exists p, IncidP HS1 p /\ IncidP HS2 p /\ IncidP HS3 p /\ IncidP HS4 p\n}.
-----
Class Hilbert_euclidean `(Hi : Hilbert_neutral_dimensionless) :=\n{\n Para :=\n   fun l m => (~ exists X, IncidL X l /\ IncidL X m) /\ exists p, IncidLP l p /\ IncidLP m p;\n euclid_uniqueness :\n   forall l P m1 m2,\n     ~ IncidL P l ->\n     Para l m1 -> IncidL P m1-> Para l m2 -> IncidL P m2 ->\n     EqL m1 m2\n}.
-----
Class Hilbert_euclidean_ID `(H_euclidean : Hilbert_euclidean) :=\n{\n decidability_of_intersection :\n   forall l m,\n     (exists I, IncidL I l /\ IncidL I m) \/\n     ~ (exists I, IncidL I l /\ IncidL I m)\n}.
-----
