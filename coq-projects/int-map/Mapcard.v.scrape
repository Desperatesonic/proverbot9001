From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
From Coq Require Import Arith.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Map.
-----
Require Import Mapaxioms.
-----
Require Import Mapiter.
-----
Require Import Fset.
-----
Require Import Mapsubset.
-----
From Coq Require Import List.
-----
Require Import Lsort.
-----
Require Import Coq.Arith.Peano_dec.
-----
Section MapCard.
-----
Variables A B : Type.
-----
Lemma MapCard_M0 : MapCard A (M0 A) = 0.
-----
Lemma MapCard_M0 : MapCard A (M0 A) = 0.

*****
A,B : Type
*****
eq (MapCard A (M0 A)) O
+++++
Proof.
-----
Lemma MapCard_M0 : MapCard A (M0 A) = 0.
Proof.

*****
A,B : Type
*****
eq (MapCard A (M0 A)) O
+++++
trivial.
-----
Lemma MapCard_M0 : MapCard A (M0 A) = 0.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapCard_M1 : forall (a:ad) (y:A), MapCard A (M1 A a y) = 1.
-----
Lemma MapCard_M1 : forall (a:ad) (y:A), MapCard A (M1 A a y) = 1.

*****
A,B : Type
*****
forall (a : ad) (y : A), eq (MapCard A (M1 A a y)) (S O)
+++++
Proof.
-----
Lemma MapCard_M1 : forall (a:ad) (y:A), MapCard A (M1 A a y) = 1.
Proof.

*****
A,B : Type
*****
forall (a : ad) (y : A), eq (MapCard A (M1 A a y)) (S O)
+++++
trivial.
-----
Lemma MapCard_M1 : forall (a:ad) (y:A), MapCard A (M1 A a y) = 1.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapCard_is_O :\n   forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.

*****
A,B : Type
*****
forall (m : Map A) (_ : eq (MapCard A m) O) (a : ad), eq (MapGet A m a) None
+++++
Proof.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (_ : eq (MapCard A m) O) (a : ad), eq (MapGet A m a) None
+++++
simple induction m.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (_ : eq (MapCard A (M0 A)) O) (a : ad), eq (MapGet A (M0 A) a) None
+++++
trivial.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (_ : eq (MapCard A (M1 A a a0)) O) (a1 : ad), eq (MapGet A (M1 A a a0) a1) None
+++++
intros a y H.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros a y H.

*****
H : eq (MapCard A (M1 A a y)) O
y : A
a : ad
m : Map A
A,B : Type
*****
forall a0 : ad, eq (MapGet A (M1 A a y) a0) None
+++++
discriminate H.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (_ : eq (MapCard A m) O) (a : ad), eq (MapGet A m a) None) (m0 : Map A) (_ : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None) (_ : eq (MapCard A (M2 A m m0)) O) (a : ad), eq (MapGet A (M2 A m m0) a) None
+++++
intros.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.

*****
a : ad
H1 : eq (MapCard A (M2 A m0 m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
simpl in H1.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.

*****
a : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
elim (plus_is_O _ _ H1).
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_O _ _ H1).

*****
a : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
forall (_ : eq (MapCard A m0) O) (_ : eq (MapCard A m1) O), eq (MapGet A (M2 A m0 m1) a) None
+++++
intros.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_O _ _ H1).
intros.

*****
H3 : eq (MapCard A m1) O
H2 : eq (MapCard A m0) O
a : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_O _ _ H1).
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).

*****
H3 : eq (MapCard A m1) O
H2 : eq (MapCard A m0) O
a : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a)) None
+++++
case (Nbit0 a).
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_O _ _ H1).
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
case (Nbit0 a).

*****
H3 : eq (MapCard A m1) O
H2 : eq (MapCard A m0) O
a : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A m1 (N.div2 a)) None
+++++
apply H0.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_O _ _ H1).
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
case (Nbit0 a).
apply H0.

*****
H3 : eq (MapCard A m1) O
H2 : eq (MapCard A m0) O
a : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A m1) O
+++++
assumption.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_O _ _ H1).
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
case (Nbit0 a).

*****
H3 : eq (MapCard A m1) O
H2 : eq (MapCard A m0) O
a : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A m0 (N.div2 a)) None
+++++
apply H.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_O _ _ H1).
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a).
case (Nbit0 a).
apply H.

*****
H3 : eq (MapCard A m1) O
H2 : eq (MapCard A m0) O
a : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) O
H0 : forall (_ : eq (MapCard A m1) O) (a : ad), eq (MapGet A m1 a) None
m1 : Map A
H : forall (_ : eq (MapCard A m0) O) (a : ad), eq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A m0) O
+++++
assumption.
-----
Lemma MapCard_is_O : forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_is_not_O :\n   forall (m:Map A) (a:ad) (y:A),\n     MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), sig (fun n : nat => eq (MapCard A m) (S n))
+++++
Proof.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), sig (fun n : nat => eq (MapCard A m) (S n))
+++++
simple induction m.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (y : A) (_ : eq (MapGet A (M0 A) a) (Some y)), sig (fun n : nat => eq (MapCard A (M0 A)) (S n))
+++++
intros.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.

*****
H : eq (MapGet A (M0 A) a) (Some y)
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M0 A)) (S n))
+++++
discriminate H.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)), sig (fun n : nat => eq (MapCard A (M1 A a a0)) (S n))
+++++
intros a y a0 y0 H.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros a y a0 y0 H.

*****
H : eq (MapGet A (M1 A a y) a0) (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M1 A a y)) (S n))
+++++
simpl in H.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.

*****
H : eq (if N.eqb a a0 then Some y else None) (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M1 A a y)) (S n))
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).

*****
H : eq (if N.eqb a a0 then Some y else None) (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, sig (fun n : nat => eq (MapCard A (M1 A a y)) (S n))
+++++
intro H0.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) true
H : eq (if N.eqb a a0 then Some y else None) (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M1 A a y)) (S n))
+++++
split with 0.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
split with 0.

*****
H0 : eq (N.eqb a a0) true
H : eq (if N.eqb a a0 then Some y else None) (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (M1 A a y)) (S O)
+++++
reflexivity.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).

*****
H : eq (if N.eqb a a0 then Some y else None) (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, sig (fun n : nat => eq (MapCard A (M1 A a y)) (S n))
+++++
intro H0.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) false
H : eq (if N.eqb a a0 then Some y else None) (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M1 A a y)) (S n))
+++++
rewrite H0 in H.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0 in H.

*****
H0 : eq (N.eqb a a0) false
H : eq None (Some y0)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M1 A a y)) (S n))
+++++
discriminate H.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), sig (fun n : nat => eq (MapCard A m) (S n))) (m0 : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)), sig (fun n : nat => eq (MapCard A m0) (S n))) (a : ad) (y : A) (_ : eq (MapGet A (M2 A m m0) a) (Some y)), sig (fun n : nat => eq (MapCard A (M2 A m m0)) (S n))
+++++
intros.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.

*****
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
intro H2.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) true
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H.

*****
H2 : eq (N.odd a) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
elim (X0 (Ndiv2 a) y H).
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H.
elim (X0 (Ndiv2 a) y H).

*****
H2 : eq (N.odd a) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
forall (x : nat) (_ : eq (MapCard A m1) (S x)), sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
intros n H3.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H.
elim (X0 (Ndiv2 a) y H).
intros n H3.

*****
H3 : eq (MapCard A m1) (S n)
n : nat
H2 : eq (N.odd a) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
simpl in |- *.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H.
elim (X0 (Ndiv2 a) y H).
intros n H3.
simpl in |- *.

*****
H3 : eq (MapCard A m1) (S n)
n : nat
H2 : eq (N.odd a) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n))
+++++
rewrite H3.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H.
elim (X0 (Ndiv2 a) y H).
intros n H3.
simpl in |- *.
rewrite H3.

*****
H3 : eq (MapCard A m1) (S n)
n : nat
H2 : eq (N.odd a) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n0 : nat => eq (Init.Nat.add (MapCard A m0) (S n)) (S n0))
+++++
split with (MapCard A m0 + n).
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H.
elim (X0 (Ndiv2 a) y H).
intros n H3.
simpl in |- *.
rewrite H3.
split with (MapCard A m0 + n).

*****
H3 : eq (MapCard A m1) (S n)
n : nat
H2 : eq (N.odd a) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (S n)) (S (Init.Nat.add (MapCard A m0) n))
+++++
rewrite <- (plus_Snm_nSm (MapCard A m0) n).
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H.
elim (X0 (Ndiv2 a) y H).
intros n H3.
simpl in |- *.
rewrite H3.
split with (MapCard A m0 + n).
rewrite <- (plus_Snm_nSm (MapCard A m0) n).

*****
H3 : eq (MapCard A m1) (S n)
n : nat
H2 : eq (N.odd a) true
H : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (S (MapCard A m0)) n) (S (Init.Nat.add (MapCard A m0) n))
+++++
reflexivity.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
intro H2.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) false
H : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H.

*****
H2 : eq (N.odd a) false
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
elim (X (Ndiv2 a) y H).
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H.
elim (X (Ndiv2 a) y H).

*****
H2 : eq (N.odd a) false
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
forall (x : nat) (_ : eq (MapCard A m0) (S x)), sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
intros n H3.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H.
elim (X (Ndiv2 a) y H).
intros n H3.

*****
H3 : eq (MapCard A m0) (S n)
n : nat
H2 : eq (N.odd a) false
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (MapCard A (M2 A m0 m1)) (S n))
+++++
simpl in |- *.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H.
elim (X (Ndiv2 a) y H).
intros n H3.
simpl in |- *.

*****
H3 : eq (MapCard A m0) (S n)
n : nat
H2 : eq (N.odd a) false
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n : nat => eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n))
+++++
rewrite H3.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H.
elim (X (Ndiv2 a) y H).
intros n H3.
simpl in |- *.
rewrite H3.

*****
H3 : eq (MapCard A m0) (S n)
n : nat
H2 : eq (N.odd a) false
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
sig (fun n0 : nat => eq (Init.Nat.add (S n) (MapCard A m1)) (S n0))
+++++
split with (n + MapCard A m1).
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H.
elim (X (Ndiv2 a) y H).
intros n H3.
simpl in |- *.
rewrite H3.
split with (n + MapCard A m1).

*****
H3 : eq (MapCard A m0) (S n)
n : nat
H2 : eq (N.odd a) false
H : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
a : ad
X0 : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m1) (S n))
m1 : Map A
X : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\nsig (fun n : nat => eq (MapCard A m0) (S n))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (S n) (MapCard A m1)) (S (Init.Nat.add n (MapCard A m1)))
+++++
reflexivity.
-----
Lemma MapCard_is_not_O : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_is_one :\n   forall m:Map A,\n     MapCard A m = 1 -> {a : ad &  {y : A | MapGet A m a = Some y}}.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.

*****
A,B : Type
*****
forall (m : Map A) (_ : eq (MapCard A m) (S O)), sigT (fun a : ad => sig (fun y : A => eq (MapGet A m a) (Some y)))
+++++
Proof.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (_ : eq (MapCard A m) (S O)), sigT (fun a : ad => sig (fun y : A => eq (MapGet A m a) (Some y)))
+++++
simple induction m.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (M0 A)) (S O), sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M0 A) a) (Some y)))
+++++
intro.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intro.

*****
H : eq (MapCard A (M0 A)) (S O)
m : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M0 A) a) (Some y)))
+++++
discriminate H.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (_ : eq (MapCard A (M1 A a a0)) (S O)), sigT (fun a1 : ad => sig (fun y : A => eq (MapGet A (M1 A a a0) a1) (Some y)))
+++++
intros a y H.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros a y H.

*****
H : eq (MapCard A (M1 A a y)) (S O)
y : A
a : ad
m : Map A
A,B : Type
*****
sigT (fun a0 : ad => sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0)))
+++++
split with a.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros a y H.
split with a.

*****
H : eq (MapCard A (M1 A a y)) (S O)
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a) (Some y0))
+++++
split with y.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros a y H.
split with a.
split with y.

*****
H : eq (MapCard A (M1 A a y)) (S O)
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a y) a) (Some y)
+++++
apply M1_semantics_1.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall _ : eq (MapCard A m) (S O), sigT (fun a : ad => sig (fun y : A => eq (MapGet A m a) (Some y)))) (m0 : Map A) (_ : forall _ : eq (MapCard A m0) (S O), sigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))) (_ : eq (MapCard A (M2 A m m0)) (S O)), sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m m0) a) (Some y)))
+++++
intros.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.

*****
H : eq (MapCard A (M2 A m0 m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
simpl in H.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.

*****
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).

*****
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
forall _ : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O)), sigT (fun a0 : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a0) (Some y)))
+++++
intro H2.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.

*****
H2 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
elim H2.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.

*****
H2 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
forall (_ : eq (MapCard A m0) O) (_ : eq (MapCard A m1) (S O)), sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
intros H3 H4.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.

*****
H4 : eq (MapCard A m1) (S O)
H3 : eq (MapCard A m0) O
H2 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
elim (X0 H4).
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X0 H4).

*****
H4 : eq (MapCard A m1) (S O)
H3 : eq (MapCard A m0) O
H2 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
forall (x : ad) (_ : sig (fun y : A => eq (MapGet A m1 x) (Some y))), sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
intros a H5.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X0 H4).
intros a H5.

*****
H5 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
a : ad
H4 : eq (MapCard A m1) (S O)
H3 : eq (MapCard A m0) O
H2 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
split with (Ndouble_plus_one a).
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X0 H4).
intros a H5.
split with (Ndouble_plus_one a).

*****
H5 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
a : ad
H4 : eq (MapCard A m1) (S O)
H3 : eq (MapCard A m0) O
H2 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) (N.succ_double a)) (Some y))
+++++
rewrite (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m0 m1).
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X0 H4).
intros a H5.
split with (Ndouble_plus_one a).
rewrite (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m0 m1).

*****
H5 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
a : ad
H4 : eq (MapCard A m1) (S O)
H3 : eq (MapCard A m0) O
H2 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m1 (N.div2 (N.succ_double a))) (Some y))
+++++
rewrite Ndouble_plus_one_div2.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X0 H4).
intros a H5.
split with (Ndouble_plus_one a).
rewrite (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m0 m1).
rewrite Ndouble_plus_one_div2.

*****
H5 : sig (fun y : A => eq (MapGet A m1 a) (Some y))
a : ad
H4 : eq (MapCard A m1) (S O)
H3 : eq (MapCard A m0) O
H2 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m1 a) (Some y))
+++++
exact H5.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).

*****
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
forall _ : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O), sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
intro H2.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.

*****
H2 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
elim H2.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.

*****
H2 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
forall (_ : eq (MapCard A m0) (S O)) (_ : eq (MapCard A m1) O), sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
intros H3 H4.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.

*****
H4 : eq (MapCard A m1) O
H3 : eq (MapCard A m0) (S O)
H2 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
elim (X H3).
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X H3).

*****
H4 : eq (MapCard A m1) O
H3 : eq (MapCard A m0) (S O)
H2 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
forall (x : ad) (_ : sig (fun y : A => eq (MapGet A m0 x) (Some y))), sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
intros a H5.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X H3).
intros a H5.

*****
H5 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
a : ad
H4 : eq (MapCard A m1) O
H3 : eq (MapCard A m0) (S O)
H2 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sigT (fun a : ad => sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)))
+++++
split with (Ndouble a).
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X H3).
intros a H5.
split with (Ndouble a).

*****
H5 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
a : ad
H4 : eq (MapCard A m1) O
H3 : eq (MapCard A m0) (S O)
H2 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) (N.double a)) (Some y))
+++++
rewrite (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m0 m1).
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X H3).
intros a H5.
split with (Ndouble a).
rewrite (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m0 m1).

*****
H5 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
a : ad
H4 : eq (MapCard A m1) O
H3 : eq (MapCard A m0) (S O)
H2 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m0 (N.div2 (N.double a))) (Some y))
+++++
rewrite Ndouble_div2.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.
intros.
simpl in H.
elim (plus_is_one (MapCard A m0) (MapCard A m1) H).
intro H2.
elim H2.
intros H3 H4.
elim (X H3).
intros a H5.
split with (Ndouble a).
rewrite (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m0 m1).
rewrite Ndouble_div2.

*****
H5 : sig (fun y : A => eq (MapGet A m0 a) (Some y))
a : ad
H4 : eq (MapCard A m1) O
H3 : eq (MapCard A m0) (S O)
H2 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
X0 : forall _ : eq (MapCard A m1) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m1 a) (Some y)))
m1 : Map A
X : forall _ : eq (MapCard A m0) (S O),\nsigT (fun a : ad => sig (fun y : A => eq (MapGet A m0 a) (Some y)))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m0 a) (Some y))
+++++
exact H5.
-----
Lemma MapCard_is_one : forall m:Map A, MapCard A m = 1 -> {a : ad & {y : A | MapGet A m a = Some y}}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_is_one_unique :\n   forall m:Map A,\n     MapCard A m = 1 ->\n     forall (a a':ad) (y y':A),\n       MapGet A m a = Some y ->\n       MapGet A m a' = Some y' -> a = a' /\ y = y'.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.

*****
A,B : Type
*****
forall (m : Map A) (_ : eq (MapCard A m) (S O)) (a a' : ad) (y y' : A) (_ : eq (MapGet A m a) (Some y)) (_ : eq (MapGet A m a') (Some y')), and (eq a a') (eq y y')
+++++
Proof.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (_ : eq (MapCard A m) (S O)) (a a' : ad) (y y' : A) (_ : eq (MapGet A m a) (Some y)) (_ : eq (MapGet A m a') (Some y')), and (eq a a') (eq y y')
+++++
simple induction m.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (_ : eq (MapCard A (M0 A)) (S O)) (a a' : ad) (y y' : A) (_ : eq (MapGet A (M0 A) a) (Some y)) (_ : eq (MapGet A (M0 A) a') (Some y')), and (eq a a') (eq y y')
+++++
intro.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intro.

*****
H : eq (MapCard A (M0 A)) (S O)
m : Map A
A,B : Type
*****
forall (a a' : ad) (y y' : A) (_ : eq (MapGet A (M0 A) a) (Some y)) (_ : eq (MapGet A (M0 A) a') (Some y')), and (eq a a') (eq y y')
+++++
discriminate H.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (_ : eq (MapCard A (M1 A a a0)) (S O)) (a1 a' : ad) (y y' : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)) (_ : eq (MapGet A (M1 A a a0) a') (Some y')), and (eq a1 a') (eq y y')
+++++
intros.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.

*****
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (MapGet A (M1 A a a0) a1) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (MapGet A (M1 A a a0) a1) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) true, and (eq a1 a') (eq y y')
+++++
intro H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.

*****
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (MapGet A (M1 A a a0) a1) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
rewrite (Neqb_complete _ _ H2) in H0.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.

*****
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (MapGet A (M1 A a1 a0) a1) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
rewrite (M1_semantics_1 A a1 a0) in H0.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.

*****
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
inversion H0.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.

*****
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
elim (sumbool_of_bool (Neqb a a')).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).

*****
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a') true, and (eq a1 a') (eq y y')
+++++
intro H5.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.

*****
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
rewrite (Neqb_complete _ _ H5) in H1.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.

*****
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a' a0) a') (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
rewrite (M1_semantics_1 A a' a0) in H1.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.
rewrite (M1_semantics_1 A a' a0) in H1.

*****
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (Some a0) (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
inversion H1.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.
rewrite (M1_semantics_1 A a' a0) in H1.
inversion H1.

*****
H6 : eq a0 y'
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (Some a0) (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
rewrite <- (Neqb_complete _ _ H2).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.
rewrite (M1_semantics_1 A a' a0) in H1.
inversion H1.
rewrite <- (Neqb_complete _ _ H2).

*****
H6 : eq a0 y'
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (Some a0) (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite <- (Neqb_complete _ _ H5).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.
rewrite (M1_semantics_1 A a' a0) in H1.
inversion H1.
rewrite <- (Neqb_complete _ _ H2).
rewrite <- (Neqb_complete _ _ H5).

*****
H6 : eq a0 y'
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (Some a0) (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a a) (eq y y')
+++++
rewrite <- H4.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.
rewrite (M1_semantics_1 A a' a0) in H1.
inversion H1.
rewrite <- (Neqb_complete _ _ H2).
rewrite <- (Neqb_complete _ _ H5).
rewrite <- H4.

*****
H6 : eq a0 y'
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (Some a0) (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a a) (eq a0 y')
+++++
rewrite <- H6.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.
rewrite (M1_semantics_1 A a' a0) in H1.
inversion H1.
rewrite <- (Neqb_complete _ _ H2).
rewrite <- (Neqb_complete _ _ H5).
rewrite <- H4.
rewrite <- H6.

*****
H6 : eq a0 y'
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (Some a0) (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a a) (eq a0 a0)
+++++
split.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.
rewrite (M1_semantics_1 A a' a0) in H1.
inversion H1.
rewrite <- (Neqb_complete _ _ H2).
rewrite <- (Neqb_complete _ _ H5).
rewrite <- H4.
rewrite <- H6.
split.

*****
H6 : eq a0 y'
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (Some a0) (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq a a
+++++
reflexivity.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (Neqb_complete _ _ H5) in H1.
rewrite (M1_semantics_1 A a' a0) in H1.
inversion H1.
rewrite <- (Neqb_complete _ _ H2).
rewrite <- (Neqb_complete _ _ H5).
rewrite <- H4.
rewrite <- H6.
split.

*****
H6 : eq a0 y'
H5 : eq (N.eqb a a') true
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (Some a0) (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq a0 a0
+++++
reflexivity.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).

*****
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a') false, and (eq a1 a') (eq y y')
+++++
intro H5.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.

*****
H5 : eq (N.eqb a a') false
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
rewrite (M1_semantics_2 A a a' a0 H5) in H1.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (M1_semantics_1 A a1 a0) in H0.
inversion H0.
elim (sumbool_of_bool (Neqb a a')).
intro H5.
rewrite (M1_semantics_2 A a a' a0 H5) in H1.

*****
H5 : eq (N.eqb a a') false
H4 : eq a0 y
H2 : eq (N.eqb a a1) true
H1 : eq None (Some y')
H0 : eq (Some a0) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
discriminate H1.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (MapGet A (M1 A a a0) a1) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) false, and (eq a1 a') (eq y y')
+++++
intro H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.

*****
H2 : eq (N.eqb a a1) false
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq (MapGet A (M1 A a a0) a1) (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
rewrite (M1_semantics_2 A a a1 a0 H2) in H0.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (M1_semantics_2 A a a1 a0 H2) in H0.

*****
H2 : eq (N.eqb a a1) false
H1 : eq (MapGet A (M1 A a a0) a') (Some y')
H0 : eq None (Some y)
y,y' : A
a1,a' : ad
H : eq (MapCard A (M1 A a a0)) (S O)
a0 : A
a : ad
m : Map A
A,B : Type
*****
and (eq a1 a') (eq y y')
+++++
discriminate H0.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (_ : eq (MapCard A m) (S O)) (a a' : ad) (y y' : A) (_ : eq (MapGet A m a) (Some y)) (_ : eq (MapGet A m a') (Some y')), and (eq a a') (eq y y')) (m0 : Map A) (_ : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A) (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')), and (eq a a') (eq y y')) (_ : eq (MapCard A (M2 A m m0)) (S O)) (a a' : ad) (y y' : A) (_ : eq (MapGet A (M2 A m m0) a) (Some y)) (_ : eq (MapGet A (M2 A m m0) a') (Some y')), and (eq a a') (eq y y')
+++++
intros.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.

*****
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (MapCard A (M2 A m0 m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
simpl in H1.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.

*****
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim (plus_is_one _ _ H1).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).

*****
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O)), and (eq a a') (eq y y')
+++++
intro H4.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.

*****
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim H4.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.

*****
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall (_ : eq (MapCard A m0) O) (_ : eq (MapCard A m1) (S O)), and (eq a a') (eq y y')
+++++
intros.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.

*****
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.

*****
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).

*****
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, and (eq a a') (eq y y')
+++++
intro H7.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.

*****
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite H7 in H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.

*****
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.

*****
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim (sumbool_of_bool (Nbit0 a')).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).

*****
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a') true, and (eq a a') (eq y y')
+++++
intro H8.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.

*****
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite H8 in H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.

*****
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim (H0 H6 _ _ _ _ H2 H3).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H0 H6 _ _ _ _ H2 H3).

*****
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall (_ : eq (N.div2 a) (N.div2 a')) (_ : eq y y'), and (eq a a') (eq y y')
+++++
intros.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H0 H6 _ _ _ _ H2 H3).
intros.

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
split.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H0 H6 _ _ _ _ H2 H3).
intros.
split.

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq a a'
+++++
rewrite <- (Ndiv2_double_plus_one a H7).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H0 H6 _ _ _ _ H2 H3).
intros.
split.
rewrite <- (Ndiv2_double_plus_one a H7).

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq (N.succ_double (N.div2 a)) a'
+++++
rewrite <- (Ndiv2_double_plus_one a' H8).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H0 H6 _ _ _ _ H2 H3).
intros.
split.
rewrite <- (Ndiv2_double_plus_one a H7).
rewrite <- (Ndiv2_double_plus_one a' H8).

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq (N.succ_double (N.div2 a)) (N.succ_double (N.div2 a'))
+++++
rewrite H9.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H0 H6 _ _ _ _ H2 H3).
intros.
split.
rewrite <- (Ndiv2_double_plus_one a H7).
rewrite <- (Ndiv2_double_plus_one a' H8).
rewrite H9.

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq (N.succ_double (N.div2 a')) (N.succ_double (N.div2 a'))
+++++
reflexivity.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H0 H6 _ _ _ _ H2 H3).
intros.
split.

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') true
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq y y'
+++++
assumption.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).

*****
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a') false, and (eq a a') (eq y y')
+++++
intro H8.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.

*****
H8 : eq (N.odd a') false
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite H8 in H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.

*****
H8 : eq (N.odd a') false
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite (MapCard_is_O m0 H5 (Ndiv2 a')) in H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
rewrite (MapCard_is_O m0 H5 (Ndiv2 a')) in H3.

*****
H8 : eq (N.odd a') false
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq None (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
discriminate H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).

*****
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, and (eq a a') (eq y y')
+++++
intro H7.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.

*****
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite H7 in H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.

*****
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite (MapCard_is_O m0 H5 (Ndiv2 a)) in H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapCard_is_O m0 H5 (Ndiv2 a)) in H2.

*****
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) (S O)
H5 : eq (MapCard A m0) O
H4 : and (eq (MapCard A m0) O) (eq (MapCard A m1) (S O))
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq None (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
discriminate H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).

*****
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O), and (eq a a') (eq y y')
+++++
intro H4.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.

*****
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim H4.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.

*****
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall (_ : eq (MapCard A m0) (S O)) (_ : eq (MapCard A m1) O), and (eq a a') (eq y y')
+++++
intros.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.

*****
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.

*****
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).

*****
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, and (eq a a') (eq y y')
+++++
intro H7.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.

*****
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite H7 in H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.

*****
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A m1 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite (MapCard_is_O m1 H6 (Ndiv2 a)) in H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapCard_is_O m1 H6 (Ndiv2 a)) in H2.

*****
H7 : eq (N.odd a) true
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq None (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
discriminate H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).

*****
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, and (eq a a') (eq y y')
+++++
intro H7.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.

*****
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (if N.odd a then MapGet A m1 (N.div2 a) else MapGet A m0 (N.div2 a))\n (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite H7 in H2.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.

*****
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A (M2 A m0 m1) a') (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.

*****
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim (sumbool_of_bool (Nbit0 a')).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).

*****
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a') true, and (eq a a') (eq y y')
+++++
intro H8.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.

*****
H8 : eq (N.odd a') true
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite H8 in H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.

*****
H8 : eq (N.odd a') true
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m1 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite (MapCard_is_O m1 H6 (Ndiv2 a')) in H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
rewrite (MapCard_is_O m1 H6 (Ndiv2 a')) in H3.

*****
H8 : eq (N.odd a') true
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq None (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
discriminate H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).

*****
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a') false, and (eq a a') (eq y y')
+++++
intro H8.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.

*****
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq\n (if N.odd a'\n then MapGet A m1 (N.div2 a')\n else MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
rewrite H8 in H3.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.

*****
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
elim (H H5 _ _ _ _ H2 H3).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H H5 _ _ _ _ H2 H3).

*****
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
forall (_ : eq (N.div2 a) (N.div2 a')) (_ : eq y y'), and (eq a a') (eq y y')
+++++
intros.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H H5 _ _ _ _ H2 H3).
intros.

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
and (eq a a') (eq y y')
+++++
split.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H H5 _ _ _ _ H2 H3).
intros.
split.

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq a a'
+++++
rewrite <- (Ndiv2_double a H7).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H H5 _ _ _ _ H2 H3).
intros.
split.
rewrite <- (Ndiv2_double a H7).

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq (N.double (N.div2 a)) a'
+++++
rewrite <- (Ndiv2_double a' H8).
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H H5 _ _ _ _ H2 H3).
intros.
split.
rewrite <- (Ndiv2_double a H7).
rewrite <- (Ndiv2_double a' H8).

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq (N.double (N.div2 a)) (N.double (N.div2 a'))
+++++
rewrite H9.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H H5 _ _ _ _ H2 H3).
intros.
split.
rewrite <- (Ndiv2_double a H7).
rewrite <- (Ndiv2_double a' H8).
rewrite H9.

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq (N.double (N.div2 a')) (N.double (N.div2 a'))
+++++
reflexivity.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.
intros.
simpl in H1.
elim (plus_is_one _ _ H1).
intro H4.
elim H4.
intros.
rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.
elim (sumbool_of_bool (Nbit0 a)).
intro H7.
rewrite H7 in H2.
rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.
elim (sumbool_of_bool (Nbit0 a')).
intro H8.
rewrite H8 in H3.
elim (H H5 _ _ _ _ H2 H3).
intros.
split.

*****
H10 : eq y y'
H9 : eq (N.div2 a) (N.div2 a')
H8 : eq (N.odd a') false
H7 : eq (N.odd a) false
H6 : eq (MapCard A m1) O
H5 : eq (MapCard A m0) (S O)
H4 : and (eq (MapCard A m0) (S O)) (eq (MapCard A m1) O)
H3 : eq (MapGet A m0 (N.div2 a')) (Some y')
H2 : eq (MapGet A m0 (N.div2 a)) (Some y)
y,y' : A
a,a' : ad
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)
H0 : forall (_ : eq (MapCard A m1) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m1 a) (Some y)) (_ : eq (MapGet A m1 a') (Some y')),\nand (eq a a') (eq y y')
m1 : Map A
H : forall (_ : eq (MapCard A m0) (S O)) (a a' : ad) (y y' : A)\n (_ : eq (MapGet A m0 a) (Some y)) (_ : eq (MapGet A m0 a') (Some y')),\nand (eq a a') (eq y y')
m,m0 : Map A
A,B : Type
*****
eq y y'
+++++
assumption.
-----
Lemma MapCard_is_one_unique : forall m:Map A, MapCard A m = 1 -> forall (a a':ad) (y y':A), MapGet A m a = Some y -> MapGet A m a' = Some y' -> a = a' /\\ y = y'.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma length_as_fold :\n   forall (C:Type) (l:list C),\n     length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.
-----
Lemma length_as_fold : forall (C:Type) (l:list C), length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.

*****
A,B : Type
*****
forall (C : Type) (l : list C), eq (length l) (fold_right (fun (_ : C) (n : nat) => S n) O l)
+++++
Proof.
-----
Lemma length_as_fold : forall (C:Type) (l:list C), length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.
Proof.

*****
A,B : Type
*****
forall (C : Type) (l : list C), eq (length l) (fold_right (fun (_ : C) (n : nat) => S n) O l)
+++++
simple induction l.
-----
Lemma length_as_fold : forall (C:Type) (l:list C), length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.
Proof.
simple induction l.

*****
l : list C
C : Type
A,B : Type
*****
eq (length nil) (fold_right (fun (_ : C) (n : nat) => S n) O nil)
+++++
reflexivity.
-----
Lemma length_as_fold : forall (C:Type) (l:list C), length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.
Proof.
simple induction l.

*****
l : list C
C : Type
A,B : Type
*****
forall (a : C) (l : list C) (_ : eq (length l) (fold_right (fun (_ : C) (n : nat) => S n) O l)), eq (length (cons a l)) (fold_right (fun (_ : C) (n : nat) => S n) O (cons a l))
+++++
intros.
-----
Lemma length_as_fold : forall (C:Type) (l:list C), length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.
Proof.
simple induction l.
intros.

*****
H : eq (length l0) (fold_right (fun (_ : C) (n : nat) => S n) O l0)
l0 : list C
a : C
l : list C
C : Type
A,B : Type
*****
eq (length (cons a l0)) (fold_right (fun (_ : C) (n : nat) => S n) O (cons a l0))
+++++
simpl in |- *.
-----
Lemma length_as_fold : forall (C:Type) (l:list C), length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H : eq (length l0) (fold_right (fun (_ : C) (n : nat) => S n) O l0)
l0 : list C
a : C
l : list C
C : Type
A,B : Type
*****
eq (S (length l0)) (S (fold_right (fun (_ : C) (n : nat) => S n) O l0))
+++++
rewrite H.
-----
Lemma length_as_fold : forall (C:Type) (l:list C), length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite H.

*****
H : eq (length l0) (fold_right (fun (_ : C) (n : nat) => S n) O l0)
l0 : list C
a : C
l : list C
C : Type
A,B : Type
*****
eq (S (fold_right (fun (_ : C) (n : nat) => S n) O l0)) (S (fold_right (fun (_ : C) (n : nat) => S n) O l0))
+++++
reflexivity.
-----
Lemma length_as_fold : forall (C:Type) (l:list C), length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma length_as_fold_2 :\n   forall l:alist A,\n     length l =\n     fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.

*****
A,B : Type
*****
forall l : alist A, eq (length l) (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O l)
+++++
Proof.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
Proof.

*****
A,B : Type
*****
forall l : alist A, eq (length l) (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O l)
+++++
simple induction l.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
Proof.
simple induction l.

*****
l : alist A
A,B : Type
*****
eq (length nil) (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O nil)
+++++
reflexivity.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
Proof.
simple induction l.

*****
l : alist A
A,B : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : eq (length l) (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O l)), eq (length (cons a l)) (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O (cons a l))
+++++
intros.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
Proof.
simple induction l.
intros.

*****
H : eq (length l0)\n (fold_right\n (fun (r : prod ad A) (n : nat) =>\n let (_, _) := r in Init.Nat.add (S O) n) O l0)
l0 : list (prod ad A)
a : prod ad A
l : alist A
A,B : Type
*****
eq (length (cons a l0)) (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O (cons a l0))
+++++
simpl in |- *.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H : eq (length l0)\n (fold_right\n (fun (r : prod ad A) (n : nat) =>\n let (_, _) := r in Init.Nat.add (S O) n) O l0)
l0 : list (prod ad A)
a : prod ad A
l : alist A
A,B : Type
*****
eq (S (length l0)) (let (_, _) := a in S (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in S n) O l0))
+++++
rewrite H.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite H.

*****
H : eq (length l0)\n (fold_right\n (fun (r : prod ad A) (n : nat) =>\n let (_, _) := r in Init.Nat.add (S O) n) O l0)
l0 : list (prod ad A)
a : prod ad A
l : alist A
A,B : Type
*****
eq (S (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O l0)) (let (_, _) := a in S (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in S n) O l0))
+++++
elim a.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite H.
elim a.

*****
H : eq (length l0)\n (fold_right\n (fun (r : prod ad A) (n : nat) =>\n let (_, _) := r in Init.Nat.add (S O) n) O l0)
l0 : list (prod ad A)
a : prod ad A
l : alist A
A,B : Type
*****
forall (_ : ad) (_ : A), eq (S (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O l0)) (S (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in S n) O l0))
+++++
reflexivity.
-----
Lemma length_as_fold_2 : forall l:alist A, length l = fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma MapCard_as_Fold_1 :\n   forall (m:Map A) (pf:ad -> ad),\n     MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.

*****
A,B : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad), eq (MapCard A m) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m)
+++++
Proof.
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad), eq (MapCard A m) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m)
+++++
simple induction m.
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall pf : forall _ : ad, ad, eq (MapCard A (M0 A)) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf (M0 A))
+++++
trivial.
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad), eq (MapCard A (M1 A a a0)) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf (M1 A a a0))
+++++
trivial.
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapCard A m) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m)) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapCard A m0) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m0)) (pf : forall _ : ad, ad), eq (MapCard A (M2 A m m0)) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf (M2 A m m0))
+++++
intros.
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.
simple induction m.
intros.

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapCard A m1)\n (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m1)
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapCard A m0)\n (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m0)
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (M2 A m0 m1)) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.
simple induction m.
intros.
simpl in |- *.

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapCard A m1)\n (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m1)
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapCard A m0)\n (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m0)
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite <- (H (fun a0:ad => pf (Ndouble a0))).
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite <- (H (fun a0:ad => pf (Ndouble a0))).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapCard A m1)\n (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m1)
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapCard A m0)\n (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m0)
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A m0) (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite <- (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite <- (H (fun a0:ad => pf (Ndouble a0))).
rewrite <- (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapCard A m1)\n (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m1)
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapCard A m0)\n (MapFold1 A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) pf m0)
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
reflexivity.
-----
Lemma MapCard_as_Fold_1 : forall (m:Map A) (pf:ad -> ad), MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_as_Fold :\n   forall m:Map A,\n     MapCard A m = MapFold A nat 0 plus (fun (_:ad) (_:A) => 1) m.
-----
Lemma MapCard_as_Fold : forall m:Map A, MapCard A m = MapFold A nat 0 plus (fun (_:ad) (_:A) => 1) m.

*****
A,B : Type
*****
forall m : Map A, eq (MapCard A m) (MapFold A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) m)
+++++
Proof.
-----
Lemma MapCard_as_Fold : forall m:Map A, MapCard A m = MapFold A nat 0 plus (fun (_:ad) (_:A) => 1) m.
Proof.

*****
A,B : Type
*****
forall m : Map A, eq (MapCard A m) (MapFold A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) m)
+++++
intro.
-----
Lemma MapCard_as_Fold : forall m:Map A, MapCard A m = MapFold A nat 0 plus (fun (_:ad) (_:A) => 1) m.
Proof.
intro.

*****
m : Map A
A,B : Type
*****
eq (MapCard A m) (MapFold A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) m)
+++++
exact (MapCard_as_Fold_1 m (fun a0:ad => a0)).
-----
Lemma MapCard_as_Fold : forall m:Map A, MapCard A m = MapFold A nat 0 plus (fun (_:ad) (_:A) => 1) m.
Proof.
intro.
exact (MapCard_as_Fold_1 m (fun a0:ad => a0)).

*****

*****

+++++
Qed.
-----
Lemma MapCard_as_length :\n   forall m:Map A, MapCard A m = length (alist_of_Map A m).
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).

*****
A,B : Type
*****
forall m : Map A, eq (MapCard A m) (length (alist_of_Map A m))
+++++
Proof.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.

*****
A,B : Type
*****
forall m : Map A, eq (MapCard A m) (length (alist_of_Map A m))
+++++
intro.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.

*****
m : Map A
A,B : Type
*****
eq (MapCard A m) (length (alist_of_Map A m))
+++++
rewrite MapCard_as_Fold.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.
rewrite MapCard_as_Fold.

*****
m : Map A
A,B : Type
*****
eq (MapFold A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) m) (length (alist_of_Map A m))
+++++
rewrite length_as_fold_2.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.
rewrite MapCard_as_Fold.
rewrite length_as_fold_2.

*****
m : Map A
A,B : Type
*****
eq (MapFold A nat O Init.Nat.add (fun (_ : ad) (_ : A) => S O) m) (fold_right (fun (r : prod ad A) (n : nat) => let (_, _) := r in Init.Nat.add (S O) n) O (alist_of_Map A m))
+++++
apply MapFold_as_fold with (op := plus) (neutral := 0) (f := fun (_:ad) (_:A) => 1).
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.
rewrite MapCard_as_Fold.
rewrite length_as_fold_2.
apply MapFold_as_fold with (op := plus) (neutral := 0) (f := fun (_:ad) (_:A) => 1).

*****
m : Map A
A,B : Type
*****
forall a b c : nat, eq (Init.Nat.add (Init.Nat.add a b) c) (Init.Nat.add a (Init.Nat.add b c))
+++++
exact plus_assoc_reverse.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.
rewrite MapCard_as_Fold.
rewrite length_as_fold_2.
apply MapFold_as_fold with (op := plus) (neutral := 0) (f := fun (_:ad) (_:A) => 1).

*****
m : Map A
A,B : Type
*****
forall a : nat, eq (Init.Nat.add O a) a
+++++
trivial.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.
rewrite MapCard_as_Fold.
rewrite length_as_fold_2.
apply MapFold_as_fold with (op := plus) (neutral := 0) (f := fun (_:ad) (_:A) => 1).

*****
m : Map A
A,B : Type
*****
forall a : nat, eq (Init.Nat.add a O) a
+++++
intro.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.
rewrite MapCard_as_Fold.
rewrite length_as_fold_2.
apply MapFold_as_fold with (op := plus) (neutral := 0) (f := fun (_:ad) (_:A) => 1).
intro.

*****
a : nat
m : Map A
A,B : Type
*****
eq (Init.Nat.add a O) a
+++++
rewrite <- plus_n_O.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.
rewrite MapCard_as_Fold.
rewrite length_as_fold_2.
apply MapFold_as_fold with (op := plus) (neutral := 0) (f := fun (_:ad) (_:A) => 1).
intro.
rewrite <- plus_n_O.

*****
a : nat
m : Map A
A,B : Type
*****
eq a a
+++++
reflexivity.
-----
Lemma MapCard_as_length : forall m:Map A, MapCard A m = length (alist_of_Map A m).
Proof.
intro.
rewrite MapCard_as_Fold.
rewrite length_as_fold_2.
apply MapFold_as_fold with (op := plus) (neutral := 0) (f := fun (_:ad) (_:A) => 1).

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put1_equals_2 :\n   forall (p:positive) (a a':ad) (y y':A),\n     MapCard A (MapPut1 A a y a' y' p) = 2.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.

*****
A,B : Type
*****
forall (p : positive) (a a' : ad) (y y' : A), eq (MapCard A (MapPut1 A a y a' y' p)) (S (S O))
+++++
Proof.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.

*****
A,B : Type
*****
forall (p : positive) (a a' : ad) (y y' : A), eq (MapCard A (MapPut1 A a y a' y' p)) (S (S O))
+++++
simple induction p.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.

*****
p : positive
A,B : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A), eq (MapCard A (MapPut1 A a y a' y' p)) (S (S O))) (a a' : ad) (y y' : A), eq (MapCard A (MapPut1 A a y a' y' (xI p))) (S (S O))
+++++
intros.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (MapPut1 A a y a' y' (xI p0))) (S (S O))
+++++
simpl in |- *.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (if N.odd a then M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y) else M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))) (S (S O))
+++++
case (Nbit0 a).
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y))) (S (S O))
+++++
reflexivity.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))) (S (S O))
+++++
reflexivity.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.

*****
p : positive
A,B : Type
*****
forall (p : positive) (_ : forall (a a' : ad) (y y' : A), eq (MapCard A (MapPut1 A a y a' y' p)) (S (S O))) (a a' : ad) (y y' : A), eq (MapCard A (MapPut1 A a y a' y' (xO p))) (S (S O))
+++++
intros.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (MapPut1 A a y a' y' (xO p0))) (S (S O))
+++++
simpl in |- *.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (if N.odd a then M2 A (M0 A) (MapPut1 A (N.div2 a) y (N.div2 a') y' p0) else M2 A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0) (M0 A))) (S (S O))
+++++
case (Nbit0 a).
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (M2 A (M0 A) (MapPut1 A (N.div2 a) y (N.div2 a') y' p0))) (S (S O))
+++++
exact (H (Ndiv2 a) (Ndiv2 a') y y').
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (M2 A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0) (M0 A))) (S (S O))
+++++
simpl in |- *.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.
case (Nbit0 a).
simpl in |- *.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0)) O) (S (S O))
+++++
rewrite <- plus_n_O.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.
case (Nbit0 a).
simpl in |- *.
rewrite <- plus_n_O.

*****
y,y' : A
a,a' : ad
H : forall (a a' : ad) (y y' : A),\neq (MapCard A (MapPut1 A a y a' y' p0)) (S (S O))
p,p0 : positive
A,B : Type
*****
eq (MapCard A (MapPut1 A (N.div2 a) y (N.div2 a') y' p0)) (S (S O))
+++++
exact (H (Ndiv2 a) (Ndiv2 a') y y').
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.

*****
p : positive
A,B : Type
*****
forall (a a' : ad) (y y' : A), eq (MapCard A (MapPut1 A a y a' y' xH)) (S (S O))
+++++
intros.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.

*****
y,y' : A
a,a' : ad
p : positive
A,B : Type
*****
eq (MapCard A (MapPut1 A a y a' y' xH)) (S (S O))
+++++
simpl in |- *.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.

*****
y,y' : A
a,a' : ad
p : positive
A,B : Type
*****
eq (MapCard A (if N.odd a then M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y) else M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))) (S (S O))
+++++
case (Nbit0 a).
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
p : positive
A,B : Type
*****
eq (MapCard A (M2 A (M1 A (N.div2 a') y') (M1 A (N.div2 a) y))) (S (S O))
+++++
reflexivity.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.
intros.
simpl in |- *.
case (Nbit0 a).

*****
y,y' : A
a,a' : ad
p : positive
A,B : Type
*****
eq (MapCard A (M2 A (M1 A (N.div2 a) y) (M1 A (N.div2 a') y'))) (S (S O))
+++++
reflexivity.
-----
Lemma MapCard_Put1_equals_2 : forall (p:positive) (a a':ad) (y y':A), MapCard A (MapPut1 A a y a' y' p) = 2.
Proof.
simple induction p.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_sum :\n   forall (m m':Map A) (a:ad) (y:A) (n n':nat),\n     m' = MapPut A m a y ->\n     n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut A m a y)) (_ : eq n (MapCard A m)) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
+++++
Proof.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut A m a y)) (_ : eq n (MapCard A m)) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
+++++
simple induction m.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut A (M0 A) a y)) (_ : eq n (MapCard A (M0 A))) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
+++++
simpl in |- *.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall (m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (M1 A a y)) (_ : eq n O) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
+++++
intros.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
simpl in |- *.
intros.

*****
H1 : eq n' (MapCard A m')
H0 : eq n O
H : eq m' (M1 A a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.

*****
H1 : eq n' (MapCard A (M1 A a y))
H0 : eq n O
H : eq m' (M1 A a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.
simpl in H1.

*****
H1 : eq n' (S O)
H0 : eq n O
H : eq m' (M1 A a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
right.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.
simpl in H1.
right.

*****
H1 : eq n' (S O)
H0 : eq n O
H : eq m' (M1 A a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq n' (S n)
+++++
rewrite H0.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.
simpl in H1.
right.
rewrite H0.

*****
H1 : eq n' (S O)
H0 : eq n O
H : eq m' (M1 A a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq n' (S O)
+++++
rewrite H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.
simpl in H1.
right.
rewrite H0.
rewrite H1.

*****
H1 : eq n' (S O)
H0 : eq n O
H : eq m' (M1 A a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq (S O) (S O)
+++++
reflexivity.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (a1 : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut A (M1 A a a0) a1 y)) (_ : eq n (MapCard A (M1 A a a0))) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
+++++
intros a y m' a0 y0 n n' H H0 H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m' (MapPut A (M1 A a y) a0 y0)
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m'\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
elim (Ndiscr (Nxor a a0)).
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m'\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : sig (fun p : positive => eq (N.lxor a a0) (Npos p)), sumbool (eq n' n) (eq n' (S n))
+++++
intro H2.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.

*****
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m'\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
elim H2.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.

*****
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m'\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
forall (x : positive) (_ : eq (N.lxor a a0) (Npos x)), sumbool (eq n' n) (eq n' (S n))
+++++
intros p H3.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.
intros p H3.

*****
H3 : eq (N.lxor a a0) (Npos p)
p : positive
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m'\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H3 in H.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.
intros p H3.
rewrite H3 in H.

*****
H3 : eq (N.lxor a a0) (Npos p)
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m' (MapPut1 A a y a0 y0 p)
p : positive
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.
intros p H3.
rewrite H3 in H.
rewrite H in H1.

*****
H3 : eq (N.lxor a a0) (Npos p)
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (MapCard A (MapPut1 A a y a0 y0 p))
H0 : eq n (MapCard A (M1 A a y))
H : eq m' (MapPut1 A a y a0 y0 p)
p : positive
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.
intros p H3.
rewrite H3 in H.
rewrite H in H1.
rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H1.

*****
H3 : eq (N.lxor a a0) (Npos p)
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (S (S O))
H0 : eq n (MapCard A (M1 A a y))
H : eq m' (MapPut1 A a y a0 y0 p)
p : positive
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H0.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.
intros p H3.
rewrite H3 in H.
rewrite H in H1.
rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H1.
simpl in H0.

*****
H3 : eq (N.lxor a a0) (Npos p)
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (S (S O))
H0 : eq n (S O)
H : eq m' (MapPut1 A a y a0 y0 p)
p : positive
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
right.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.
intros p H3.
rewrite H3 in H.
rewrite H in H1.
rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H1.
simpl in H0.
right.

*****
H3 : eq (N.lxor a a0) (Npos p)
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (S (S O))
H0 : eq n (S O)
H : eq m' (MapPut1 A a y a0 y0 p)
p : positive
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq n' (S n)
+++++
rewrite H0.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.
intros p H3.
rewrite H3 in H.
rewrite H in H1.
rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H1.
simpl in H0.
right.
rewrite H0.

*****
H3 : eq (N.lxor a a0) (Npos p)
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (S (S O))
H0 : eq n (S O)
H : eq m' (MapPut1 A a y a0 y0 p)
p : positive
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq n' (S (S O))
+++++
rewrite H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
elim H2.
intros p H3.
rewrite H3 in H.
rewrite H in H1.
rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H1.
simpl in H0.
right.
rewrite H0.
rewrite H1.

*****
H3 : eq (N.lxor a a0) (Npos p)
H2 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H1 : eq n' (S (S O))
H0 : eq n (S O)
H : eq m' (MapPut1 A a y a0 y0 p)
p : positive
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (S O)) (S (S O))
+++++
reflexivity.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m'\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.lxor a a0) N0, sumbool (eq n' n) (eq n' (S n))
+++++
intro H2.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.

*****
H2 : eq (N.lxor a a0) N0
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m'\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H2 in H.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
rewrite H2 in H.

*****
H2 : eq (N.lxor a a0) N0
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M1 A a y))
H : eq m' (M1 A a0 y0)
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
rewrite H2 in H.
rewrite H in H1.

*****
H2 : eq (N.lxor a a0) N0
H1 : eq n' (MapCard A (M1 A a0 y0))
H0 : eq n (MapCard A (M1 A a y))
H : eq m' (M1 A a0 y0)
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.

*****
H2 : eq (N.lxor a a0) N0
H1 : eq n' (S O)
H0 : eq n (MapCard A (M1 A a y))
H : eq m' (M1 A a0 y0)
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H0.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.
simpl in H0.

*****
H2 : eq (N.lxor a a0) N0
H1 : eq n' (S O)
H0 : eq n (S O)
H : eq m' (M1 A a0 y0)
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
left.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.
simpl in H0.
left.

*****
H2 : eq (N.lxor a a0) N0
H1 : eq n' (S O)
H0 : eq n (S O)
H : eq m' (M1 A a0 y0)
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq n' n
+++++
rewrite H0.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.
simpl in H0.
left.
rewrite H0.

*****
H2 : eq (N.lxor a a0) N0
H1 : eq n' (S O)
H0 : eq n (S O)
H : eq m' (M1 A a0 y0)
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq n' (S O)
+++++
rewrite H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros a y m' a0 y0 n n' H H0 H1.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.
simpl in H0.
left.
rewrite H0.
rewrite H1.

*****
H2 : eq (N.lxor a a0) N0
H1 : eq n' (S O)
H0 : eq n (S O)
H : eq m' (M1 A a0 y0)
n,n' : nat
y0 : A
a0 : ad
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S O) (S O)
+++++
reflexivity.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut A m a y)) (_ : eq n (MapCard A m)) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))) (m0 : Map A) (_ : forall (m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0)) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))) (m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut A (M2 A m m0) a y)) (_ : eq n (MapCard A (M2 A m m0))) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
+++++
intros.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (MapPut A (M2 A m0 m1) a y)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H0.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (MapPut A (M2 A m0 m1) a y)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m'\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m'\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, sumbool (eq n' n) (eq n' (S n))
+++++
intro H4.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.

*****
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m'\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H4 in H.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.

*****
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).

*****
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (MapCard A m1), sumbool (eq n' n) (eq n' (S n))
+++++
intro H5.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (MapCard A m1)
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (MapCard A m1)
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A (M2 A m0 (MapPut A m1 (N.div2 a) y)))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (MapCard A m1)
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y)))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H5 in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (MapCard A m1)
H4 : eq (N.odd a) true
H1 : eq n' (Init.Nat.add (MapCard A m0) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite <- H0 in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
rewrite <- H0 in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (MapCard A m1)
H4 : eq (N.odd a) true
H1 : eq n' n
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
left.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
rewrite <- H0 in H1.
left.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (MapCard A m1)
H4 : eq (N.odd a) true
H1 : eq n' n
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
eq n' n
+++++
assumption.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).

*****
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1)), sumbool (eq n' n) (eq n' (S n))
+++++
intro H5.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A (M2 A m0 (MapPut A m1 (N.div2 a) y)))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y)))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H5 in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
H4 : eq (N.odd a) true
H1 : eq n' (Init.Nat.add (MapCard A m0) (S (MapCard A m1)))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)) in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)) in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
H4 : eq (N.odd a) true
H1 : eq n' (Init.Nat.add (S (MapCard A m0)) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)) in H1.
simpl in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
H4 : eq (N.odd a) true
H1 : eq n' (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite <- H0 in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)) in H1.
simpl in H1.
rewrite <- H0 in H1.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
H4 : eq (N.odd a) true
H1 : eq n' (S n)
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
right.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)) in H1.
simpl in H1.
rewrite <- H0 in H1.
right.

*****
H5 : eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
H4 : eq (N.odd a) true
H1 : eq n' (S n)
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A m0 (MapPut A m1 (N.div2 a) y))
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
eq n' (S n)
+++++
assumption.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m'\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, sumbool (eq n' n) (eq n' (S n))
+++++
intro H4.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.

*****
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m'\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H4 in H.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.

*****
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).

*****
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m0), sumbool (eq n' n) (eq n' (S n))
+++++
intro H5.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m0)
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m0)
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A (M2 A (MapPut A m0 (N.div2 a) y) m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m0)
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H5 in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m0)
H4 : eq (N.odd a) false
H1 : eq n' (Init.Nat.add (MapCard A m0) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite <- H0 in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
rewrite <- H0 in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m0)
H4 : eq (N.odd a) false
H1 : eq n' n
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
left.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
rewrite <- H0 in H1.
left.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m0)
H4 : eq (N.odd a) false
H1 : eq n' n
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
eq n' n
+++++
assumption.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).

*****
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0)), sumbool (eq n' n) (eq n' (S n))
+++++
intro H5.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A m')
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A (M2 A (MapPut A m0 (N.div2 a) y) m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite H5 in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
H4 : eq (N.odd a) false
H1 : eq n' (Init.Nat.add (S (MapCard A m0)) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
simpl in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
simpl in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
H4 : eq (N.odd a) false
H1 : eq n' (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
rewrite <- H0 in H1.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
simpl in H1.
rewrite <- H0 in H1.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
H4 : eq (N.odd a) false
H1 : eq n' (S n)
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
right.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.
intros.
simpl in H0.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
elim (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y ( MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) ( refl_equal _) (refl_equal _) (refl_equal _)).
intro H5.
rewrite H in H1.
simpl in H1.
rewrite H5 in H1.
simpl in H1.
rewrite <- H0 in H1.
right.

*****
H5 : eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
H4 : eq (N.odd a) false
H1 : eq n' (S n)
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (M2 A (MapPut A m0 (N.div2 a) y) m1)
n,n' : nat
y : A
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m1 a y)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m1 : Map A
X : forall (m' : Map A) (a : ad) (y : A) (n n' : nat)\n (_ : eq m' (MapPut A m0 a y)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
m,m0 : Map A
A,B : Type
*****
eq n' (S n)
+++++
assumption.
-----
Lemma MapCard_Put_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_lb :\n   forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), ge (MapCard A (MapPut A m a y)) (MapCard A m)
+++++
Proof.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), ge (MapCard A (MapPut A m a y)) (MapCard A m)
+++++
unfold ge in |- *.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), le (MapCard A m) (MapCard A (MapPut A m a y))
+++++
intros.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.

*****
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (MapCard A (MapPut A m a y))
+++++
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m a y)) (MapCard A m), le (MapCard A m) (MapCard A (MapPut A m a y))
+++++
intro H.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.

*****
H : eq (MapCard A (MapPut A m a y)) (MapCard A m)
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (MapCard A (MapPut A m a y))
+++++
rewrite H.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.
rewrite H.

*****
H : eq (MapCard A (MapPut A m a y)) (MapCard A m)
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (MapCard A m)
+++++
apply le_n.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m a y)) (S (MapCard A m)), le (MapCard A m) (MapCard A (MapPut A m a y))
+++++
intro H.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.

*****
H : eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (MapCard A (MapPut A m a y))
+++++
rewrite H.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.
rewrite H.

*****
H : eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (S (MapCard A m))
+++++
apply le_n_Sn.
-----
Lemma MapCard_Put_lb : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_ub :\n   forall (m:Map A) (a:ad) (y:A),\n     MapCard A (MapPut A m a y) <= S (MapCard A m).
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), le (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
Proof.
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), le (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
intros.
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.
intros.

*****
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m a y)) (MapCard A m), le (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
intro H.
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.

*****
H : eq (MapCard A (MapPut A m a y)) (MapCard A m)
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
rewrite H.
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.
rewrite H.

*****
H : eq (MapCard A (MapPut A m a y)) (MapCard A m)
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (S (MapCard A m))
+++++
apply le_n_Sn.
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m a y)) (S (MapCard A m)), le (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
intro H.
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.

*****
H : eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
rewrite H.
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.
rewrite H.

*****
H : eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
y : A
a : ad
m : Map A
A,B : Type
*****
le (S (MapCard A m)) (S (MapCard A m))
+++++
apply le_n.
-----
Lemma MapCard_Put_ub : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) <= S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_1 :\n   forall (m:Map A) (a:ad) (y:A),\n     MapCard A (MapPut A m a y) = MapCard A m ->\n     {y : A | MapGet A m a = Some y}.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapCard A (MapPut A m a y)) (MapCard A m)), sig (fun y0 : A => eq (MapGet A m a) (Some y0))
+++++
Proof.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapCard A (MapPut A m a y)) (MapCard A m)), sig (fun y0 : A => eq (MapGet A m a) (Some y0))
+++++
simple induction m.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (y : A) (_ : eq (MapCard A (MapPut A (M0 A) a y)) (MapCard A (M0 A))), sig (fun y0 : A => eq (MapGet A (M0 A) a) (Some y0))
+++++
intros.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.

*****
H : eq (MapCard A (MapPut A (M0 A) a y)) (MapCard A (M0 A))
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M0 A) a) (Some y))
+++++
discriminate H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (MapCard A (MapPut A (M1 A a a0) a1 y)) (MapCard A (M1 A a a0))), sig (fun y0 : A => eq (MapGet A (M1 A a a0) a1) (Some y0))
+++++
intros a y a0 y0 H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.

*****
H : eq (MapCard A (MapPut A (M1 A a y) a0 y0)) (MapCard A (M1 A a y))
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
simpl in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.

*****
H : eq\n (MapCard A\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
elim (Ndiscr (Nxor a a0)).
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).

*****
H : eq\n (MapCard A\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : sig (fun p : positive => eq (N.lxor a a0) (Npos p)), sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
intro H0.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.

*****
H0 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H : eq\n (MapCard A\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
elim H0.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.
elim H0.

*****
H0 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H : eq\n (MapCard A\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall (x : positive) (_ : eq (N.lxor a a0) (Npos x)), sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
intros p H1.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.
elim H0.
intros p H1.

*****
H1 : eq (N.lxor a a0) (Npos p)
p : positive
H0 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H : eq\n (MapCard A\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
rewrite H1 in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.
elim H0.
intros p H1.
rewrite H1 in H.

*****
H1 : eq (N.lxor a a0) (Npos p)
H0 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H : eq (MapCard A (MapPut1 A a y a0 y0 p)) (S O)
p : positive
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.
elim H0.
intros p H1.
rewrite H1 in H.
rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H.

*****
H1 : eq (N.lxor a a0) (Npos p)
H0 : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
H : eq (S (S O)) (S O)
p : positive
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
discriminate H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).

*****
H : eq\n (MapCard A\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.lxor a a0) N0, sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
intro H0.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.

*****
H0 : eq (N.lxor a a0) N0
H : eq\n (MapCard A\n match N.lxor a a0 with\n | N0 => M1 A a0 y0\n | Npos p => MapPut1 A a y a0 y0 p\n end) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
rewrite H0 in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.
rewrite H0 in H.

*****
H0 : eq (N.lxor a a0) N0
H : eq (MapCard A (M1 A a0 y0)) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
rewrite (Nxor_eq _ _ H0).
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.
rewrite H0 in H.
rewrite (Nxor_eq _ _ H0).

*****
H0 : eq (N.lxor a a0) N0
H : eq (MapCard A (M1 A a0 y0)) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a0 y) a0) (Some y0))
+++++
split with y.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 y0 H.
simpl in H.
elim (Ndiscr (Nxor a a0)).
intro H0.
rewrite H0 in H.
rewrite (Nxor_eq _ _ H0).
split with y.

*****
H0 : eq (N.lxor a a0) N0
H : eq (MapCard A (M1 A a0 y0)) (S O)
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a0 y) a0) (Some y)
+++++
apply M1_semantics_1.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapCard A (MapPut A m a y)) (MapCard A m)), sig (fun y0 : A => eq (MapGet A m a) (Some y0))) (m0 : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)), sig (fun y0 : A => eq (MapGet A m0 a) (Some y0))) (a : ad) (y : A) (_ : eq (MapCard A (MapPut A (M2 A m m0) a y)) (MapCard A (M2 A m m0))), sig (fun y0 : A => eq (MapGet A (M2 A m m0) a) (Some y0))
+++++
intros.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.

*****
H : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A (M2 A m0 m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.

*****
H : eq\n (MapCard A\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1))\n (MapCard A (M2 A m0 m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).

*****
H : eq\n (MapCard A\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1))\n (MapCard A (M2 A m0 m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intro H2.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) true
H : eq\n (MapCard A\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1))\n (MapCard A (M2 A m0 m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite H2 in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.

*****
H2 : eq (N.odd a) true
H : eq (MapCard A (M2 A m0 (MapPut A m1 (N.div2 a) y)))\n (MapCard A (M2 A m0 m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
simpl in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.

*****
H2 : eq (N.odd a) true
H : eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim (X0 (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
elim (X0 (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).

*****
H2 : eq (N.odd a) true
H : eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m1 (N.div2 a)) (Some x)), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intros y0 H3.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
elim (X0 (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).
intros y0 H3.

*****
H3 : eq (MapGet A m1 (N.div2 a)) (Some y0)
y0 : A
H2 : eq (N.odd a) true
H : eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
split with y0.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
elim (X0 (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).
intros y0 H3.
split with y0.

*****
H3 : eq (MapGet A m1 (N.div2 a)) (Some y0)
y0 : A
H2 : eq (N.odd a) true
H : eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) (Some y0)
+++++
rewrite <- H3.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
elim (X0 (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).
intros y0 H3.
split with y0.
rewrite <- H3.

*****
H3 : eq (MapGet A m1 (N.div2 a)) (Some y0)
y0 : A
H2 : eq (N.odd a) true
H : eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) (MapGet A m1 (N.div2 a))
+++++
exact (MapGet_M2_bit_0_1 A a H2 m0 m1).
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).

*****
H : eq\n (MapCard A\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1))\n (MapCard A (M2 A m0 m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intro H2.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) false
H : eq\n (MapCard A\n (if N.odd a\n then M2 A m0 (MapPut A m1 (N.div2 a) y)\n else M2 A (MapPut A m0 (N.div2 a) y) m1))\n (MapCard A (M2 A m0 m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite H2 in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.

*****
H2 : eq (N.odd a) false
H : eq (MapCard A (M2 A (MapPut A m0 (N.div2 a) y) m1))\n (MapCard A (M2 A m0 m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
simpl in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.

*****
H2 : eq (N.odd a) false
H : eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H.

*****
H2 : eq (N.odd a) false
H : eq (Nat.add (MapCard A m1) (MapCard A (MapPut A m0 (N.div2 a) y)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H.
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.

*****
H2 : eq (N.odd a) false
H : eq (Nat.add (MapCard A m1) (MapCard A (MapPut A m0 (N.div2 a) y)))\n (Nat.add (MapCard A m1) (MapCard A m0))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim (X (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H.
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.
elim (X (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).

*****
H2 : eq (N.odd a) false
H : eq (Nat.add (MapCard A m1) (MapCard A (MapPut A m0 (N.div2 a) y)))\n (Nat.add (MapCard A m1) (MapCard A m0))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m0 (N.div2 a)) (Some x)), sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intros y0 H3.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H.
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.
elim (X (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).
intros y0 H3.

*****
H3 : eq (MapGet A m0 (N.div2 a)) (Some y0)
y0 : A
H2 : eq (N.odd a) false
H : eq (Nat.add (MapCard A m1) (MapCard A (MapPut A m0 (N.div2 a) y)))\n (Nat.add (MapCard A m1) (MapCard A m0))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
split with y0.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H.
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.
elim (X (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).
intros y0 H3.
split with y0.

*****
H3 : eq (MapGet A m0 (N.div2 a)) (Some y0)
y0 : A
H2 : eq (N.odd a) false
H : eq (Nat.add (MapCard A m1) (MapCard A (MapPut A m0 (N.div2 a) y)))\n (Nat.add (MapCard A m1) (MapCard A m0))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) (Some y0)
+++++
rewrite <- H3.
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
simpl in H.
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H.
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.
elim (X (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).
intros y0 H3.
split with y0.
rewrite <- H3.

*****
H3 : eq (MapGet A m0 (N.div2 a)) (Some y0)
y0 : A
H2 : eq (N.odd a) false
H : eq (Nat.add (MapCard A m1) (MapCard A (MapPut A m0 (N.div2 a) y)))\n (Nat.add (MapCard A m1) (MapCard A m0))
y : A
a : ad
X0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (MapCard A m1)),\nsig (fun y0 : A => eq (MapGet A m1 a) (Some y0))
m1 : Map A
X : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (MapCard A m0)),\nsig (fun y0 : A => eq (MapGet A m0 a) (Some y0))
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) (MapGet A m0 (N.div2 a))
+++++
exact (MapGet_M2_bit_0_0 A a H2 m0 m1).
-----
Lemma MapCard_Put_1 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_2 :\n   forall (m:Map A) (a:ad) (y:A),\n     MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapCard A (MapPut A m a y)) (S (MapCard A m))), eq (MapGet A m a) None
+++++
Proof.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapCard A (MapPut A m a y)) (S (MapCard A m))), eq (MapGet A m a) None
+++++
simple induction m.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (y : A) (_ : eq (MapCard A (MapPut A (M0 A) a y)) (S (MapCard A (M0 A)))), eq (MapGet A (M0 A) a) None
+++++
trivial.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (_ : eq (MapCard A (MapPut A (M1 A a a0) a1 y)) (S (MapCard A (M1 A a a0)))), eq (MapGet A (M1 A a a0) a1) None
+++++
intros.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.

*****
H : eq (MapCard A (MapPut A (M1 A a a0) a1 y)) (S (MapCard A (M1 A a a0)))
y : A
a1 : ad
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) None
+++++
simpl in H.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H.

*****
H : eq\n (MapCard A\n match N.lxor a a1 with\n | N0 => M1 A a1 y\n | Npos p => MapPut1 A a a0 a1 y p\n end) (S (S O))
y : A
a1 : ad
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) None
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Neqb a a1)).

*****
H : eq\n (MapCard A\n match N.lxor a a1 with\n | N0 => M1 A a1 y\n | Npos p => MapPut1 A a a0 a1 y p\n end) (S (S O))
y : A
a1 : ad
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) true, eq (MapGet A (M1 A a a0) a1) None
+++++
intro H0.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.

*****
H0 : eq (N.eqb a a1) true
H : eq\n (MapCard A\n match N.lxor a a1 with\n | N0 => M1 A a1 y\n | Npos p => MapPut1 A a a0 a1 y p\n end) (S (S O))
y : A
a1 : ad
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) None
+++++
rewrite (Neqb_complete _ _ H0) in H.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite (Neqb_complete _ _ H0) in H.

*****
H0 : eq (N.eqb a a1) true
H : eq\n (MapCard A\n match N.lxor a1 a1 with\n | N0 => M1 A a1 y\n | Npos p => MapPut1 A a1 a0 a1 y p\n end) (S (S O))
y : A
a1 : ad
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) None
+++++
rewrite (Nxor_nilpotent a1) in H.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.
rewrite (Neqb_complete _ _ H0) in H.
rewrite (Nxor_nilpotent a1) in H.

*****
H0 : eq (N.eqb a a1) true
H : eq (MapCard A (M1 A a1 y)) (S (S O))
y : A
a1 : ad
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) None
+++++
discriminate H.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Neqb a a1)).

*****
H : eq\n (MapCard A\n match N.lxor a a1 with\n | N0 => M1 A a1 y\n | Npos p => MapPut1 A a a0 a1 y p\n end) (S (S O))
y : A
a1 : ad
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) false, eq (MapGet A (M1 A a a0) a1) None
+++++
intro H0.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Neqb a a1)).
intro H0.

*****
H0 : eq (N.eqb a a1) false
H : eq\n (MapCard A\n match N.lxor a a1 with\n | N0 => M1 A a1 y\n | Npos p => MapPut1 A a a0 a1 y p\n end) (S (S O))
y : A
a1 : ad
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a a0) a1) None
+++++
exact (M1_semantics_2 A a a1 a0 H0).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapCard A (MapPut A m a y)) (S (MapCard A m))), eq (MapGet A m a) None) (m0 : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))), eq (MapGet A m0 a) None) (a : ad) (y : A) (_ : eq (MapCard A (MapPut A (M2 A m m0) a y)) (S (MapCard A (M2 A m m0)))), eq (MapGet A (M2 A m m0) a) None
+++++
intros.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, eq (MapGet A (M2 A m0 m1) a) None
+++++
intro H2.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) true
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).

*****
H2 : eq (N.odd a) true
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A m1 (N.div2 a)) None
+++++
apply (H0 (Ndiv2 a) y).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).

*****
H2 : eq (N.odd a) true
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m1 (N.div2 a) y)) (S (MapCard A m1))
+++++
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).

*****
H2 : eq (N.odd a) true
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y))) (Init.Nat.add (MapCard A m0) (S (MapCard A m1)))
+++++
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).

*****
H2 : eq (N.odd a) true
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y))) (Init.Nat.add (S (MapCard A m0)) (MapCard A m1))
+++++
simpl in H1.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.

*****
H2 : eq (N.odd a) true
H1 : eq\n (MapCard A\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y)\n | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y))) (Init.Nat.add (S (MapCard A m0)) (MapCard A m1))
+++++
simpl in |- *.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.
simpl in |- *.

*****
H2 : eq (N.odd a) true
H1 : eq\n (MapCard A\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y)\n | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y))) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
+++++
rewrite <- H1.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.
simpl in |- *.
rewrite <- H1.

*****
H2 : eq (N.odd a) true
H1 : eq\n (MapCard A\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y)\n | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y))) (MapCard A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
clear H1.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.
simpl in |- *.
rewrite <- H1.
clear H1.

*****
H2 : eq (N.odd a) true
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 a) y))) (MapCard A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
induction a.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.
simpl in |- *.
rewrite <- H1.
clear H1.
induction a.

*****
H2 : eq (N.odd N0) true
y : A
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 N0) y))) (MapCard A (M2 A (MapPut A m0 N0 y) m1))
+++++
discriminate H2.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.
simpl in |- *.
rewrite <- H1.
clear H1.
induction a.

*****
H2 : eq (N.odd (Npos p)) true
y : A
p : positive
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 (Npos p)) y))) (MapCard A match p with | xI p => M2 A m0 (MapPut A m1 (Npos p) y) | xO p => M2 A (MapPut A m0 (Npos p) y) m1 | xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
induction p.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.
simpl in |- *.
rewrite <- H1.
clear H1.
induction a.
induction p.

*****
IHp : forall _ : eq (N.odd (Npos p)) true,\neq\n (Init.Nat.add (MapCard A m0)\n (MapCard A (MapPut A m1 (N.div2 (Npos p)) y)))\n (MapCard A\n match p with\n | xI p => M2 A m0 (MapPut A m1 (Npos p) y)\n | xO p => M2 A (MapPut A m0 (Npos p) y) m1\n | xH => M2 A m0 (MapPut A m1 N0 y)\n end)
H2 : eq (N.odd (Npos (xI p))) true
y : A
p : positive
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 (Npos (xI p))) y))) (MapCard A (M2 A m0 (MapPut A m1 (Npos p) y)))
+++++
reflexivity.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.
simpl in |- *.
rewrite <- H1.
clear H1.
induction a.
induction p.

*****
IHp : forall _ : eq (N.odd (Npos p)) true,\neq\n (Init.Nat.add (MapCard A m0)\n (MapCard A (MapPut A m1 (N.div2 (Npos p)) y)))\n (MapCard A\n match p with\n | xI p => M2 A m0 (MapPut A m1 (Npos p) y)\n | xO p => M2 A (MapPut A m0 (Npos p) y) m1\n | xH => M2 A m0 (MapPut A m1 N0 y)\n end)
H2 : eq (N.odd (Npos (xO p))) true
y : A
p : positive
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 (Npos (xO p))) y))) (MapCard A (M2 A (MapPut A m0 (Npos p) y) m1))
+++++
discriminate H2.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply (H0 (Ndiv2 a) y).
apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)).
simpl in H1.
simpl in |- *.
rewrite <- H1.
clear H1.
induction a.
induction p.

*****
H2 : eq (N.odd (Npos xH)) true
y : A
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A (MapPut A m1 (N.div2 (Npos xH)) y))) (MapCard A (M2 A m0 (MapPut A m1 N0 y)))
+++++
reflexivity.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, eq (MapGet A (M2 A m0 m1) a) None
+++++
intro H2.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).

*****
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A m0 (N.div2 a)) None
+++++
apply (H (Ndiv2 a) y).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).

*****
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
+++++
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).

*****
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
forall _ : eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1)) (Init.Nat.add (S (MapCard A m0)) (MapCard A m1)), eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
+++++
intro.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
intro.

*****
H3 : eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1))\n (Init.Nat.add (S (MapCard A m0)) (MapCard A m1))
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
+++++
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H3.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
intro.
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H3.

*****
H3 : eq (Nat.add (MapCard A m1) (MapCard A (MapPut A m0 (N.div2 a) y)))\n (Init.Nat.add (S (MapCard A m0)) (MapCard A m1))
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
+++++
rewrite (plus_comm (S (MapCard A m0)) (MapCard A m1)) in H3.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
intro.
rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1)) in H3.
rewrite (plus_comm (S (MapCard A m0)) (MapCard A m1)) in H3.

*****
H3 : eq (Nat.add (MapCard A m1) (MapCard A (MapPut A m0 (N.div2 a) y)))\n (Nat.add (MapCard A m1) (S (MapCard A m0)))
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m0 (N.div2 a) y)) (S (MapCard A m0))
+++++
exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H3).
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).

*****
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1)) (Init.Nat.add (S (MapCard A m0)) (MapCard A m1))
+++++
simpl in |- *.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
simpl in |- *.

*****
H2 : eq (N.odd a) false
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1)) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
+++++
simpl in H1.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
simpl in |- *.
simpl in H1.

*****
H2 : eq (N.odd a) false
H1 : eq\n (MapCard A\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y)\n | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1)) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
+++++
rewrite <- H1.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
simpl in |- *.
simpl in H1.
rewrite <- H1.

*****
H2 : eq (N.odd a) false
H1 : eq\n (MapCard A\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y)\n | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
a : ad
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 a) y)) (MapCard A m1)) (MapCard A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
induction a.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
simpl in |- *.
simpl in H1.
rewrite <- H1.
induction a.

*****
H2 : eq (N.odd N0) false
H1 : eq (MapCard A (M2 A (MapPut A m0 N0 y) m1))\n (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 N0) y)) (MapCard A m1)) (MapCard A (M2 A (MapPut A m0 N0 y) m1))
+++++
trivial.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
simpl in |- *.
simpl in H1.
rewrite <- H1.
induction a.

*****
H2 : eq (N.odd (Npos p)) false
H1 : eq\n (MapCard A\n match p with\n | xI p => M2 A m0 (MapPut A m1 (Npos p) y)\n | xO p => M2 A (MapPut A m0 (Npos p) y) m1\n | xH => M2 A m0 (MapPut A m1 N0 y)\n end) (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
p : positive
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 (Npos p)) y)) (MapCard A m1)) (MapCard A match p with | xI p => M2 A m0 (MapPut A m1 (Npos p) y) | xO p => M2 A (MapPut A m0 (Npos p) y) m1 | xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
induction p.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
simpl in |- *.
simpl in H1.
rewrite <- H1.
induction a.
induction p.

*****
IHp : forall\n (_ : eq\n (MapCard A\n match p with\n | xI p => M2 A m0 (MapPut A m1 (Npos p) y)\n | xO p => M2 A (MapPut A m0 (Npos p) y) m1\n | xH => M2 A m0 (MapPut A m1 N0 y)\n end) (S (Init.Nat.add (MapCard A m0) (MapCard A m1))))\n (_ : eq (N.odd (Npos p)) false),\neq\n (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 (Npos p)) y))\n (MapCard A m1))\n (MapCard A\n match p with\n | xI p => M2 A m0 (MapPut A m1 (Npos p) y)\n | xO p => M2 A (MapPut A m0 (Npos p) y) m1\n | xH => M2 A m0 (MapPut A m1 N0 y)\n end)
H2 : eq (N.odd (Npos (xI p))) false
H1 : eq (MapCard A (M2 A m0 (MapPut A m1 (Npos p) y)))\n (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
p : positive
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 (Npos (xI p))) y)) (MapCard A m1)) (MapCard A (M2 A m0 (MapPut A m1 (Npos p) y)))
+++++
discriminate H2.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
simpl in |- *.
simpl in H1.
rewrite <- H1.
induction a.
induction p.

*****
IHp : forall\n (_ : eq\n (MapCard A\n match p with\n | xI p => M2 A m0 (MapPut A m1 (Npos p) y)\n | xO p => M2 A (MapPut A m0 (Npos p) y) m1\n | xH => M2 A m0 (MapPut A m1 N0 y)\n end) (S (Init.Nat.add (MapCard A m0) (MapCard A m1))))\n (_ : eq (N.odd (Npos p)) false),\neq\n (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 (Npos p)) y))\n (MapCard A m1))\n (MapCard A\n match p with\n | xI p => M2 A m0 (MapPut A m1 (Npos p) y)\n | xO p => M2 A (MapPut A m0 (Npos p) y) m1\n | xH => M2 A m0 (MapPut A m1 N0 y)\n end)
H2 : eq (N.odd (Npos (xO p))) false
H1 : eq (MapCard A (M2 A (MapPut A m0 (Npos p) y) m1))\n (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
p : positive
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 (Npos (xO p))) y)) (MapCard A m1)) (MapCard A (M2 A (MapPut A m0 (Npos p) y) m1))
+++++
reflexivity.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply (H (Ndiv2 a) y).
cut (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 = S (MapCard A m0) + MapCard A m1).
simpl in |- *.
simpl in H1.
rewrite <- H1.
induction a.
induction p.

*****
H2 : eq (N.odd (Npos xH)) false
H1 : eq (MapCard A (M2 A m0 (MapPut A m1 N0 y)))\n (S (Init.Nat.add (MapCard A m0) (MapCard A m1)))
y : A
H0 : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m1 a y)) (S (MapCard A m1))),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (y : A)\n (_ : eq (MapCard A (MapPut A m0 a y)) (S (MapCard A m0))),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (MapPut A m0 (N.div2 (Npos xH)) y)) (MapCard A m1)) (MapCard A (M2 A m0 (MapPut A m1 N0 y)))
+++++
discriminate H2.
-----
Lemma MapCard_Put_2 : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_1_conv :\n   forall (m:Map A) (a:ad) (y y':A),\n     MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.
-----
Lemma MapCard_Put_1_conv : forall (m:Map A) (a:ad) (y y':A), MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y y' : A) (_ : eq (MapGet A m a) (Some y)), eq (MapCard A (MapPut A m a y')) (MapCard A m)
+++++
Proof.
-----
Lemma MapCard_Put_1_conv : forall (m:Map A) (a:ad) (y y':A), MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y y' : A) (_ : eq (MapGet A m a) (Some y)), eq (MapCard A (MapPut A m a y')) (MapCard A m)
+++++
intros.
-----
Lemma MapCard_Put_1_conv : forall (m:Map A) (a:ad) (y y':A), MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.
Proof.
intros.

*****
H : eq (MapGet A m a) (Some y)
y,y' : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m a y')) (MapCard A m)
+++++
elim (MapCard_Put_sum m (MapPut A m a y') a y' (MapCard A m) (MapCard A (MapPut A m a y')) (refl_equal _) ( refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Put_1_conv : forall (m:Map A) (a:ad) (y y':A), MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y') a y' (MapCard A m) (MapCard A (MapPut A m a y')) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
H : eq (MapGet A m a) (Some y)
y,y' : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m a y')) (MapCard A m), eq (MapCard A (MapPut A m a y')) (MapCard A m)
+++++
trivial.
-----
Lemma MapCard_Put_1_conv : forall (m:Map A) (a:ad) (y y':A), MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y') a y' (MapCard A m) (MapCard A (MapPut A m a y')) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
H : eq (MapGet A m a) (Some y)
y,y' : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m a y')) (S (MapCard A m)), eq (MapCard A (MapPut A m a y')) (MapCard A m)
+++++
intro H0.
-----
Lemma MapCard_Put_1_conv : forall (m:Map A) (a:ad) (y y':A), MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y') a y' (MapCard A m) (MapCard A (MapPut A m a y')) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.

*****
H0 : eq (MapCard A (MapPut A m a y')) (S (MapCard A m))
H : eq (MapGet A m a) (Some y)
y,y' : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m a y')) (MapCard A m)
+++++
rewrite (MapCard_Put_2 m a y' H0) in H.
-----
Lemma MapCard_Put_1_conv : forall (m:Map A) (a:ad) (y y':A), MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y') a y' (MapCard A m) (MapCard A (MapPut A m a y')) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
rewrite (MapCard_Put_2 m a y' H0) in H.

*****
H0 : eq (MapCard A (MapPut A m a y')) (S (MapCard A m))
H : eq None (Some y)
y,y' : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m a y')) (MapCard A m)
+++++
discriminate H.
-----
Lemma MapCard_Put_1_conv : forall (m:Map A) (a:ad) (y y':A), MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y') a y' (MapCard A m) (MapCard A (MapPut A m a y')) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_2_conv :\n   forall (m:Map A) (a:ad) (y:A),\n     MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) None), eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
Proof.
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) None), eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
intros.
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.
intros.

*****
H : eq (MapGet A m a) None
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
H : eq (MapGet A m a) None
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m a y)) (MapCard A m), eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
intro H0.
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.

*****
H0 : eq (MapCard A (MapPut A m a y)) (MapCard A m)
H : eq (MapGet A m a) None
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
elim (MapCard_Put_1 m a y H0).
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
elim (MapCard_Put_1 m a y H0).

*****
H0 : eq (MapCard A (MapPut A m a y)) (MapCard A m)
H : eq (MapGet A m a) None
y : A
a : ad
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
intros y' H1.
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
elim (MapCard_Put_1 m a y H0).
intros y' H1.

*****
H1 : eq (MapGet A m a) (Some y')
y' : A
H0 : eq (MapCard A (MapPut A m a y)) (MapCard A m)
H : eq (MapGet A m a) None
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
rewrite H1 in H.
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
elim (MapCard_Put_1 m a y H0).
intros y' H1.
rewrite H1 in H.

*****
H1 : eq (MapGet A m a) (Some y')
H0 : eq (MapCard A (MapPut A m a y)) (MapCard A m)
H : eq (Some y') None
y,y' : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
discriminate H.
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
H : eq (MapGet A m a) None
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapPut A m a y)) (S (MapCard A m)), eq (MapCard A (MapPut A m a y)) (S (MapCard A m))
+++++
trivial.
-----
Lemma MapCard_Put_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).
Proof.
intros.
elim (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m) (MapCard A (MapPut A m a y)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****

*****

+++++
Qed.
-----
Lemma MapCard_ext :\n   forall m m':Map A,\n     eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : eqm A (MapGet A m) (MapGet A m')), eq (MapCard A m) (MapCard A m')
+++++
Proof.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : eqm A (MapGet A m) (MapGet A m')), eq (MapCard A m) (MapCard A m')
+++++
unfold eqm in |- *.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : forall a : ad, eq (MapGet A m a) (MapGet A m' a)), eq (MapCard A m) (MapCard A m')
+++++
intros.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.

*****
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (MapCard A m) (MapCard A m')
+++++
rewrite (MapCard_as_length m).
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).

*****
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (length (alist_of_Map A m)) (MapCard A m')
+++++
rewrite (MapCard_as_length m').
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').

*****
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (length (alist_of_Map A m)) (length (alist_of_Map A m'))
+++++
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).

*****
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (length (alist_of_Map A m')) (length (alist_of_Map A m'))
+++++
reflexivity.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).

*****
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eqm A (alist_semantics A (alist_of_Map A m)) (alist_semantics A (alist_of_Map A m'))
+++++
unfold eqm in |- *.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).
unfold eqm in |- *.

*****
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
forall a : ad, eq (alist_semantics A (alist_of_Map A m) a) (alist_semantics A (alist_of_Map A m') a)
+++++
intro.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).
unfold eqm in |- *.
intro.

*****
a : ad
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (alist_semantics A (alist_of_Map A m) a) (alist_semantics A (alist_of_Map A m') a)
+++++
rewrite (Map_of_alist_semantics A (alist_of_Map A m) a).
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).
unfold eqm in |- *.
intro.
rewrite (Map_of_alist_semantics A (alist_of_Map A m) a).

*****
a : ad
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (MapGet A (Map_of_alist A (alist_of_Map A m)) a) (alist_semantics A (alist_of_Map A m') a)
+++++
rewrite (Map_of_alist_semantics A (alist_of_Map A m') a).
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).
unfold eqm in |- *.
intro.
rewrite (Map_of_alist_semantics A (alist_of_Map A m) a).
rewrite (Map_of_alist_semantics A (alist_of_Map A m') a).

*****
a : ad
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (MapGet A (Map_of_alist A (alist_of_Map A m)) a) (MapGet A (Map_of_alist A (alist_of_Map A m')) a)
+++++
rewrite (Map_of_alist_of_Map A m' a).
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).
unfold eqm in |- *.
intro.
rewrite (Map_of_alist_semantics A (alist_of_Map A m) a).
rewrite (Map_of_alist_semantics A (alist_of_Map A m') a).
rewrite (Map_of_alist_of_Map A m' a).

*****
a : ad
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (MapGet A (Map_of_alist A (alist_of_Map A m)) a) (MapGet A m' a)
+++++
rewrite (Map_of_alist_of_Map A m a).
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).
unfold eqm in |- *.
intro.
rewrite (Map_of_alist_semantics A (alist_of_Map A m) a).
rewrite (Map_of_alist_semantics A (alist_of_Map A m') a).
rewrite (Map_of_alist_of_Map A m' a).
rewrite (Map_of_alist_of_Map A m a).

*****
a : ad
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
eq (MapGet A m a) (MapGet A m' a)
+++++
exact (H a).
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).

*****
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
alist_sorted_2 A (alist_of_Map A m)
+++++
apply alist_of_Map_sorts2.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).

*****
H : forall a : ad, eq (MapGet A m a) (MapGet A m' a)
m,m' : Map A
A,B : Type
*****
alist_sorted_2 A (alist_of_Map A m')
+++++
apply alist_of_Map_sorts2.
-----
Lemma MapCard_ext : forall m m':Map A, eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.
Proof.
unfold eqm in |- *.
intros.
rewrite (MapCard_as_length m).
rewrite (MapCard_as_length m').
rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')).

*****

*****

+++++
Qed.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).

*****
A,B : Type
*****
forall m : Map A, eq (MapCard A m) (MapCard unit (MapDom A m))
+++++
Proof.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.

*****
A,B : Type
*****
forall m : Map A, eq (MapCard A m) (MapCard unit (MapDom A m))
+++++
simple induction m.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
eq (MapCard A (M0 A)) (MapCard unit (MapDom A (M0 A)))
+++++
trivial.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A), eq (MapCard A (M1 A a a0)) (MapCard unit (MapDom A (M1 A a a0)))
+++++
trivial.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : eq (MapCard A m) (MapCard unit (MapDom A m))) (m0 : Map A) (_ : eq (MapCard A m0) (MapCard unit (MapDom A m0))), eq (MapCard A (M2 A m m0)) (MapCard unit (MapDom A (M2 A m m0)))
+++++
trivial.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.
trivial.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : eq (MapCard A m) (MapCard unit (MapDom A m))) (m0 : Map A) (_ : eq (MapCard A m0) (MapCard unit (MapDom A m0))), eq (MapCard A (M2 A m m0)) (MapCard unit (MapDom A (M2 A m m0)))
+++++
intros.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.
trivial.
intros.

*****
H0 : eq (MapCard A m1) (MapCard unit (MapDom A m1))
m1 : Map A
H : eq (MapCard A m0) (MapCard unit (MapDom A m0))
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (M2 A m0 m1)) (MapCard unit (MapDom A (M2 A m0 m1)))
+++++
simpl in |- *.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.
trivial.
intros.
simpl in |- *.

*****
H0 : eq (MapCard A m1) (MapCard unit (MapDom A m1))
m1 : Map A
H : eq (MapCard A m0) (MapCard unit (MapDom A m0))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard unit (MapDom A m0)) (MapCard unit (MapDom A m1)))
+++++
rewrite H.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.
trivial.
intros.
simpl in |- *.
rewrite H.

*****
H0 : eq (MapCard A m1) (MapCard unit (MapDom A m1))
m1 : Map A
H : eq (MapCard A m0) (MapCard unit (MapDom A m0))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard unit (MapDom A m0)) (MapCard A m1)) (Init.Nat.add (MapCard unit (MapDom A m0)) (MapCard unit (MapDom A m1)))
+++++
rewrite H0.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.
trivial.
intros.
simpl in |- *.
rewrite H.
rewrite H0.

*****
H0 : eq (MapCard A m1) (MapCard unit (MapDom A m1))
m1 : Map A
H : eq (MapCard A m0) (MapCard unit (MapDom A m0))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard unit (MapDom A m0)) (MapCard unit (MapDom A m1))) (Init.Nat.add (MapCard unit (MapDom A m0)) (MapCard unit (MapDom A m1)))
+++++
reflexivity.
-----
Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Dom_Put_behind :\n   forall (m:Map A) (a:ad) (y:A),\n     MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), eq (MapDom A (MapPut_behind A m a y)) (MapDom A (MapPut A m a y))
+++++
Proof.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), eq (MapDom A (MapPut_behind A m a y)) (MapDom A (MapPut A m a y))
+++++
simple induction m.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (y : A), eq (MapDom A (MapPut_behind A (M0 A) a y)) (MapDom A (MapPut A (M0 A) a y))
+++++
trivial.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A), eq (MapDom A (MapPut_behind A (M1 A a a0) a1 y)) (MapDom A (MapPut A (M1 A a a0) a1 y))
+++++
intros a y a0 y0.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.

*****
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapDom A (MapPut_behind A (M1 A a y) a0 y0)) (MapDom A (MapPut A (M1 A a y) a0 y0))
+++++
simpl in |- *.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.

*****
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapDom A match N.lxor a a0 with | N0 => M1 A a y | Npos p => MapPut1 A a y a0 y0 p end) (MapDom A match N.lxor a a0 with | N0 => M1 A a0 y0 | Npos p => MapPut1 A a y a0 y0 p end)
+++++
elim (Ndiscr (Nxor a a0)).
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).

*****
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : sig (fun p : positive => eq (N.lxor a a0) (Npos p)), eq (MapDom A match N.lxor a a0 with | N0 => M1 A a y | Npos p => MapPut1 A a y a0 y0 p end) (MapDom A match N.lxor a a0 with | N0 => M1 A a0 y0 | Npos p => MapPut1 A a y a0 y0 p end)
+++++
intro H.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).
intro H.

*****
H : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapDom A match N.lxor a a0 with | N0 => M1 A a y | Npos p => MapPut1 A a y a0 y0 p end) (MapDom A match N.lxor a a0 with | N0 => M1 A a0 y0 | Npos p => MapPut1 A a y a0 y0 p end)
+++++
elim H.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).
intro H.
elim H.

*****
H : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall (x : positive) (_ : eq (N.lxor a a0) (Npos x)), eq (MapDom A match N.lxor a a0 with | N0 => M1 A a y | Npos p0 => MapPut1 A a y a0 y0 p0 end) (MapDom A match N.lxor a a0 with | N0 => M1 A a0 y0 | Npos p0 => MapPut1 A a y a0 y0 p0 end)
+++++
intros p H0.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).
intro H.
elim H.
intros p H0.

*****
H0 : eq (N.lxor a a0) (Npos p)
p : positive
H : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapDom A match N.lxor a a0 with | N0 => M1 A a y | Npos p => MapPut1 A a y a0 y0 p end) (MapDom A match N.lxor a a0 with | N0 => M1 A a0 y0 | Npos p => MapPut1 A a y a0 y0 p end)
+++++
rewrite H0.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).
intro H.
elim H.
intros p H0.
rewrite H0.

*****
H0 : eq (N.lxor a a0) (Npos p)
p : positive
H : sig (fun p : positive => eq (N.lxor a a0) (Npos p))
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapDom A (MapPut1 A a y a0 y0 p)) (MapDom A (MapPut1 A a y a0 y0 p))
+++++
reflexivity.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).

*****
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.lxor a a0) N0, eq (MapDom A match N.lxor a a0 with | N0 => M1 A a y | Npos p => MapPut1 A a y a0 y0 p end) (MapDom A match N.lxor a a0 with | N0 => M1 A a0 y0 | Npos p => MapPut1 A a y a0 y0 p end)
+++++
intro H.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).
intro H.

*****
H : eq (N.lxor a a0) N0
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapDom A match N.lxor a a0 with | N0 => M1 A a y | Npos p => MapPut1 A a y a0 y0 p end) (MapDom A match N.lxor a a0 with | N0 => M1 A a0 y0 | Npos p => MapPut1 A a y a0 y0 p end)
+++++
rewrite H.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).
intro H.
rewrite H.

*****
H : eq (N.lxor a a0) N0
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapDom A (M1 A a y)) (MapDom A (M1 A a0 y0))
+++++
rewrite (Nxor_eq _ _ H).
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros a y a0 y0.
simpl in |- *.
elim (Ndiscr (Nxor a a0)).
intro H.
rewrite H.
rewrite (Nxor_eq _ _ H).

*****
H : eq (N.lxor a a0) N0
y0 : A
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapDom A (M1 A a0 y)) (MapDom A (M1 A a0 y0))
+++++
reflexivity.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (a : ad) (y : A), eq (MapDom A (MapPut_behind A m a y)) (MapDom A (MapPut A m a y))) (m0 : Map A) (_ : forall (a : ad) (y : A), eq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))) (a : ad) (y : A), eq (MapDom A (MapPut_behind A (M2 A m m0) a y)) (MapDom A (MapPut A (M2 A m m0) a y))
+++++
intros.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A (MapPut_behind A (M2 A m0 m1) a y)) (MapDom A (MapPut A (M2 A m0 m1) a y))
+++++
simpl in |- *.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A match a with | N0 => M2 A (MapPut_behind A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut_behind A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut_behind A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut_behind A m1 N0 y) end) (MapDom A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
elim (Ndiscr a).
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
forall _ : sig (fun p : positive => eq a (Npos p)), eq (MapDom A match a with | N0 => M2 A (MapPut_behind A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut_behind A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut_behind A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut_behind A m1 N0 y) end) (MapDom A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
intro H1.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.

*****
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A match a with | N0 => M2 A (MapPut_behind A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut_behind A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut_behind A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut_behind A m1 N0 y) end) (MapDom A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
elim H1.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.

*****
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
forall (x : positive) (_ : eq a (Npos x)), eq (MapDom A match a with | N0 => M2 A (MapPut_behind A m0 N0 y) m1 | Npos (xI p1) => M2 A m0 (MapPut_behind A m1 (Npos p1) y) | Npos (xO p1) => M2 A (MapPut_behind A m0 (Npos p1) y) m1 | Npos xH => M2 A m0 (MapPut_behind A m1 N0 y) end) (MapDom A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y) | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
intros p H2.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.

*****
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A match a with | N0 => M2 A (MapPut_behind A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut_behind A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut_behind A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut_behind A m1 N0 y) end) (MapDom A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
rewrite H2.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.

*****
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A match p with | xI p => M2 A m0 (MapPut_behind A m1 (Npos p) y) | xO p => M2 A (MapPut_behind A m0 (Npos p) y) m1 | xH => M2 A m0 (MapPut_behind A m1 N0 y) end) (MapDom A match p with | xI p => M2 A m0 (MapPut A m1 (Npos p) y) | xO p => M2 A (MapPut A m0 (Npos p) y) m1 | xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
case p.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.

*****
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
forall p : positive, eq (MapDom A (M2 A m0 (MapPut_behind A m1 (Npos p) y))) (MapDom A (M2 A m0 (MapPut A m1 (Npos p) y)))
+++++
intro p0.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.
intro p0.

*****
p0 : positive
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A (M2 A m0 (MapPut_behind A m1 (Npos p0) y))) (MapDom A (M2 A m0 (MapPut A m1 (Npos p0) y)))
+++++
simpl in |- *.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.
intro p0.
simpl in |- *.

*****
p0 : positive
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (M2 unit (MapDom A m0) (MapDom A (MapPut_behind A m1 (Npos p0) y))) (M2 unit (MapDom A m0) (MapDom A (MapPut A m1 (Npos p0) y)))
+++++
rewrite H0.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.
intro p0.
simpl in |- *.
rewrite H0.

*****
p0 : positive
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (M2 unit (MapDom A m0) (MapDom A (MapPut A m1 (Npos p0) y))) (M2 unit (MapDom A m0) (MapDom A (MapPut A m1 (Npos p0) y)))
+++++
reflexivity.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.

*****
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
forall p : positive, eq (MapDom A (M2 A (MapPut_behind A m0 (Npos p) y) m1)) (MapDom A (M2 A (MapPut A m0 (Npos p) y) m1))
+++++
intro p0.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.
intro p0.

*****
p0 : positive
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A (M2 A (MapPut_behind A m0 (Npos p0) y) m1)) (MapDom A (M2 A (MapPut A m0 (Npos p0) y) m1))
+++++
simpl in |- *.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.
intro p0.
simpl in |- *.

*****
p0 : positive
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (M2 unit (MapDom A (MapPut_behind A m0 (Npos p0) y)) (MapDom A m1)) (M2 unit (MapDom A (MapPut A m0 (Npos p0) y)) (MapDom A m1))
+++++
rewrite H.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.
intro p0.
simpl in |- *.
rewrite H.

*****
p0 : positive
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (M2 unit (MapDom A (MapPut A m0 (Npos p0) y)) (MapDom A m1)) (M2 unit (MapDom A (MapPut A m0 (Npos p0) y)) (MapDom A m1))
+++++
reflexivity.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.

*****
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A (M2 A m0 (MapPut_behind A m1 N0 y))) (MapDom A (M2 A m0 (MapPut A m1 N0 y)))
+++++
simpl in |- *.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.
simpl in |- *.

*****
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (M2 unit (MapDom A m0) (MapDom A (MapPut_behind A m1 N0 y))) (M2 unit (MapDom A m0) (MapDom A (MapPut A m1 N0 y)))
+++++
rewrite H0.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
elim H1.
intros p H2.
rewrite H2.
case p.
simpl in |- *.
rewrite H0.

*****
H2 : eq a (Npos p)
p : positive
H1 : sig (fun p : positive => eq a (Npos p))
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (M2 unit (MapDom A m0) (MapDom A (MapPut A m1 N0 y))) (M2 unit (MapDom A m0) (MapDom A (MapPut A m1 N0 y)))
+++++
reflexivity.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).

*****
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
forall _ : eq a N0, eq (MapDom A match a with | N0 => M2 A (MapPut_behind A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut_behind A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut_behind A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut_behind A m1 N0 y) end) (MapDom A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
intro H1.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.

*****
H1 : eq a N0
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A match a with | N0 => M2 A (MapPut_behind A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut_behind A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut_behind A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut_behind A m1 N0 y) end) (MapDom A match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end)
+++++
rewrite H1.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
rewrite H1.

*****
H1 : eq a N0
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (MapDom A (M2 A (MapPut_behind A m0 N0 y) m1)) (MapDom A (M2 A (MapPut A m0 N0 y) m1))
+++++
simpl in |- *.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
rewrite H1.
simpl in |- *.

*****
H1 : eq a N0
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (M2 unit (MapDom A (MapPut_behind A m0 N0 y)) (MapDom A m1)) (M2 unit (MapDom A (MapPut A m0 N0 y)) (MapDom A m1))
+++++
rewrite H.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.
intros.
simpl in |- *.
elim (Ndiscr a).
intro H1.
rewrite H1.
simpl in |- *.
rewrite H.

*****
H1 : eq a N0
y : A
a : ad
H0 : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m1 a y)) (MapDom A (MapPut A m1 a y))
m1 : Map A
H : forall (a : ad) (y : A),\neq (MapDom A (MapPut_behind A m0 a y)) (MapDom A (MapPut A m0 a y))
m,m0 : Map A
A,B : Type
*****
eq (M2 unit (MapDom A (MapPut A m0 N0 y)) (MapDom A m1)) (M2 unit (MapDom A (MapPut A m0 N0 y)) (MapDom A m1))
+++++
reflexivity.
-----
Lemma MapCard_Dom_Put_behind : forall (m:Map A) (a:ad) (y:A), MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_behind_Put :\n   forall (m:Map A) (a:ad) (y:A),\n     MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).
-----
Lemma MapCard_Put_behind_Put : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), eq (MapCard A (MapPut_behind A m a y)) (MapCard A (MapPut A m a y))
+++++
Proof.
-----
Lemma MapCard_Put_behind_Put : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A), eq (MapCard A (MapPut_behind A m a y)) (MapCard A (MapPut A m a y))
+++++
intros.
-----
Lemma MapCard_Put_behind_Put : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).
Proof.
intros.

*****
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapPut_behind A m a y)) (MapCard A (MapPut A m a y))
+++++
rewrite MapCard_Dom.
-----
Lemma MapCard_Put_behind_Put : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).
Proof.
intros.
rewrite MapCard_Dom.

*****
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard unit (MapDom A (MapPut_behind A m a y))) (MapCard A (MapPut A m a y))
+++++
rewrite MapCard_Dom.
-----
Lemma MapCard_Put_behind_Put : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).
Proof.
intros.
rewrite MapCard_Dom.
rewrite MapCard_Dom.

*****
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard unit (MapDom A (MapPut_behind A m a y))) (MapCard unit (MapDom A (MapPut A m a y)))
+++++
rewrite MapCard_Dom_Put_behind.
-----
Lemma MapCard_Put_behind_Put : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).
Proof.
intros.
rewrite MapCard_Dom.
rewrite MapCard_Dom.
rewrite MapCard_Dom_Put_behind.

*****
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard unit (MapDom A (MapPut A m a y))) (MapCard unit (MapDom A (MapPut A m a y)))
+++++
reflexivity.
-----
Lemma MapCard_Put_behind_Put : forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).
Proof.
intros.
rewrite MapCard_Dom.
rewrite MapCard_Dom.
rewrite MapCard_Dom_Put_behind.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Put_behind_sum :\n   forall (m m':Map A) (a:ad) (y:A) (n n':nat),\n     m' = MapPut_behind A m a y ->\n     n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut_behind A m a y)) (_ : eq n (MapCard A m)) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
+++++
Proof.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad) (y : A) (n n' : nat) (_ : eq m' (MapPut_behind A m a y)) (_ : eq n (MapCard A m)) (_ : eq n' (MapCard A m')), sumbool (eq n' n) (eq n' (S n))
+++++
intros.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
intros.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A m)
H : eq m' (MapPut_behind A m a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
sumbool (eq n' n) (eq n' (S n))
+++++
apply (MapCard_Put_sum m (MapPut A m a y) a y n n').
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
intros.
apply (MapCard_Put_sum m (MapPut A m a y) a y n n').

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A m)
H : eq m' (MapPut_behind A m a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq (MapPut A m a y) (MapPut A m a y)
+++++
trivial.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
intros.
apply (MapCard_Put_sum m (MapPut A m a y) a y n n').

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A m)
H : eq m' (MapPut_behind A m a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq n (MapCard A m)
+++++
trivial.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
intros.
apply (MapCard_Put_sum m (MapPut A m a y) a y n n').

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A m)
H : eq m' (MapPut_behind A m a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq n' (MapCard A (MapPut A m a y))
+++++
trivial.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
intros.
apply (MapCard_Put_sum m (MapPut A m a y) a y n n').
trivial.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A m)
H : eq m' (MapPut_behind A m a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq n' (MapCard A (MapPut A m a y))
+++++
rewrite <- MapCard_Put_behind_Put.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
intros.
apply (MapCard_Put_sum m (MapPut A m a y) a y n n').
trivial.
rewrite <- MapCard_Put_behind_Put.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A m)
H : eq m' (MapPut_behind A m a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq n' (MapCard A (MapPut_behind A m a y))
+++++
rewrite <- H.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
intros.
apply (MapCard_Put_sum m (MapPut A m a y) a y n n').
trivial.
rewrite <- MapCard_Put_behind_Put.
rewrite <- H.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A m)
H : eq m' (MapPut_behind A m a y)
n,n' : nat
y : A
a : ad
m,m' : Map A
A,B : Type
*****
eq n' (MapCard A m')
+++++
assumption.
-----
Lemma MapCard_Put_behind_sum : forall (m m':Map A) (a:ad) (y:A) (n n':nat), m' = MapPut_behind A m a y -> n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.
Proof.
intros.
apply (MapCard_Put_sum m (MapPut A m a y) a y n n').

*****

*****

+++++
Qed.
-----
Lemma MapCard_makeM2 :\n   forall m m':Map A, MapCard A (makeM2 A m m') = MapCard A m + MapCard A m'.
-----
Lemma MapCard_makeM2 : forall m m':Map A, MapCard A (makeM2 A m m') = MapCard A m + MapCard A m'.

*****
A,B : Type
*****
forall m m' : Map A, eq (MapCard A (makeM2 A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
Proof.
-----
Lemma MapCard_makeM2 : forall m m':Map A, MapCard A (makeM2 A m m') = MapCard A m + MapCard A m'.
Proof.

*****
A,B : Type
*****
forall m m' : Map A, eq (MapCard A (makeM2 A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
intros.
-----
Lemma MapCard_makeM2 : forall m m':Map A, MapCard A (makeM2 A m m') = MapCard A m + MapCard A m'.
Proof.
intros.

*****
m,m' : Map A
A,B : Type
*****
eq (MapCard A (makeM2 A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
rewrite (MapCard_ext _ _ (makeM2_M2 A m m')).
-----
Lemma MapCard_makeM2 : forall m m':Map A, MapCard A (makeM2 A m m') = MapCard A m + MapCard A m'.
Proof.
intros.
rewrite (MapCard_ext _ _ (makeM2_M2 A m m')).

*****
m,m' : Map A
A,B : Type
*****
eq (MapCard A (M2 A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
reflexivity.
-----
Lemma MapCard_makeM2 : forall m m':Map A, MapCard A (makeM2 A m m') = MapCard A m + MapCard A m'.
Proof.
intros.
rewrite (MapCard_ext _ _ (makeM2_M2 A m m')).
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Remove_sum :\n   forall (m m':Map A) (a:ad) (n n':nat),\n     m' = MapRemove A m a ->\n     n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad) (n n' : nat) (_ : eq m' (MapRemove A m a)) (_ : eq n (MapCard A m)) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
+++++
Proof.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (a : ad) (n n' : nat) (_ : eq m' (MapRemove A m a)) (_ : eq n (MapCard A m)) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
+++++
simple induction m.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m' : Map A) (a : ad) (n n' : nat) (_ : eq m' (MapRemove A (M0 A) a)) (_ : eq n (MapCard A (M0 A))) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
+++++
simpl in |- *.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall (m' : Map A) (_ : ad) (n n' : nat) (_ : eq m' (M0 A)) (_ : eq n O) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
+++++
intros.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.

*****
H1 : eq n' (MapCard A m')
H0 : eq n O
H : eq m' (M0 A)
n,n' : nat
a : ad
m,m' : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.

*****
H1 : eq n' (MapCard A (M0 A))
H0 : eq n O
H : eq m' (M0 A)
n,n' : nat
a : ad
m,m' : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
simpl in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.
simpl in H1.

*****
H1 : eq n' O
H0 : eq n O
H : eq m' (M0 A)
n,n' : nat
a : ad
m,m' : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
left.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.
simpl in H1.
left.

*****
H1 : eq n' O
H0 : eq n O
H : eq m' (M0 A)
n,n' : nat
a : ad
m,m' : Map A
A,B : Type
*****
eq n n'
+++++
rewrite H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite H in H1.
simpl in H1.
left.
rewrite H1.

*****
H1 : eq n' O
H0 : eq n O
H : eq m' (M0 A)
n,n' : nat
a : ad
m,m' : Map A
A,B : Type
*****
eq n O
+++++
assumption.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (a1 : ad) (n n' : nat) (_ : eq m' (MapRemove A (M1 A a a0) a1)) (_ : eq n (MapCard A (M1 A a a0))) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
+++++
simpl in |- *.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (a1 : ad) (n n' : nat) (_ : eq m' (if N.eqb a a1 then M0 A else M1 A a a0)) (_ : eq n (S O)) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
+++++
intros.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (S O)
H : eq m' (if N.eqb a a1 then M0 A else M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
H1 : eq n' (MapCard A m')
H0 : eq n (S O)
H : eq m' (if N.eqb a a1 then M0 A else M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) true, sumbool (eq n n') (eq n (S n'))
+++++
intro H2.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.

*****
H2 : eq (N.eqb a a1) true
H1 : eq n' (MapCard A m')
H0 : eq n (S O)
H : eq m' (if N.eqb a a1 then M0 A else M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H2 in H.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.

*****
H2 : eq (N.eqb a a1) true
H1 : eq n' (MapCard A m')
H0 : eq n (S O)
H : eq m' (M0 A)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.
rewrite H in H1.

*****
H2 : eq (N.eqb a a1) true
H1 : eq n' (MapCard A (M0 A))
H0 : eq n (S O)
H : eq m' (M0 A)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
simpl in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.

*****
H2 : eq (N.eqb a a1) true
H1 : eq n' O
H0 : eq n (S O)
H : eq m' (M0 A)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
right.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.
right.

*****
H2 : eq (N.eqb a a1) true
H1 : eq n' O
H0 : eq n (S O)
H : eq m' (M0 A)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq n (S n')
+++++
rewrite H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.
right.
rewrite H1.

*****
H2 : eq (N.eqb a a1) true
H1 : eq n' O
H0 : eq n (S O)
H : eq m' (M0 A)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq n (S O)
+++++
assumption.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
H1 : eq n' (MapCard A m')
H0 : eq n (S O)
H : eq m' (if N.eqb a a1 then M0 A else M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) false, sumbool (eq n n') (eq n (S n'))
+++++
intro H2.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.

*****
H2 : eq (N.eqb a a1) false
H1 : eq n' (MapCard A m')
H0 : eq n (S O)
H : eq m' (if N.eqb a a1 then M0 A else M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H2 in H.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.

*****
H2 : eq (N.eqb a a1) false
H1 : eq n' (MapCard A m')
H0 : eq n (S O)
H : eq m' (M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.
rewrite H in H1.

*****
H2 : eq (N.eqb a a1) false
H1 : eq n' (MapCard A (M1 A a a0))
H0 : eq n (S O)
H : eq m' (M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
simpl in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.

*****
H2 : eq (N.eqb a a1) false
H1 : eq n' (S O)
H0 : eq n (S O)
H : eq m' (M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
left.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.
left.

*****
H2 : eq (N.eqb a a1) false
H1 : eq n' (S O)
H0 : eq n (S O)
H : eq m' (M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq n n'
+++++
rewrite H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H.
rewrite H in H1.
simpl in H1.
left.
rewrite H1.

*****
H2 : eq (N.eqb a a1) false
H1 : eq n' (S O)
H0 : eq n (S O)
H : eq m' (M1 A a a0)
n,n' : nat
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
eq n (S O)
+++++
assumption.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (m' : Map A) (a : ad) (n n' : nat) (_ : eq m' (MapRemove A m a)) (_ : eq n (MapCard A m)) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))) (m0 : Map A) (_ : forall (m' : Map A) (a : ad) (n n' : nat) (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0)) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))) (m' : Map A) (a : ad) (n n' : nat) (_ : eq m' (MapRemove A (M2 A m m0) a)) (_ : eq n (MapCard A (M2 A m m0))) (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
+++++
intros.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (MapRemove A (M2 A m0 m1) a)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
simpl in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (MapRemove A (M2 A m0 m1) a)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
simpl in H.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m'\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m'\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, sumbool (eq n n') (eq n (S n'))
+++++
intro H4.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.

*****
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m'\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H4 in H.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.

*****
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.

*****
H4 : eq (N.odd a) true
H1 : eq n' (MapCard A (makeM2 A m0 (MapRemove A m1 (N.div2 a))))
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.

*****
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).

*****
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A m1) (MapCard A (MapRemove A m1 (N.div2 a))), sumbool (eq n n') (eq n (S n'))
+++++
simpl in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.

*****
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A m1) (MapCard A (MapRemove A m1 (N.div2 a))), sumbool (eq n n') (eq n (S n'))
+++++
intro H5.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.

*****
H5 : eq (MapCard A m1) (MapCard A (MapRemove A m1 (N.div2 a)))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H5 in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.

*****
H5 : eq (MapCard A m1) (MapCard A (MapRemove A m1 (N.div2 a)))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
left.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
left.

*****
H5 : eq (MapCard A m1) (MapCard A (MapRemove A m1 (N.div2 a)))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
eq n n'
+++++
rewrite H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
left.
rewrite H1.

*****
H5 : eq (MapCard A m1) (MapCard A (MapRemove A m1 (N.div2 a)))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
eq n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
+++++
exact H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).

*****
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A m1) (S (MapCard A (MapRemove A m1 (N.div2 a)))), sumbool (eq n n') (eq n (S n'))
+++++
simpl in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.

*****
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A m1) (S (MapCard A (MapRemove A m1 (N.div2 a)))), sumbool (eq n n') (eq n (S n'))
+++++
intro H5.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.

*****
H5 : eq (MapCard A m1) (S (MapCard A (MapRemove A m1 (N.div2 a))))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H5 in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.

*****
H5 : eq (MapCard A m1) (S (MapCard A (MapRemove A m1 (N.div2 a))))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n\n (Init.Nat.add (MapCard A m0)\n (S (MapCard A (MapRemove A m1 (N.div2 a)))))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A (MapRemove A m1 (Ndiv2 a)))) in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A (MapRemove A m1 (Ndiv2 a)))) in H0.

*****
H5 : eq (MapCard A m1) (S (MapCard A (MapRemove A m1 (N.div2 a))))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n\n (Init.Nat.add (S (MapCard A m0))\n (MapCard A (MapRemove A m1 (N.div2 a))))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
right.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A (MapRemove A m1 (Ndiv2 a)))) in H0.
right.

*****
H5 : eq (MapCard A m1) (S (MapCard A (MapRemove A m1 (N.div2 a))))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n\n (Init.Nat.add (S (MapCard A m0))\n (MapCard A (MapRemove A m1 (N.div2 a))))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
eq n (S n')
+++++
rewrite H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
elim (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A (MapRemove A m1 (Ndiv2 a)))) in H0.
right.
rewrite H1.

*****
H5 : eq (MapCard A m1) (S (MapCard A (MapRemove A m1 (N.div2 a))))
H4 : eq (N.odd a) true
H1 : eq n'\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))
H0 : eq n\n (Init.Nat.add (S (MapCard A m0))\n (MapCard A (MapRemove A m1 (N.div2 a))))
H : eq m' (makeM2 A m0 (MapRemove A m1 (N.div2 a)))
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
eq n (S (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a)))))
+++++
exact H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m'\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, sumbool (eq n n') (eq n (S n'))
+++++
intro H4.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.

*****
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m'\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H4 in H.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.

*****
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A m')
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.

*****
H4 : eq (N.odd a) false
H1 : eq n' (MapCard A (makeM2 A (MapRemove A m0 (N.div2 a)) m1))
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.

*****
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).

*****
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A m0) (MapCard A (MapRemove A m0 (N.div2 a))), sumbool (eq n n') (eq n (S n'))
+++++
simpl in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.

*****
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A m0) (MapCard A (MapRemove A m0 (N.div2 a))), sumbool (eq n n') (eq n (S n'))
+++++
intro H5.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.

*****
H5 : eq (MapCard A m0) (MapCard A (MapRemove A m0 (N.div2 a)))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H5 in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.

*****
H5 : eq (MapCard A m0) (MapCard A (MapRemove A m0 (N.div2 a)))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
left.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
left.

*****
H5 : eq (MapCard A m0) (MapCard A (MapRemove A m0 (N.div2 a)))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
eq n n'
+++++
rewrite H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
left.
rewrite H1.

*****
H5 : eq (MapCard A m0) (MapCard A (MapRemove A m0 (N.div2 a)))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
eq n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
+++++
exact H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).

*****
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n (MapCard A (M2 A m0 m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A m0) (S (MapCard A (MapRemove A m0 (N.div2 a)))), sumbool (eq n n') (eq n (S n'))
+++++
simpl in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.

*****
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A m0) (S (MapCard A (MapRemove A m0 (N.div2 a)))), sumbool (eq n n') (eq n (S n'))
+++++
intro H5.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.

*****
H5 : eq (MapCard A m0) (S (MapCard A (MapRemove A m0 (N.div2 a))))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n (Init.Nat.add (MapCard A m0) (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
rewrite H5 in H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.

*****
H5 : eq (MapCard A m0) (S (MapCard A (MapRemove A m0 (N.div2 a))))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n\n (Init.Nat.add (S (MapCard A (MapRemove A m0 (N.div2 a))))\n (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
sumbool (eq n n') (eq n (S n'))
+++++
right.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
right.

*****
H5 : eq (MapCard A m0) (S (MapCard A (MapRemove A m0 (N.div2 a))))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n\n (Init.Nat.add (S (MapCard A (MapRemove A m0 (N.div2 a))))\n (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
eq n (S n')
+++++
rewrite H1.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.
intros.
simpl in H1.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H4.
rewrite H4 in H.
rewrite H in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
elim (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) ( MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a))) (refl_equal _) (refl_equal _) (refl_equal _)).
simpl in H0.
intro H5.
rewrite H5 in H0.
right.
rewrite H1.

*****
H5 : eq (MapCard A m0) (S (MapCard A (MapRemove A m0 (N.div2 a))))
H4 : eq (N.odd a) false
H1 : eq n'\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))
H0 : eq n\n (Init.Nat.add (S (MapCard A (MapRemove A m0 (N.div2 a))))\n (MapCard A m1))
H : eq m' (makeM2 A (MapRemove A m0 (N.div2 a)) m1)
n,n' : nat
a : ad
m' : Map A
X0 : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m1 a)) (_ : eq n (MapCard A m1))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m1 : Map A
X : forall (m' : Map A) (a : ad) (n n' : nat)\n (_ : eq m' (MapRemove A m0 a)) (_ : eq n (MapCard A m0))\n (_ : eq n' (MapCard A m')), sumbool (eq n n') (eq n (S n'))
m,m0 : Map A
A,B : Type
*****
eq n (S (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1)))
+++++
exact H0.
-----
Lemma MapCard_Remove_sum : forall (m m':Map A) (a:ad) (n n':nat), m' = MapRemove A m a -> n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Remove_ub :\n   forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (a : ad), le (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
Proof.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad), le (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
intros.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.
intros.

*****
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A m) (MapCard A (MapRemove A m a)), le (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
intro H.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.

*****
H : eq (MapCard A m) (MapCard A (MapRemove A m a))
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
rewrite H.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.
rewrite H.

*****
H : eq (MapCard A m) (MapCard A (MapRemove A m a))
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapRemove A m a)) (MapCard A (MapRemove A m a))
+++++
apply le_n.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A m) (S (MapCard A (MapRemove A m a))), le (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
intro H.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.

*****
H : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
rewrite H.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.
rewrite H.

*****
H : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapRemove A m a)) (S (MapCard A (MapRemove A m a)))
+++++
apply le_n_Sn.
-----
Lemma MapCard_Remove_ub : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****

*****

+++++
Qed.
-----
Lemma MapCard_Remove_lb :\n   forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (a : ad), ge (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
Proof.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad), ge (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
unfold ge in |- *.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.

*****
A,B : Type
*****
forall (m : Map A) (a : ad), le (MapCard A m) (S (MapCard A (MapRemove A m a)))
+++++
intros.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.

*****
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (S (MapCard A (MapRemove A m a)))
+++++
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A m) (MapCard A (MapRemove A m a)), le (MapCard A m) (S (MapCard A (MapRemove A m a)))
+++++
intro H.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.

*****
H : eq (MapCard A m) (MapCard A (MapRemove A m a))
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (S (MapCard A (MapRemove A m a)))
+++++
rewrite H.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.
rewrite H.

*****
H : eq (MapCard A m) (MapCard A (MapRemove A m a))
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapRemove A m a)) (S (MapCard A (MapRemove A m a)))
+++++
apply le_n_Sn.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A m) (S (MapCard A (MapRemove A m a))), le (MapCard A m) (S (MapCard A (MapRemove A m a)))
+++++
intro H.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.

*****
H : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
a : ad
m : Map A
A,B : Type
*****
le (MapCard A m) (S (MapCard A (MapRemove A m a)))
+++++
rewrite H.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H.
rewrite H.

*****
H : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
a : ad
m : Map A
A,B : Type
*****
le (S (MapCard A (MapRemove A m a))) (S (MapCard A (MapRemove A m a)))
+++++
apply le_n.
-----
Lemma MapCard_Remove_lb : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****

*****

+++++
Qed.
-----
Lemma MapCard_Remove_1 :\n   forall (m:Map A) (a:ad),\n     MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (MapCard A (MapRemove A m a)) (MapCard A m)), eq (MapGet A m a) None
+++++
Proof.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (MapCard A (MapRemove A m a)) (MapCard A m)), eq (MapGet A m a) None
+++++
simple induction m.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (_ : eq (MapCard A (MapRemove A (M0 A) a)) (MapCard A (M0 A))), eq (MapGet A (M0 A) a) None
+++++
trivial.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq (MapCard A (MapRemove A (M1 A a a0) a1)) (MapCard A (M1 A a a0))), eq (MapGet A (M1 A a a0) a1) None
+++++
simpl in |- *.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq (MapCard A (if N.eqb a a1 then M0 A else M1 A a a0)) (S O)), eq (if N.eqb a a1 then Some a0 else None) None
+++++
intros a y a0 H.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
simpl in |- *.
intros a y a0 H.

*****
H : eq (MapCard A (if N.eqb a a0 then M0 A else M1 A a y)) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (if N.eqb a a0 then Some y else None) None
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
simpl in |- *.
intros a y a0 H.
elim (sumbool_of_bool (Neqb a a0)).

*****
H : eq (MapCard A (if N.eqb a a0 then M0 A else M1 A a y)) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb a a0 then Some y else None) None
+++++
intro H0.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
simpl in |- *.
intros a y a0 H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) true
H : eq (MapCard A (if N.eqb a a0 then M0 A else M1 A a y)) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (if N.eqb a a0 then Some y else None) None
+++++
rewrite H0 in H.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
simpl in |- *.
intros a y a0 H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0 in H.

*****
H0 : eq (N.eqb a a0) true
H : eq (MapCard A (M0 A)) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (if N.eqb a a0 then Some y else None) None
+++++
discriminate H.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
simpl in |- *.
intros a y a0 H.
elim (sumbool_of_bool (Neqb a a0)).

*****
H : eq (MapCard A (if N.eqb a a0 then M0 A else M1 A a y)) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb a a0 then Some y else None) None
+++++
intro H0.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
simpl in |- *.
intros a y a0 H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) false
H : eq (MapCard A (if N.eqb a a0 then M0 A else M1 A a y)) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (if N.eqb a a0 then Some y else None) None
+++++
rewrite H0.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
simpl in |- *.
intros a y a0 H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a0) false
H : eq (MapCard A (if N.eqb a a0 then M0 A else M1 A a y)) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (a : ad) (_ : eq (MapCard A (MapRemove A m a)) (MapCard A m)), eq (MapGet A m a) None) (m0 : Map A) (_ : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)), eq (MapGet A m0 a) None) (a : ad) (_ : eq (MapCard A (MapRemove A (M2 A m m0) a)) (MapCard A (M2 A m m0))), eq (MapGet A (M2 A m m0) a) None
+++++
intros.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.

*****
H1 : eq (MapCard A (MapRemove A (M2 A m0 m1) a)) (MapCard A (M2 A m0 m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
simpl in H1.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.

*****
H1 : eq\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, eq (MapGet A (M2 A m0 m1) a) None
+++++
intro H2.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) true
H1 : eq\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite H2 in H1.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.

*****
H2 : eq (N.odd a) true
H1 : eq (MapCard A (makeM2 A m0 (MapRemove A m1 (N.div2 a))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.

*****
H2 : eq (N.odd a) true
H1 : eq\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).

*****
H2 : eq (N.odd a) true
H1 : eq\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A m1 (N.div2 a)) None
+++++
apply H0.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1).
apply H0.

*****
H2 : eq (N.odd a) true
H1 : eq\n (Init.Nat.add (MapCard A m0) (MapCard A (MapRemove A m1 (N.div2 a))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m1 (N.div2 a))) (MapCard A m1)
+++++
exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H1).
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, eq (MapGet A (M2 A m0 m1) a) None
+++++
intro H2.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) false
H1 : eq\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite H2 in H1.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.

*****
H2 : eq (N.odd a) false
H1 : eq (MapCard A (makeM2 A (MapRemove A m0 (N.div2 a)) m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.

*****
H2 : eq (N.odd a) false
H1 : eq\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A (M2 A m0 m1) a) None
+++++
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).

*****
H2 : eq (N.odd a) false
H1 : eq\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapGet A m0 (N.div2 a)) None
+++++
apply H.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply H.

*****
H2 : eq (N.odd a) false
H1 : eq\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m1))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m0)
+++++
rewrite (plus_comm (MapCard A (MapRemove A m0 (Ndiv2 a))) (MapCard A m1)) in H1.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply H.
rewrite (plus_comm (MapCard A (MapRemove A m0 (Ndiv2 a))) (MapCard A m1)) in H1.

*****
H2 : eq (N.odd a) false
H1 : eq (Nat.add (MapCard A m1) (MapCard A (MapRemove A m0 (N.div2 a))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m0)
+++++
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H1.
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.
intros.
simpl in H1.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H1.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply H.
rewrite (plus_comm (MapCard A (MapRemove A m0 (Ndiv2 a))) (MapCard A m1)) in H1.
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H1.

*****
H2 : eq (N.odd a) false
H1 : eq (Nat.add (MapCard A m1) (MapCard A (MapRemove A m0 (N.div2 a))))\n (Nat.add (MapCard A m1) (MapCard A m0))
a : ad
H0 : forall (a : ad) (_ : eq (MapCard A (MapRemove A m1 a)) (MapCard A m1)),\neq (MapGet A m1 a) None
m1 : Map A
H : forall (a : ad) (_ : eq (MapCard A (MapRemove A m0 a)) (MapCard A m0)),\neq (MapGet A m0 a) None
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m0 (N.div2 a))) (MapCard A m0)
+++++
exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H1).
-----
Lemma MapCard_Remove_1 : forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Remove_2 :\n   forall (m:Map A) (a:ad),\n     S (MapCard A (MapRemove A m a)) = MapCard A m ->\n     {y : A | MapGet A m a = Some y}.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (S (MapCard A (MapRemove A m a))) (MapCard A m)), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
Proof.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (S (MapCard A (MapRemove A m a))) (MapCard A m)), sig (fun y : A => eq (MapGet A m a) (Some y))
+++++
simple induction m.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (_ : eq (S (MapCard A (MapRemove A (M0 A) a))) (MapCard A (M0 A))), sig (fun y : A => eq (MapGet A (M0 A) a) (Some y))
+++++
intros.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.

*****
H : eq (S (MapCard A (MapRemove A (M0 A) a))) (MapCard A (M0 A))
a : ad
m : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M0 A) a) (Some y))
+++++
discriminate H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (_ : eq (S (MapCard A (MapRemove A (M1 A a a0) a1))) (MapCard A (M1 A a a0))), sig (fun y : A => eq (MapGet A (M1 A a a0) a1) (Some y))
+++++
intros a y a0 H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.

*****
H : eq (S (MapCard A (MapRemove A (M1 A a y) a0))) (MapCard A (M1 A a y))
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
simpl in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.
simpl in H.

*****
H : eq (S (MapCard A (if N.eqb a a0 then M0 A else M1 A a y))) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).

*****
H : eq (S (MapCard A (if N.eqb a a0 then M0 A else M1 A a y))) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
intro H0.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) true
H : eq (S (MapCard A (if N.eqb a a0 then M0 A else M1 A a y))) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
rewrite (Neqb_complete _ _ H0).
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a a0) true
H : eq (S (MapCard A (if N.eqb a a0 then M0 A else M1 A a y))) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a0 y) a0) (Some y0))
+++++
split with y.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite (Neqb_complete _ _ H0).
split with y.

*****
H0 : eq (N.eqb a a0) true
H : eq (S (MapCard A (if N.eqb a a0 then M0 A else M1 A a y))) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapGet A (M1 A a0 y) a0) (Some y)
+++++
exact (M1_semantics_1 A a0 y).
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).

*****
H : eq (S (MapCard A (if N.eqb a a0 then M0 A else M1 A a y))) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
intro H0.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) false
H : eq (S (MapCard A (if N.eqb a a0 then M0 A else M1 A a y))) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
rewrite H0 in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros a y a0 H.
simpl in H.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0 in H.

*****
H0 : eq (N.eqb a a0) false
H : eq (S (MapCard A (M1 A a y))) (S O)
a0 : ad
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun y0 : A => eq (MapGet A (M1 A a y) a0) (Some y0))
+++++
discriminate H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (a : ad) (_ : eq (S (MapCard A (MapRemove A m a))) (MapCard A m)), sig (fun y : A => eq (MapGet A m a) (Some y))) (m0 : Map A) (_ : forall (a : ad) (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)), sig (fun y : A => eq (MapGet A m0 a) (Some y))) (a : ad) (_ : eq (S (MapCard A (MapRemove A (M2 A m m0) a))) (MapCard A (M2 A m m0))), sig (fun y : A => eq (MapGet A (M2 A m m0) a) (Some y))
+++++
intros.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.

*****
H : eq (S (MapCard A (MapRemove A (M2 A m0 m1) a)))\n (MapCard A (M2 A m0 m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
simpl in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.

*****
H : eq\n (S\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).

*****
H : eq\n (S\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intro H0.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H0.

*****
H0 : eq (N.odd a) true
H : eq\n (S\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite H0 in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H0.
rewrite H0 in H.

*****
H0 : eq (N.odd a) true
H : eq (S (MapCard A (makeM2 A m0 (MapRemove A m1 (N.div2 a)))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H0.
rewrite H0 in H.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H.

*****
H0 : eq (N.odd a) true
H : eq\n (S\n (Init.Nat.add (MapCard A m0)\n (MapCard A (MapRemove A m1 (N.div2 a)))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite (MapGet_M2_bit_0_1 A a H0 m0 m1).
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H0.
rewrite H0 in H.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H.
rewrite (MapGet_M2_bit_0_1 A a H0 m0 m1).

*****
H0 : eq (N.odd a) true
H : eq\n (S\n (Init.Nat.add (MapCard A m0)\n (MapCard A (MapRemove A m1 (N.div2 a)))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m1 (N.div2 a)) (Some y))
+++++
apply X0.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H0.
rewrite H0 in H.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H.
rewrite (MapGet_M2_bit_0_1 A a H0 m0 m1).
apply X0.

*****
H0 : eq (N.odd a) true
H : eq\n (S\n (Init.Nat.add (MapCard A m0)\n (MapCard A (MapRemove A m1 (N.div2 a)))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m1 (N.div2 a)))) (MapCard A m1)
+++++
change (S (MapCard A m0) + MapCard A (MapRemove A m1 (Ndiv2 a)) = MapCard A m0 + MapCard A m1) in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H0.
rewrite H0 in H.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H.
rewrite (MapGet_M2_bit_0_1 A a H0 m0 m1).
apply X0.
change (S (MapCard A m0) + MapCard A (MapRemove A m1 (Ndiv2 a)) = MapCard A m0 + MapCard A m1) in H.

*****
H0 : eq (N.odd a) true
H : eq\n (Init.Nat.add (S (MapCard A m0))\n (MapCard A (MapRemove A m1 (N.div2 a))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m1 (N.div2 a)))) (MapCard A m1)
+++++
rewrite (plus_Snm_nSm (MapCard A m0) (MapCard A (MapRemove A m1 (Ndiv2 a)))) in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H0.
rewrite H0 in H.
rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H.
rewrite (MapGet_M2_bit_0_1 A a H0 m0 m1).
apply X0.
change (S (MapCard A m0) + MapCard A (MapRemove A m1 (Ndiv2 a)) = MapCard A m0 + MapCard A m1) in H.
rewrite (plus_Snm_nSm (MapCard A m0) (MapCard A (MapRemove A m1 (Ndiv2 a)))) in H.

*****
H0 : eq (N.odd a) true
H : eq\n (Init.Nat.add (MapCard A m0)\n (S (MapCard A (MapRemove A m1 (N.div2 a)))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m1 (N.div2 a)))) (MapCard A m1)
+++++
exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H).
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).

*****
H : eq\n (S\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
intro H2.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) false
H : eq\n (S\n (MapCard A\n (if N.odd a\n then makeM2 A m0 (MapRemove A m1 (N.div2 a))\n else makeM2 A (MapRemove A m0 (N.div2 a)) m1)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite H2 in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.

*****
H2 : eq (N.odd a) false
H : eq (S (MapCard A (makeM2 A (MapRemove A m0 (N.div2 a)) m1)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
+++++
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).

*****
H2 : eq (N.odd a) false
H : eq (S (MapCard A (makeM2 A (MapRemove A m0 (N.div2 a)) m1)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
sig (fun y : A => eq (MapGet A m0 (N.div2 a)) (Some y))
+++++
apply X.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply X.

*****
H2 : eq (N.odd a) false
H : eq (S (MapCard A (makeM2 A (MapRemove A m0 (N.div2 a)) m1)))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m0 (N.div2 a)))) (MapCard A m0)
+++++
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply X.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H.

*****
H2 : eq (N.odd a) false
H : eq\n (S\n (Init.Nat.add (MapCard A (MapRemove A m0 (N.div2 a)))\n (MapCard A m1))) (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m0 (N.div2 a)))) (MapCard A m0)
+++++
change (S (MapCard A (MapRemove A m0 (Ndiv2 a))) + MapCard A m1 = MapCard A m0 + MapCard A m1) in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply X.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H.
change (S (MapCard A (MapRemove A m0 (Ndiv2 a))) + MapCard A m1 = MapCard A m0 + MapCard A m1) in H.

*****
H2 : eq (N.odd a) false
H : eq\n (Init.Nat.add (S (MapCard A (MapRemove A m0 (N.div2 a))))\n (MapCard A m1)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m0 (N.div2 a)))) (MapCard A m0)
+++++
rewrite (plus_comm (S (MapCard A (MapRemove A m0 (Ndiv2 a)))) (MapCard A m1)) in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply X.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H.
change (S (MapCard A (MapRemove A m0 (Ndiv2 a))) + MapCard A m1 = MapCard A m0 + MapCard A m1) in H.
rewrite (plus_comm (S (MapCard A (MapRemove A m0 (Ndiv2 a)))) (MapCard A m1)) in H.

*****
H2 : eq (N.odd a) false
H : eq (Nat.add (MapCard A m1) (S (MapCard A (MapRemove A m0 (N.div2 a)))))\n (Init.Nat.add (MapCard A m0) (MapCard A m1))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m0 (N.div2 a)))) (MapCard A m0)
+++++
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.
intros.
simpl in H.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
rewrite H2 in H.
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1).
apply X.
rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H.
change (S (MapCard A (MapRemove A m0 (Ndiv2 a))) + MapCard A m1 = MapCard A m0 + MapCard A m1) in H.
rewrite (plus_comm (S (MapCard A (MapRemove A m0 (Ndiv2 a)))) (MapCard A m1)) in H.
rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.

*****
H2 : eq (N.odd a) false
H : eq (Nat.add (MapCard A m1) (S (MapCard A (MapRemove A m0 (N.div2 a)))))\n (Nat.add (MapCard A m1) (MapCard A m0))
a : ad
X0 : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m1 a))) (MapCard A m1)),\nsig (fun y : A => eq (MapGet A m1 a) (Some y))
m1 : Map A
X : forall (a : ad)\n (_ : eq (S (MapCard A (MapRemove A m0 a))) (MapCard A m0)),\nsig (fun y : A => eq (MapGet A m0 a) (Some y))
m,m0 : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m0 (N.div2 a)))) (MapCard A m0)
+++++
exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H).
-----
Lemma MapCard_Remove_2 : forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) = MapCard A m -> {y : A | MapGet A m a = Some y}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_Remove_1_conv :\n   forall (m:Map A) (a:ad),\n     MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (MapGet A m a) None), eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
Proof.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (_ : eq (MapGet A m a) None), eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
intros.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.

*****
H : eq (MapGet A m a) None
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
H : eq (MapGet A m a) None
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A m) (MapCard A (MapRemove A m a)), eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
intro H0.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.

*****
H0 : eq (MapCard A m) (MapCard A (MapRemove A m a))
H : eq (MapGet A m a) None
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
rewrite H0.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
rewrite H0.

*****
H0 : eq (MapCard A m) (MapCard A (MapRemove A m a))
H : eq (MapGet A m a) None
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) (MapCard A (MapRemove A m a))
+++++
reflexivity.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
H : eq (MapGet A m a) None
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A m) (S (MapCard A (MapRemove A m a))), eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
intro H0.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.

*****
H0 : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
H : eq (MapGet A m a) None
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
elim (MapCard_Remove_2 m a (sym_eq H0)).
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
elim (MapCard_Remove_2 m a (sym_eq H0)).

*****
H0 : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
H : eq (MapGet A m a) None
a : ad
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
intros y H1.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
elim (MapCard_Remove_2 m a (sym_eq H0)).
intros y H1.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
H : eq (MapGet A m a) None
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
rewrite H1 in H.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
elim (MapCard_Remove_2 m a (sym_eq H0)).
intros y H1.
rewrite H1 in H.

*****
H1 : eq (MapGet A m a) (Some y)
H0 : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
H : eq (Some y) None
y : A
a : ad
m : Map A
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) (MapCard A m)
+++++
discriminate H.
-----
Lemma MapCard_Remove_1_conv : forall (m:Map A) (a:ad), MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****

*****

+++++
Qed.
-----
Lemma MapCard_Remove_2_conv :\n   forall (m:Map A) (a:ad) (y:A),\n     MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
Proof.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
intros.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.
intros.

*****
H : eq (MapGet A m a) (Some y)
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
H : eq (MapGet A m a) (Some y)
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A m) (MapCard A (MapRemove A m a)), eq (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
intro H0.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.

*****
H0 : eq (MapCard A m) (MapCard A (MapRemove A m a))
H : eq (MapGet A m a) (Some y)
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
rewrite (MapCard_Remove_1 m a (sym_eq H0)) in H.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
rewrite (MapCard_Remove_1 m a (sym_eq H0)) in H.

*****
H0 : eq (MapCard A m) (MapCard A (MapRemove A m a))
H : eq None (Some y)
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
discriminate H.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****
H : eq (MapGet A m a) (Some y)
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapCard A m) (S (MapCard A (MapRemove A m a))), eq (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
intro H0.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.

*****
H0 : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
H : eq (MapGet A m a) (Some y)
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m a))) (MapCard A m)
+++++
rewrite H0.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).
intro H0.
rewrite H0.

*****
H0 : eq (MapCard A m) (S (MapCard A (MapRemove A m a)))
H : eq (MapGet A m a) (Some y)
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A (MapRemove A m a))) (S (MapCard A (MapRemove A m a)))
+++++
reflexivity.
-----
Lemma MapCard_Remove_2_conv : forall (m:Map A) (a:ad) (y:A), MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.
Proof.
intros.
elim (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m) (MapCard A (MapRemove A m a)) (refl_equal _) ( refl_equal _) (refl_equal _)).

*****

*****

+++++
Qed.
-----
Lemma MapMerge_Restr_Card :\n   forall m m':Map A,\n     MapCard A m + MapCard A m' =\n     MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').

*****
A,B : Type
*****
forall m m' : Map A, eq (Init.Nat.add (MapCard A m) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m')))
+++++
Proof.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.

*****
A,B : Type
*****
forall m m' : Map A, eq (Init.Nat.add (MapCard A m) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m')))
+++++
simple induction m.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall m' : Map A, eq (Init.Nat.add (MapCard A (M0 A)) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A (M0 A) m')) (MapCard A (MapDomRestrTo A A (M0 A) m')))
+++++
simpl in |- *.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall m' : Map A, eq (MapCard A m') (Init.Nat.add (MapCard A m') O)
+++++
intro.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intro.

*****
m,m' : Map A
A,B : Type
*****
eq (MapCard A m') (Init.Nat.add (MapCard A m') O)
+++++
apply plus_n_O.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map A), eq (Init.Nat.add (MapCard A (M1 A a a0)) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A (M1 A a a0) m')) (MapCard A (MapDomRestrTo A A (M1 A a a0) m')))
+++++
simpl in |- *.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map A), eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a a0)) (MapCard A match MapGet A m' a with | Some _ => M1 A a a0 | None => M0 A end))
+++++
intros a y m'.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.

*****
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A match MapGet A m' a with | Some _ => M1 A a y | None => M0 A end))
+++++
elim (option_sum A (MapGet A m' a)).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).

*****
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A m' a) (Some y)), eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A match MapGet A m' a with | Some _ => M1 A a y | None => M0 A end))
+++++
intro H.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.

*****
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A match MapGet A m' a with | Some _ => M1 A a y | None => M0 A end))
+++++
elim H.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.

*****
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m' a) (Some x)), eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A match MapGet A m' a with | Some _ => M1 A a y | None => M0 A end))
+++++
intros y0 H0.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y0 H0.

*****
H0 : eq (MapGet A m' a) (Some y0)
y0 : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A match MapGet A m' a with | Some _ => M1 A a y | None => M0 A end))
+++++
rewrite H0.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.

*****
H0 : eq (MapGet A m' a) (Some y0)
y0 : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A (M1 A a y)))
+++++
rewrite MapCard_Put_behind_Put.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
rewrite MapCard_Put_behind_Put.

*****
H0 : eq (MapGet A m' a) (Some y0)
y0 : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut A m' a y)) (MapCard A (M1 A a y)))
+++++
rewrite (MapCard_Put_1_conv m' a y0 y H0).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
rewrite MapCard_Put_behind_Put.
rewrite (MapCard_Put_1_conv m' a y0 y H0).

*****
H0 : eq (MapGet A m' a) (Some y0)
y0 : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A m') (MapCard A (M1 A a y)))
+++++
simpl in |- *.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
rewrite MapCard_Put_behind_Put.
rewrite (MapCard_Put_1_conv m' a y0 y H0).
simpl in |- *.

*****
H0 : eq (MapGet A m' a) (Some y0)
y0 : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A m') (S O))
+++++
rewrite <- plus_Snm_nSm.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
rewrite MapCard_Put_behind_Put.
rewrite (MapCard_Put_1_conv m' a y0 y H0).
simpl in |- *.
rewrite <- plus_Snm_nSm.

*****
H0 : eq (MapGet A m' a) (Some y0)
y0 : A
H : sig (fun y : A => eq (MapGet A m' a) (Some y))
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (S (MapCard A m')) O)
+++++
apply plus_n_O.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).

*****
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapGet A m' a) None, eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A match MapGet A m' a with | Some _ => M1 A a y | None => M0 A end))
+++++
intro H.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.

*****
H : eq (MapGet A m' a) None
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A match MapGet A m' a with | Some _ => M1 A a y | None => M0 A end))
+++++
rewrite H.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
rewrite H.

*****
H : eq (MapGet A m' a) None
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut_behind A m' a y)) (MapCard A (M0 A)))
+++++
rewrite MapCard_Put_behind_Put.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
rewrite H.
rewrite MapCard_Put_behind_Put.

*****
H : eq (MapGet A m' a) None
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (MapCard A (MapPut A m' a y)) (MapCard A (M0 A)))
+++++
rewrite (MapCard_Put_2_conv m' a y H).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
simpl in |- *.
intros a y m'.
elim (option_sum A (MapGet A m' a)).
intro H.
rewrite H.
rewrite MapCard_Put_behind_Put.
rewrite (MapCard_Put_2_conv m' a y H).

*****
H : eq (MapGet A m' a) None
m' : Map A
y : A
a : ad
m : Map A
A,B : Type
*****
eq (S (MapCard A m')) (Init.Nat.add (S (MapCard A m')) (MapCard A (M0 A)))
+++++
apply plus_n_O.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall m' : Map A, eq (Init.Nat.add (MapCard A m) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m')))) (m0 : Map A) (_ : forall m' : Map A, eq (Init.Nat.add (MapCard A m0) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A m0 m')) (MapCard A (MapDomRestrTo A A m0 m')))) (m' : Map A), eq (Init.Nat.add (MapCard A (M2 A m m0)) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A (M2 A m m0) m')) (MapCard A (MapDomRestrTo A A (M2 A m m0) m')))
+++++
intros.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.

*****
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m')) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')))
+++++
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.

*****
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A m')) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m')) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')))
+++++
elim m'.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.

*****
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M0 A))) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) (M0 A))) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) (M0 A))))
+++++
reflexivity.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.

*****
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
forall (a : ad) (a0 : A), eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a a0))) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) (M1 A a a0))) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) (M1 A a a0))))
+++++
intros a y.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.

*****
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) (M1 A a y))) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) (M1 A a y))))
+++++
unfold MapMerge in |- *.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.

*****
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) (M1 A a y))))
+++++
unfold MapDomRestrTo in |- *.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.

*****
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end))
+++++
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).

*****
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
forall _ : sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y)), eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end))
+++++
intro H1.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.

*****
H1 : sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end))
+++++
elim H1.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.
elim H1.

*****
H1 : sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some x)), eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end))
+++++
intros y0 H2.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.
elim H1.
intros y0 H2.

*****
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end))
+++++
rewrite H2.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.
elim H1.
intros y0 H2.
rewrite H2.

*****
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A (M1 A a y0)))
+++++
rewrite (MapCard_Put_1_conv (M2 A m0 m1) a y0 y H2).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.
elim H1.
intros y0 H2.
rewrite H2.
rewrite (MapCard_Put_1_conv (M2 A m0 m1) a y0 y H2).

*****
H2 : eq (MapGet A (M2 A m0 m1) a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (MapGet A (M2 A m0 m1) a) (Some y))
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M1 A a y0)))
+++++
reflexivity.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).

*****
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapGet A (M2 A m0 m1) a) None, eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end))
+++++
intro H1.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.

*****
H1 : eq (MapGet A (M2 A m0 m1) a) None
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end))
+++++
rewrite H1.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.
rewrite H1.

*****
H1 : eq (MapGet A (M2 A m0 m1) a) None
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (MapCard A (MapPut A (M2 A m0 m1) a y)) (MapCard A (M0 A)))
+++++
rewrite (MapCard_Put_2_conv (M2 A m0 m1) a y H1).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.
rewrite H1.
rewrite (MapCard_Put_2_conv (M2 A m0 m1) a y H1).

*****
H1 : eq (MapGet A (M2 A m0 m1) a) None
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M1 A a y))) (Init.Nat.add (S (MapCard A (M2 A m0 m1))) (MapCard A (M0 A)))
+++++
simpl in |- *.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.
rewrite H1.
rewrite (MapCard_Put_2_conv (M2 A m0 m1) a y H1).
simpl in |- *.

*****
H1 : eq (MapGet A (M2 A m0 m1) a) None
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S O)) (S (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) O))
+++++
rewrite <- (plus_Snm_nSm (MapCard A m0 + MapCard A m1) 0).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros a y.
unfold MapMerge in |- *.
unfold MapDomRestrTo in |- *.
elim (option_sum A (MapGet A (M2 A m0 m1) a)).
intro H1.
rewrite H1.
rewrite (MapCard_Put_2_conv (M2 A m0 m1) a y H1).
simpl in |- *.
rewrite <- (plus_Snm_nSm (MapCard A m0 + MapCard A m1) 0).

*****
H1 : eq (MapGet A (M2 A m0 m1) a) None
y : A
a : ad
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (S (Init.Nat.add (MapCard A m0) (MapCard A m1))) O) (S (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) O))
+++++
reflexivity.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.

*****
m' : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
forall (m : Map A) (_ : eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A m)) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m)) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m)))) (m2 : Map A) (_ : eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A m2)) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m2)) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m2)))), eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M2 A m m2))) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m m2))) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) (M2 A m m2))))
+++++
intros.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros.

*****
H2 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m3))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m3)))
m3 : Map A
H1 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m2))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m2)))
m',m2 : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (MapCard A (M2 A m2 m3))) (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3))) (MapCard A (MapDomRestrTo A A (M2 A m0 m1) (M2 A m2 m3))))
+++++
simpl in |- *.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros.
simpl in |- *.

*****
H2 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m3))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m3)))
m3 : Map A
H1 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m2))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m2)))
m',m2 : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A m2) (MapCard A m3))) (Init.Nat.add (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapMerge A m1 m3))) (MapCard A (makeM2 A (MapDomRestrTo A A m0 m2) (MapDomRestrTo A A m1 m3))))
+++++
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m1) ( MapCard A m2) (MapCard A m3)).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros.
simpl in |- *.
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m1) ( MapCard A m2) (MapCard A m3)).

*****
H2 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m3))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m3)))
m3 : Map A
H1 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m2))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m2)))
m',m2 : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Nat.add (Nat.add (MapCard A m0) (MapCard A m2)) (Nat.add (MapCard A m1) (MapCard A m3))) (Init.Nat.add (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapMerge A m1 m3))) (MapCard A (makeM2 A (MapDomRestrTo A A m0 m2) (MapDomRestrTo A A m1 m3))))
+++++
rewrite (H m2).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros.
simpl in |- *.
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m1) ( MapCard A m2) (MapCard A m3)).
rewrite (H m2).

*****
H2 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m3))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m3)))
m3 : Map A
H1 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m2))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m2)))
m',m2 : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Nat.add (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapDomRestrTo A A m0 m2))) (Nat.add (MapCard A m1) (MapCard A m3))) (Init.Nat.add (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapMerge A m1 m3))) (MapCard A (makeM2 A (MapDomRestrTo A A m0 m2) (MapDomRestrTo A A m1 m3))))
+++++
rewrite (H0 m3).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros.
simpl in |- *.
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m1) ( MapCard A m2) (MapCard A m3)).
rewrite (H m2).
rewrite (H0 m3).

*****
H2 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m3))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m3)))
m3 : Map A
H1 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m2))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m2)))
m',m2 : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Nat.add (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapDomRestrTo A A m0 m2))) (Init.Nat.add (MapCard A (MapMerge A m1 m3)) (MapCard A (MapDomRestrTo A A m1 m3)))) (Init.Nat.add (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapMerge A m1 m3))) (MapCard A (makeM2 A (MapDomRestrTo A A m0 m2) (MapDomRestrTo A A m1 m3))))
+++++
rewrite (MapCard_makeM2 (MapDomRestrTo A A m0 m2) (MapDomRestrTo A A m1 m3)).
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.
intros.
change (MapCard A m0 + MapCard A m1 + MapCard A m' = MapCard A (MapMerge A (M2 A m0 m1) m') + MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) in |- *.
elim m'.
intros.
simpl in |- *.
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m1) ( MapCard A m2) (MapCard A m3)).
rewrite (H m2).
rewrite (H0 m3).
rewrite (MapCard_makeM2 (MapDomRestrTo A A m0 m2) (MapDomRestrTo A A m1 m3)).

*****
H2 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m3))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m3)))
m3 : Map A
H1 : eq\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (MapCard A m2))\n (Init.Nat.add (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (MapCard A (MapDomRestrTo A A (M2 A m0 m1) m2)))
m',m2 : Map A
H0 : forall m' : Map A,\neq (Init.Nat.add (MapCard A m1) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m1 m'))\n (MapCard A (MapDomRestrTo A A m1 m')))
m1 : Map A
H : forall m' : Map A,\neq (Init.Nat.add (MapCard A m0) (MapCard A m'))\n (Init.Nat.add (MapCard A (MapMerge A m0 m'))\n (MapCard A (MapDomRestrTo A A m0 m')))
m,m0 : Map A
A,B : Type
*****
eq (Nat.add (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapDomRestrTo A A m0 m2))) (Init.Nat.add (MapCard A (MapMerge A m1 m3)) (MapCard A (MapDomRestrTo A A m1 m3)))) (Init.Nat.add (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapMerge A m1 m3))) (Init.Nat.add (MapCard A (MapDomRestrTo A A m0 m2)) (MapCard A (MapDomRestrTo A A m1 m3))))
+++++
apply plus_permute_2_in_4.
-----
Lemma MapMerge_Restr_Card : forall m m':Map A, MapCard A m + MapCard A m' = MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapMerge_disjoint_Card :\n   forall m m':Map A,\n     MapDisjoint A A m m' ->\n     MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.
-----
Lemma MapMerge_disjoint_Card : forall m m':Map A, MapDisjoint A A m m' -> MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : MapDisjoint A A m m'), eq (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
Proof.
-----
Lemma MapMerge_disjoint_Card : forall m m':Map A, MapDisjoint A A m m' -> MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : MapDisjoint A A m m'), eq (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
intros.
-----
Lemma MapMerge_disjoint_Card : forall m m':Map A, MapDisjoint A A m m' -> MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.
Proof.
intros.

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eq (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
rewrite (MapMerge_Restr_Card m m').
-----
Lemma MapMerge_disjoint_Card : forall m m':Map A, MapDisjoint A A m m' -> MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.
Proof.
intros.
rewrite (MapMerge_Restr_Card m m').

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eq (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m')))
+++++
rewrite (MapCard_ext _ _ (MapDisjoint_imp_2 _ _ _ _ H)).
-----
Lemma MapMerge_disjoint_Card : forall m m':Map A, MapDisjoint A A m m' -> MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.
Proof.
intros.
rewrite (MapMerge_Restr_Card m m').
rewrite (MapCard_ext _ _ (MapDisjoint_imp_2 _ _ _ _ H)).

*****
H : MapDisjoint A A m m'
m,m' : Map A
A,B : Type
*****
eq (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A (MapMerge A m m')) (MapCard A (M0 A)))
+++++
apply plus_n_O.
-----
Lemma MapMerge_disjoint_Card : forall m m':Map A, MapDisjoint A A m m' -> MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.
Proof.
intros.
rewrite (MapMerge_Restr_Card m m').
rewrite (MapCard_ext _ _ (MapDisjoint_imp_2 _ _ _ _ H)).
apply plus_n_O.

*****

*****

+++++
Qed.
-----
Lemma MapSplit_Card :\n   forall (m:Map A) (m':Map B),\n     MapCard A m =\n     MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').
-----
Lemma MapSplit_Card : forall (m:Map A) (m':Map B), MapCard A m = MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), eq (MapCard A m) (Init.Nat.add (MapCard A (MapDomRestrTo A B m m')) (MapCard A (MapDomRestrBy A B m m')))
+++++
Proof.
-----
Lemma MapSplit_Card : forall (m:Map A) (m':Map B), MapCard A m = MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), eq (MapCard A m) (Init.Nat.add (MapCard A (MapDomRestrTo A B m m')) (MapCard A (MapDomRestrBy A B m m')))
+++++
intros.
-----
Lemma MapSplit_Card : forall (m:Map A) (m':Map B), MapCard A m = MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').
Proof.
intros.

*****
m' : Map B
m : Map A
A,B : Type
*****
eq (MapCard A m) (Init.Nat.add (MapCard A (MapDomRestrTo A B m m')) (MapCard A (MapDomRestrBy A B m m')))
+++++
rewrite (MapCard_ext _ _ (MapDom_Split_1 A B m m')).
-----
Lemma MapSplit_Card : forall (m:Map A) (m':Map B), MapCard A m = MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').
Proof.
intros.
rewrite (MapCard_ext _ _ (MapDom_Split_1 A B m m')).

*****
m' : Map B
m : Map A
A,B : Type
*****
eq (MapCard A (MapMerge A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m'))) (Init.Nat.add (MapCard A (MapDomRestrTo A B m m')) (MapCard A (MapDomRestrBy A B m m')))
+++++
apply MapMerge_disjoint_Card.
-----
Lemma MapSplit_Card : forall (m:Map A) (m':Map B), MapCard A m = MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').
Proof.
intros.
rewrite (MapCard_ext _ _ (MapDom_Split_1 A B m m')).
apply MapMerge_disjoint_Card.

*****
m' : Map B
m : Map A
A,B : Type
*****
MapDisjoint A A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m')
+++++
apply MapDisjoint_2_imp.
-----
Lemma MapSplit_Card : forall (m:Map A) (m':Map B), MapCard A m = MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').
Proof.
intros.
rewrite (MapCard_ext _ _ (MapDom_Split_1 A B m m')).
apply MapMerge_disjoint_Card.
apply MapDisjoint_2_imp.

*****
m' : Map B
m : Map A
A,B : Type
*****
MapDisjoint_2 A A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m')
+++++
unfold MapDisjoint_2 in |- *.
-----
Lemma MapSplit_Card : forall (m:Map A) (m':Map B), MapCard A m = MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').
Proof.
intros.
rewrite (MapCard_ext _ _ (MapDom_Split_1 A B m m')).
apply MapMerge_disjoint_Card.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.

*****
m' : Map B
m : Map A
A,B : Type
*****
eqmap A (MapDomRestrTo A A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m')) (M0 A)
+++++
apply MapDom_Split_3.
-----
Lemma MapSplit_Card : forall (m:Map A) (m':Map B), MapCard A m = MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').
Proof.
intros.
rewrite (MapCard_ext _ _ (MapDom_Split_1 A B m m')).
apply MapMerge_disjoint_Card.
apply MapDisjoint_2_imp.
unfold MapDisjoint_2 in |- *.
apply MapDom_Split_3.

*****

*****

+++++
Qed.
-----
Lemma MapMerge_Card_ub :\n   forall m m':Map A,\n     MapCard A (MapMerge A m m') <= MapCard A m + MapCard A m'.
-----
Lemma MapMerge_Card_ub : forall m m':Map A, MapCard A (MapMerge A m m') <= MapCard A m + MapCard A m'.

*****
A,B : Type
*****
forall m m' : Map A, le (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
Proof.
-----
Lemma MapMerge_Card_ub : forall m m':Map A, MapCard A (MapMerge A m m') <= MapCard A m + MapCard A m'.
Proof.

*****
A,B : Type
*****
forall m m' : Map A, le (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
intros.
-----
Lemma MapMerge_Card_ub : forall m m':Map A, MapCard A (MapMerge A m m') <= MapCard A m + MapCard A m'.
Proof.
intros.

*****
m,m' : Map A
A,B : Type
*****
le (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))
+++++
rewrite MapMerge_Restr_Card.
-----
Lemma MapMerge_Card_ub : forall m m':Map A, MapCard A (MapMerge A m m') <= MapCard A m + MapCard A m'.
Proof.
intros.
rewrite MapMerge_Restr_Card.

*****
m,m' : Map A
A,B : Type
*****
le (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m')))
+++++
apply le_plus_l.
-----
Lemma MapMerge_Card_ub : forall m m':Map A, MapCard A (MapMerge A m m') <= MapCard A m + MapCard A m'.
Proof.
intros.
rewrite MapMerge_Restr_Card.
apply le_plus_l.

*****

*****

+++++
Qed.
-----
Lemma MapDomRestrTo_Card_ub_l :\n   forall (m:Map A) (m':Map B),\n     MapCard A (MapDomRestrTo A B m m') <= MapCard A m.
-----
Lemma MapDomRestrTo_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), le (MapCard A (MapDomRestrTo A B m m')) (MapCard A m)
+++++
Proof.
-----
Lemma MapDomRestrTo_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), le (MapCard A (MapDomRestrTo A B m m')) (MapCard A m)
+++++
intros.
-----
Lemma MapDomRestrTo_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard A m.
Proof.
intros.

*****
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B m m')) (MapCard A m)
+++++
rewrite (MapSplit_Card m m').
-----
Lemma MapDomRestrTo_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard A m.
Proof.
intros.
rewrite (MapSplit_Card m m').

*****
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B m m')) (Init.Nat.add (MapCard A (MapDomRestrTo A B m m')) (MapCard A (MapDomRestrBy A B m m')))
+++++
apply le_plus_l.
-----
Lemma MapDomRestrTo_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard A m.
Proof.
intros.
rewrite (MapSplit_Card m m').
apply le_plus_l.

*****

*****

+++++
Qed.
-----
Lemma MapDomRestrBy_Card_ub_l :\n   forall (m:Map A) (m':Map B),\n     MapCard A (MapDomRestrBy A B m m') <= MapCard A m.
-----
Lemma MapDomRestrBy_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrBy A B m m') <= MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), le (MapCard A (MapDomRestrBy A B m m')) (MapCard A m)
+++++
Proof.
-----
Lemma MapDomRestrBy_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrBy A B m m') <= MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), le (MapCard A (MapDomRestrBy A B m m')) (MapCard A m)
+++++
intros.
-----
Lemma MapDomRestrBy_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrBy A B m m') <= MapCard A m.
Proof.
intros.

*****
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrBy A B m m')) (MapCard A m)
+++++
rewrite (MapSplit_Card m m').
-----
Lemma MapDomRestrBy_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrBy A B m m') <= MapCard A m.
Proof.
intros.
rewrite (MapSplit_Card m m').

*****
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrBy A B m m')) (Init.Nat.add (MapCard A (MapDomRestrTo A B m m')) (MapCard A (MapDomRestrBy A B m m')))
+++++
apply le_plus_r.
-----
Lemma MapDomRestrBy_Card_ub_l : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrBy A B m m') <= MapCard A m.
Proof.
intros.
rewrite (MapSplit_Card m m').
apply le_plus_r.

*****

*****

+++++
Qed.
-----
Lemma MapMerge_Card_disjoint :\n   forall m m':Map A,\n     MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' ->\n     MapDisjoint A A m m'.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : eq (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))), MapDisjoint A A m m'
+++++
Proof.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.

*****
A,B : Type
*****
forall (m m' : Map A) (_ : eq (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))), MapDisjoint A A m m'
+++++
simple induction m.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m' : Map A) (_ : eq (MapCard A (MapMerge A (M0 A) m')) (Init.Nat.add (MapCard A (M0 A)) (MapCard A m'))), MapDisjoint A A (M0 A) m'
+++++
intros.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
intros.

*****
H : eq (MapCard A (MapMerge A (M0 A) m'))\n (Init.Nat.add (MapCard A (M0 A)) (MapCard A m'))
m,m' : Map A
A,B : Type
*****
MapDisjoint A A (M0 A) m'
+++++
apply Map_M0_disjoint.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (_ : eq (MapCard A (MapMerge A (M1 A a a0) m')) (Init.Nat.add (MapCard A (M1 A a a0)) (MapCard A m'))), MapDisjoint A A (M1 A a a0) m'
+++++
simpl in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map A) (_ : eq (MapCard A (MapPut_behind A m' a a0)) (S (MapCard A m'))), MapDisjoint A A (M1 A a a0) m'
+++++
intros.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.

*****
H : eq (MapCard A (MapPut_behind A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
MapDisjoint A A (M1 A a a0) m'
+++++
rewrite (MapCard_Put_behind_Put m' a a0) in H.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.

*****
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
MapDisjoint A A (M1 A a a0) m'
+++++
unfold MapDisjoint.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.

*****
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall (a1 : ad) (_ : eq (in_dom A a1 (M1 A a a0)) true) (_ : eq (in_dom A a1 m') true), False
+++++
unfold in_dom in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.

*****
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall (a1 : ad) (_ : eq match MapGet A (M1 A a a0) a1 with | Some _ => true | None => false end true) (_ : eq match MapGet A m' a1 with | Some _ => true | None => false end true), False
+++++
simpl in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.

*****
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall (a1 : ad) (_ : eq match (if N.eqb a a1 then Some a0 else None) with | Some _ => true | None => false end true) (_ : eq match MapGet A m' a1 with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.
intros.

*****
H1 : eq match MapGet A m' a1 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a1 then Some a0 else None) with\n | Some _ => true\n | None => false\n end true
a1 : ad
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
False
+++++
elim (sumbool_of_bool (Neqb a a1)).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
H1 : eq match MapGet A m' a1 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a1 then Some a0 else None) with\n | Some _ => true\n | None => false\n end true
a1 : ad
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) true, False
+++++
intro H2.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.

*****
H2 : eq (N.eqb a a1) true
H1 : eq match MapGet A m' a1 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a1 then Some a0 else None) with\n | Some _ => true\n | None => false\n end true
a1 : ad
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
False
+++++
rewrite (Neqb_complete _ _ H2) in H.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H.

*****
H2 : eq (N.eqb a a1) true
H1 : eq match MapGet A m' a1 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a1 then Some a0 else None) with\n | Some _ => true\n | None => false\n end true
H : eq (MapCard A (MapPut A m' a1 a0)) (S (MapCard A m'))
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
False
+++++
rewrite (MapCard_Put_2 m' a1 a0 H) in H1.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H.
rewrite (MapCard_Put_2 m' a1 a0 H) in H1.

*****
H2 : eq (N.eqb a a1) true
H1 : eq false true
H0 : eq\n match (if N.eqb a a1 then Some a0 else None) with\n | Some _ => true\n | None => false\n end true
H : eq (MapCard A (MapPut A m' a1 a0)) (S (MapCard A m'))
a1 : ad
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
False
+++++
discriminate H1.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).

*****
H1 : eq match MapGet A m' a1 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a1 then Some a0 else None) with\n | Some _ => true\n | None => false\n end true
a1 : ad
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a1) false, False
+++++
intro H2.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.

*****
H2 : eq (N.eqb a a1) false
H1 : eq match MapGet A m' a1 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a1 then Some a0 else None) with\n | Some _ => true\n | None => false\n end true
a1 : ad
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
False
+++++
rewrite H2 in H0.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simpl in |- *.
intros.
rewrite (MapCard_Put_behind_Put m' a a0) in H.
unfold MapDisjoint.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a1)).
intro H2.
rewrite H2 in H0.

*****
H2 : eq (N.eqb a a1) false
H1 : eq match MapGet A m' a1 with\n | Some _ => true\n | None => false\n end true
H0 : eq false true
a1 : ad
H : eq (MapCard A (MapPut A m' a a0)) (S (MapCard A m'))
m' : Map A
a0 : A
a : ad
m : Map A
A,B : Type
*****
False
+++++
discriminate H0.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (m' : Map A) (_ : eq (MapCard A (MapMerge A m m')) (Init.Nat.add (MapCard A m) (MapCard A m'))), MapDisjoint A A m m') (m0 : Map A) (_ : forall (m' : Map A) (_ : eq (MapCard A (MapMerge A m0 m')) (Init.Nat.add (MapCard A m0) (MapCard A m'))), MapDisjoint A A m0 m') (m' : Map A) (_ : eq (MapCard A (MapMerge A (M2 A m m0) m')) (Init.Nat.add (MapCard A (M2 A m m0)) (MapCard A m'))), MapDisjoint A A (M2 A m m0) m'
+++++
simple induction m'.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall _ : eq (MapCard A (MapMerge A (M2 A m0 m1) (M0 A))) (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M0 A))), MapDisjoint A A (M2 A m0 m1) (M0 A)
+++++
intros.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H1 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M0 A)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M0 A)))
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
MapDisjoint A A (M2 A m0 m1) (M0 A)
+++++
apply Map_disjoint_M0.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (_ : eq (MapCard A (MapMerge A (M2 A m0 m1) (M1 A a a0))) (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M1 A a a0)))), MapDisjoint A A (M2 A m0 m1) (M1 A a a0)
+++++
intros a y H1.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.

*****
H1 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M1 A a y)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M1 A a y)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
MapDisjoint A A (M2 A m0 m1) (M1 A a y)
+++++
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M1 A a y)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
MapDisjoint A A (M2 A m0 m1) (M1 A a y)
+++++
unfold MapCard at 3 in H1.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (S O))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
MapDisjoint A A (M2 A m0 m1) (M1 A a y)
+++++
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y))\n (Init.Nat.add (S (MapCard A (M2 A m0 m1))) O)
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
MapDisjoint A A (M2 A m0 m1) (M1 A a y)
+++++
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
MapDisjoint A A (M2 A m0 m1) (M1 A a y)
+++++
unfold MapDisjoint.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall (a0 : ad) (_ : eq (in_dom A a0 (M2 A m0 m1)) true) (_ : eq (in_dom A a0 (M1 A a y)) true), False
+++++
unfold in_dom in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall (a0 : ad) (_ : eq match MapGet A (M2 A m0 m1) a0 with | Some _ => true | None => false end true) (_ : eq match MapGet A (M1 A a y) a0 with | Some _ => true | None => false end true), False
+++++
unfold MapGet at 2 in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.

*****
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall (a0 : ad) (_ : eq match MapGet A (M2 A m0 m1) a0 with | Some _ => true | None => false end true) (_ : eq match (if N.eqb a a0 then Some y else None) with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.
intros.

*****
H3 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H2 : eq\n match MapGet A (M2 A m0 m1) a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
H3 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H2 : eq\n match MapGet A (M2 A m0 m1) a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, False
+++++
intro H4.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H4.

*****
H4 : eq (N.eqb a a0) true
H3 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H2 : eq\n match MapGet A (M2 A m0 m1) a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
rewrite <- (Neqb_complete _ _ H4) in H2.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H4.
rewrite <- (Neqb_complete _ _ H4) in H2.

*****
H4 : eq (N.eqb a a0) true
H3 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H2 : eq\n match MapGet A (M2 A m0 m1) a with\n | Some _ => true\n | None => false\n end true
a0 : ad
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
rewrite (MapCard_Put_2 _ _ _ H1) in H2.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H4.
rewrite <- (Neqb_complete _ _ H4) in H2.
rewrite (MapCard_Put_2 _ _ _ H1) in H2.

*****
H4 : eq (N.eqb a a0) true
H3 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H2 : eq false true
a0 : ad
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
discriminate H2.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
H3 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H2 : eq\n match MapGet A (M2 A m0 m1) a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, False
+++++
intro H4.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H4.

*****
H4 : eq (N.eqb a a0) false
H3 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H2 : eq\n match MapGet A (M2 A m0 m1) a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
rewrite H4 in H3.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros a y H1.
rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.
unfold MapCard at 3 in H1.
rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.
rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1.
unfold MapDisjoint.
unfold in_dom in |- *.
unfold MapGet at 2 in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H4.
rewrite H4 in H3.

*****
H4 : eq (N.eqb a a0) false
H3 : eq false true
H2 : eq\n match MapGet A (M2 A m0 m1) a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H1 : eq (MapCard A (MapPut A (M2 A m0 m1) a y)) (S (MapCard A (M2 A m0 m1)))
y : A
a : ad
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
discriminate H3.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m)) (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m)), MapDisjoint A A (M2 A m0 m1) m) (m2 : Map A) (_ : forall _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2)) (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)), MapDisjoint A A (M2 A m0 m1) m2) (_ : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m m2))) (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m m2)))), MapDisjoint A A (M2 A m0 m1) (M2 A m m2)
+++++
intros.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
MapDisjoint A A (M2 A m0 m1) (M2 A m2 m3)
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.

*****
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall (a : ad) (_ : eq (in_dom A a (M2 A m0 m1)) true) (_ : eq (in_dom A a (M2 A m2 m3)) true), False
+++++
intros.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.

*****
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) true, False
+++++
intro H6.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
unfold MapDisjoint in H0.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
apply H0 with (m' := m3) (a := Ndiv2 a).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapMerge A m1 m3)) (Init.Nat.add (MapCard A m1) (MapCard A m3))
+++++
apply le_antisym.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
apply le_antisym.

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapMerge A m1 m3)) (Init.Nat.add (MapCard A m1) (MapCard A m3))
+++++
apply MapMerge_Card_ub.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
apply le_antisym.

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A m1) (MapCard A m3)) (MapCard A (MapMerge A m1 m3))
+++++
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m0 + MapCard A m2).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m0 + MapCard A m2).

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
le (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m2)) (Init.Nat.add (MapCard A m1) (MapCard A m3))) (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m2)) (MapCard A (MapMerge A m1 m3)))
+++++
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m0 + MapCard A m2).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
le (Nat.add (Nat.add (MapCard A m0) (MapCard A m1)) (Nat.add (MapCard A m2) (MapCard A m3))) (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m2)) (MapCard A (MapMerge A m1 m3)))
+++++
change (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m0 + MapCard A m2).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
change (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)))\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (Init.Nat.add (MapCard A m2) (MapCard A m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
le (Nat.add (Nat.add (MapCard A m0) (MapCard A m1)) (Nat.add (MapCard A m2) (MapCard A m3))) (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m2)) (MapCard A (MapMerge A m1 m3)))
+++++
rewrite <- H3.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m0 + MapCard A m2).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
change (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.
rewrite <- H3.

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)))\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (Init.Nat.add (MapCard A m2) (MapCard A m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
le (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3))) (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m2)) (MapCard A (MapMerge A m1 m3)))
+++++
simpl in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m0 + MapCard A m2).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
change (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.
rewrite <- H3.
simpl in |- *.

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)))\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (Init.Nat.add (MapCard A m2) (MapCard A m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapMerge A m1 m3))) (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m2)) (MapCard A (MapMerge A m1 m3)))
+++++
apply plus_le_compat_r.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m0 + MapCard A m2).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
change (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.
rewrite <- H3.
simpl in |- *.
apply plus_le_compat_r.

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)))\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (Init.Nat.add (MapCard A m2) (MapCard A m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapMerge A m0 m2)) (Init.Nat.add (MapCard A m0) (MapCard A m2))
+++++
apply MapMerge_Card_ub.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m1) true
+++++
elim (in_dom_some _ _ _ H4).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some x)), eq (in_dom A (N.div2 a) m1) true
+++++
intros y H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).
intros y H7.

*****
H7 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m1) true
+++++
rewrite (MapGet_M2_bit_0_1 _ a H6 m0 m1) in H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).
intros y H7.
rewrite (MapGet_M2_bit_0_1 _ a H6 m0 m1) in H7.

*****
H7 : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m1) true
+++++
unfold in_dom in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).
intros y H7.
rewrite (MapGet_M2_bit_0_1 _ a H6 m0 m1) in H7.
unfold in_dom in |- *.

*****
H7 : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m1 (N.div2 a) with | Some _ => true | None => false end true
+++++
rewrite H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).
intros y H7.
rewrite (MapGet_M2_bit_0_1 _ a H6 m0 m1) in H7.
unfold in_dom in |- *.
rewrite H7.

*****
H7 : eq (MapGet A m1 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m3) true
+++++
elim (in_dom_some _ _ _ H5).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).

*****
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A (M2 A m2 m3) a) (Some x)), eq (in_dom A (N.div2 a) m3) true
+++++
intros y H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).
intros y H7.

*****
H7 : eq (MapGet A (M2 A m2 m3) a) (Some y)
y : A
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m3) true
+++++
rewrite (MapGet_M2_bit_0_1 _ a H6 m2 m3) in H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).
intros y H7.
rewrite (MapGet_M2_bit_0_1 _ a H6 m2 m3) in H7.

*****
H7 : eq (MapGet A m3 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m3) true
+++++
unfold in_dom in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).
intros y H7.
rewrite (MapGet_M2_bit_0_1 _ a H6 m2 m3) in H7.
unfold in_dom in |- *.

*****
H7 : eq (MapGet A m3 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m3 (N.div2 a) with | Some _ => true | None => false end true
+++++
rewrite H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H0.
apply H0 with (m' := m3) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).
intros y H7.
rewrite (MapGet_M2_bit_0_1 _ a H6 m2 m3) in H7.
unfold in_dom in |- *.
rewrite H7.

*****
H7 : eq (MapGet A m3 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) true
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m1) true) (_ : eq (in_dom A a m') true),\nFalse
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
forall _ : eq (N.odd a) false, False
+++++
intro H6.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))),\nMapDisjoint A A m0 m'
m,m0 : Map A
A,B : Type
*****
False
+++++
unfold MapDisjoint in H.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
False
+++++
apply H with (m' := m2) (a := Ndiv2 a).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq (MapCard A (MapMerge A m0 m2)) (Init.Nat.add (MapCard A m0) (MapCard A m2))
+++++
apply le_antisym.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapMerge A m0 m2)) (Init.Nat.add (MapCard A m0) (MapCard A m2))
+++++
apply MapMerge_Card_ub.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A m0) (MapCard A m2)) (MapCard A (MapMerge A m0 m2))
+++++
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m1 + MapCard A m3).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m1 + MapCard A m3).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (Init.Nat.add (Init.Nat.add (MapCard A m1) (MapCard A m3)) (Init.Nat.add (MapCard A m0) (MapCard A m2))) (Init.Nat.add (Init.Nat.add (MapCard A m1) (MapCard A m3)) (MapCard A (MapMerge A m0 m2)))
+++++
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A m0 + MapCard A m2)).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m1 + MapCard A m3).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A m0 + MapCard A m2)).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m2)) (Init.Nat.add (MapCard A m1) (MapCard A m3))) (Init.Nat.add (Init.Nat.add (MapCard A m1) (MapCard A m3)) (MapCard A (MapMerge A m0 m2)))
+++++
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m1 + MapCard A m3).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A m0 + MapCard A m2)).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (Nat.add (Nat.add (MapCard A m0) (MapCard A m1)) (Nat.add (MapCard A m2) (MapCard A m3))) (Init.Nat.add (Init.Nat.add (MapCard A m1) (MapCard A m3)) (MapCard A (MapMerge A m0 m2)))
+++++
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A (MapMerge A m0 m2))).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m1 + MapCard A m3).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A m0 + MapCard A m2)).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A (MapMerge A m0 m2))).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (Nat.add (Nat.add (MapCard A m0) (MapCard A m1)) (Nat.add (MapCard A m2) (MapCard A m3))) (Nat.add (MapCard A (MapMerge A m0 m2)) (Init.Nat.add (MapCard A m1) (MapCard A m3)))
+++++
change (MapCard A (MapMerge A m0 m2) + MapCard A (MapMerge A m1 m3) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m1 + MapCard A m3).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A m0 + MapCard A m2)).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A (MapMerge A m0 m2))).
change (MapCard A (MapMerge A m0 m2) + MapCard A (MapMerge A m1 m3) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq\n (Init.Nat.add (MapCard A (MapMerge A m0 m2))\n (MapCard A (MapMerge A m1 m3)))\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (Init.Nat.add (MapCard A m2) (MapCard A m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (Nat.add (Nat.add (MapCard A m0) (MapCard A m1)) (Nat.add (MapCard A m2) (MapCard A m3))) (Nat.add (MapCard A (MapMerge A m0 m2)) (Init.Nat.add (MapCard A m1) (MapCard A m3)))
+++++
rewrite <- H3.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m1 + MapCard A m3).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A m0 + MapCard A m2)).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A (MapMerge A m0 m2))).
change (MapCard A (MapMerge A m0 m2) + MapCard A (MapMerge A m1 m3) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.
rewrite <- H3.

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq\n (Init.Nat.add (MapCard A (MapMerge A m0 m2))\n (MapCard A (MapMerge A m1 m3)))\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (Init.Nat.add (MapCard A m2) (MapCard A m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A (MapMerge A m0 m2)) (MapCard A (MapMerge A m1 m3))) (Nat.add (MapCard A (MapMerge A m0 m2)) (Init.Nat.add (MapCard A m1) (MapCard A m3)))
+++++
apply plus_le_compat_l.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
apply le_antisym.
apply (fun p n m:nat => plus_le_reg_l n m p) with (p := MapCard A m1 + MapCard A m3).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A m0 + MapCard A m2)).
rewrite (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) ( MapCard A m1) (MapCard A m3)).
rewrite (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A (MapMerge A m0 m2))).
change (MapCard A (MapMerge A m0 m2) + MapCard A (MapMerge A m1 m3) = MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) in H3.
rewrite <- H3.
apply plus_le_compat_l.

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq\n (Init.Nat.add (MapCard A (MapMerge A m0 m2))\n (MapCard A (MapMerge A m1 m3)))\n (Init.Nat.add (Init.Nat.add (MapCard A m0) (MapCard A m1))\n (Init.Nat.add (MapCard A m2) (MapCard A m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapMerge A m1 m3)) (Init.Nat.add (MapCard A m1) (MapCard A m3))
+++++
apply MapMerge_Card_ub.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m0) true
+++++
elim (in_dom_some _ _ _ H4).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some x)), eq (in_dom A (N.div2 a) m0) true
+++++
intros y H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).
intros y H7.

*****
H7 : eq (MapGet A (M2 A m0 m1) a) (Some y)
y : A
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m0) true
+++++
rewrite (MapGet_M2_bit_0_0 _ a H6 m0 m1) in H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).
intros y H7.
rewrite (MapGet_M2_bit_0_0 _ a H6 m0 m1) in H7.

*****
H7 : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m0) true
+++++
unfold in_dom in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).
intros y H7.
rewrite (MapGet_M2_bit_0_0 _ a H6 m0 m1) in H7.
unfold in_dom in |- *.

*****
H7 : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m0 (N.div2 a) with | Some _ => true | None => false end true
+++++
rewrite H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H4).
intros y H7.
rewrite (MapGet_M2_bit_0_0 _ a H6 m0 m1) in H7.
unfold in_dom in |- *.
rewrite H7.

*****
H7 : eq (MapGet A m0 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m2) true
+++++
elim (in_dom_some _ _ _ H5).
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).

*****
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A (M2 A m2 m3) a) (Some x)), eq (in_dom A (N.div2 a) m2) true
+++++
intros y H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).
intros y H7.

*****
H7 : eq (MapGet A (M2 A m2 m3) a) (Some y)
y : A
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m2) true
+++++
rewrite (MapGet_M2_bit_0_0 _ a H6 m2 m3) in H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).
intros y H7.
rewrite (MapGet_M2_bit_0_0 _ a H6 m2 m3) in H7.

*****
H7 : eq (MapGet A m2 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.div2 a) m2) true
+++++
unfold in_dom in |- *.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).
intros y H7.
rewrite (MapGet_M2_bit_0_0 _ a H6 m2 m3) in H7.
unfold in_dom in |- *.

*****
H7 : eq (MapGet A m2 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m2 (N.div2 a) with | Some _ => true | None => false end true
+++++
rewrite H7.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.
simple induction m'.
intros.
unfold MapDisjoint in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H6.
unfold MapDisjoint in H.
apply H with (m' := m2) (a := Ndiv2 a).
elim (in_dom_some _ _ _ H5).
intros y H7.
rewrite (MapGet_M2_bit_0_0 _ a H6 m2 m3) in H7.
unfold in_dom in |- *.
rewrite H7.

*****
H7 : eq (MapGet A m2 (N.div2 a)) (Some y)
y : A
H6 : eq (N.odd a) false
H5 : eq (in_dom A a (M2 A m2 m3)) true
H4 : eq (in_dom A a (M2 A m0 m1)) true
a : ad
H3 : eq (MapCard A (MapMerge A (M2 A m0 m1) (M2 A m2 m3)))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A (M2 A m2 m3)))
H2 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m3))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m3)),\nMapDisjoint A A (M2 A m0 m1) m3
m3 : Map A
H1 : forall\n _ : eq (MapCard A (MapMerge A (M2 A m0 m1) m2))\n (Init.Nat.add (MapCard A (M2 A m0 m1)) (MapCard A m2)),\nMapDisjoint A A (M2 A m0 m1) m2
m',m2 : Map A
H0 : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m1 m'))\n (Init.Nat.add (MapCard A m1) (MapCard A m'))),\nMapDisjoint A A m1 m'
m1 : Map A
H : forall (m' : Map A)\n (_ : eq (MapCard A (MapMerge A m0 m'))\n (Init.Nat.add (MapCard A m0) (MapCard A m'))) \n (a : ad) (_ : eq (in_dom A a m0) true) (_ : eq (in_dom A a m') true),\nFalse
m,m0 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapMerge_Card_disjoint : forall m m':Map A, MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' -> MapDisjoint A A m m'.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapCard_is_Sn :\n   forall (m:Map A) (n:nat),\n     MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.

*****
A,B : Type
*****
forall (m : Map A) (n : nat) (_ : eq (MapCard A m) (S n)), sig (fun a : ad => eq (in_dom A a m) true)
+++++
Proof.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (n : nat) (_ : eq (MapCard A m) (S n)), sig (fun a : ad => eq (in_dom A a m) true)
+++++
simple induction m.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (n : nat) (_ : eq (MapCard A (M0 A)) (S n)), sig (fun a : ad => eq (in_dom A a (M0 A)) true)
+++++
intros.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.

*****
H : eq (MapCard A (M0 A)) (S n)
n : nat
m : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M0 A)) true)
+++++
discriminate H.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (n : nat) (_ : eq (MapCard A (M1 A a a0)) (S n)), sig (fun a1 : ad => eq (in_dom A a1 (M1 A a a0)) true)
+++++
intros a y n H.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros a y n H.

*****
H : eq (MapCard A (M1 A a y)) (S n)
n : nat
y : A
a : ad
m : Map A
A,B : Type
*****
sig (fun a0 : ad => eq (in_dom A a0 (M1 A a y)) true)
+++++
split with a.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros a y n H.
split with a.

*****
H : eq (MapCard A (M1 A a y)) (S n)
n : nat
y : A
a : ad
m : Map A
A,B : Type
*****
eq (in_dom A a (M1 A a y)) true
+++++
unfold in_dom in |- *.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros a y n H.
split with a.
unfold in_dom in |- *.

*****
H : eq (MapCard A (M1 A a y)) (S n)
n : nat
y : A
a : ad
m : Map A
A,B : Type
*****
eq match MapGet A (M1 A a y) a with | Some _ => true | None => false end true
+++++
rewrite (M1_semantics_1 _ a y).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros a y n H.
split with a.
unfold in_dom in |- *.
rewrite (M1_semantics_1 _ a y).

*****
H : eq (MapCard A (M1 A a y)) (S n)
n : nat
y : A
a : ad
m : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall (n : nat) (_ : eq (MapCard A m) (S n)), sig (fun a : ad => eq (in_dom A a m) true)) (m0 : Map A) (_ : forall (n : nat) (_ : eq (MapCard A m0) (S n)), sig (fun a : ad => eq (in_dom A a m0) true)) (n : nat) (_ : eq (MapCard A (M2 A m m0)) (S n)), sig (fun a : ad => eq (in_dom A a (M2 A m m0)) true)
+++++
intros.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.

*****
H1 : eq (MapCard A (M2 A m0 m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
simpl in H1.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.

*****
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
elim (O_or_S (MapCard _ m0)).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).

*****
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
forall _ : sig (fun m : nat => eq (S m) (MapCard A m0)), sig (fun a0 : ad => eq (in_dom A a0 (M2 A m0 m1)) true)
+++++
intro H2.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.

*****
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
elim H2.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.

*****
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
forall (x : nat) (_ : eq (S x) (MapCard A m0)), sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
intros m2 H3.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.

*****
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
elim (H _ (sym_eq H3)).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).

*****
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
forall (x : ad) (_ : eq (in_dom A x m0) true), sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
intros a H4.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).
intros a H4.

*****
H4 : eq (in_dom A a m0) true
a : ad
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
split with (Ndouble a).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).
intros a H4.
split with (Ndouble a).

*****
H4 : eq (in_dom A a m0) true
a : ad
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.double a) (M2 A m0 m1)) true
+++++
unfold in_dom in |- *.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).
intros a H4.
split with (Ndouble a).
unfold in_dom in |- *.

*****
H4 : eq (in_dom A a m0) true
a : ad
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq match MapGet A (M2 A m0 m1) (N.double a) with | Some _ => true | None => false end true
+++++
rewrite (MapGet_M2_bit_0_0 A (Ndouble a) (Ndouble_bit0 a) m0 m1).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).
intros a H4.
split with (Ndouble a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_0 A (Ndouble a) (Ndouble_bit0 a) m0 m1).

*****
H4 : eq (in_dom A a m0) true
a : ad
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m0 (N.div2 (N.double a)) with | Some _ => true | None => false end true
+++++
rewrite (Ndouble_div2 a).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).
intros a H4.
split with (Ndouble a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_0 A (Ndouble a) (Ndouble_bit0 a) m0 m1).
rewrite (Ndouble_div2 a).

*****
H4 : eq (in_dom A a m0) true
a : ad
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m0 a with | Some _ => true | None => false end true
+++++
elim (in_dom_some _ _ _ H4).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).
intros a H4.
split with (Ndouble a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_0 A (Ndouble a) (Ndouble_bit0 a) m0 m1).
rewrite (Ndouble_div2 a).
elim (in_dom_some _ _ _ H4).

*****
H4 : eq (in_dom A a m0) true
a : ad
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m0 a) (Some x)), eq match MapGet A m0 a with | Some _ => true | None => false end true
+++++
intros y H5.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).
intros a H4.
split with (Ndouble a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_0 A (Ndouble a) (Ndouble_bit0 a) m0 m1).
rewrite (Ndouble_div2 a).
elim (in_dom_some _ _ _ H4).
intros y H5.

*****
H5 : eq (MapGet A m0 a) (Some y)
y : A
H4 : eq (in_dom A a m0) true
a : ad
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m0 a with | Some _ => true | None => false end true
+++++
rewrite H5.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
elim H2.
intros m2 H3.
elim (H _ (sym_eq H3)).
intros a H4.
split with (Ndouble a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_0 A (Ndouble a) (Ndouble_bit0 a) m0 m1).
rewrite (Ndouble_div2 a).
elim (in_dom_some _ _ _ H4).
intros y H5.
rewrite H5.

*****
H5 : eq (MapGet A m0 a) (Some y)
y : A
H4 : eq (in_dom A a m0) true
a : ad
H3 : eq (S m2) (MapCard A m0)
m2 : nat
H2 : sig (fun m : nat => eq (S m) (MapCard A m0))
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).

*****
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
forall _ : eq O (MapCard A m0), sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
intro H2.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.

*****
H2 : eq O (MapCard A m0)
H1 : eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
rewrite <- H2 in H1.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.

*****
H2 : eq O (MapCard A m0)
H1 : eq (Init.Nat.add O (MapCard A m1)) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
simpl in H1.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.

*****
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
elim (H0 _ H1).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).

*****
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
forall (x : ad) (_ : eq (in_dom A x m1) true), sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
intros a H3.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).
intros a H3.

*****
H3 : eq (in_dom A a m1) true
a : ad
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
sig (fun a : ad => eq (in_dom A a (M2 A m0 m1)) true)
+++++
split with (Ndouble_plus_one a).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).
intros a H3.
split with (Ndouble_plus_one a).

*****
H3 : eq (in_dom A a m1) true
a : ad
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq (in_dom A (N.succ_double a) (M2 A m0 m1)) true
+++++
unfold in_dom in |- *.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).
intros a H3.
split with (Ndouble_plus_one a).
unfold in_dom in |- *.

*****
H3 : eq (in_dom A a m1) true
a : ad
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq match MapGet A (M2 A m0 m1) (N.succ_double a) with | Some _ => true | None => false end true
+++++
rewrite (MapGet_M2_bit_0_1 A (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).
intros a H3.
split with (Ndouble_plus_one a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_1 A (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).

*****
H3 : eq (in_dom A a m1) true
a : ad
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m1 (N.div2 (N.succ_double a)) with | Some _ => true | None => false end true
+++++
rewrite (Ndouble_plus_one_div2 a).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).
intros a H3.
split with (Ndouble_plus_one a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_1 A (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).
rewrite (Ndouble_plus_one_div2 a).

*****
H3 : eq (in_dom A a m1) true
a : ad
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m1 a with | Some _ => true | None => false end true
+++++
elim (in_dom_some _ _ _ H3).
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).
intros a H3.
split with (Ndouble_plus_one a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_1 A (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).
rewrite (Ndouble_plus_one_div2 a).
elim (in_dom_some _ _ _ H3).

*****
H3 : eq (in_dom A a m1) true
a : ad
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m1 a) (Some x)), eq match MapGet A m1 a with | Some _ => true | None => false end true
+++++
intros y H4.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).
intros a H3.
split with (Ndouble_plus_one a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_1 A (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).
rewrite (Ndouble_plus_one_div2 a).
elim (in_dom_some _ _ _ H3).
intros y H4.

*****
H4 : eq (MapGet A m1 a) (Some y)
y : A
H3 : eq (in_dom A a m1) true
a : ad
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq match MapGet A m1 a with | Some _ => true | None => false end true
+++++
rewrite H4.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.
intros.
simpl in H1.
elim (O_or_S (MapCard _ m0)).
intro H2.
rewrite <- H2 in H1.
simpl in H1.
elim (H0 _ H1).
intros a H3.
split with (Ndouble_plus_one a).
unfold in_dom in |- *.
rewrite (MapGet_M2_bit_0_1 A (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a) m0 m1).
rewrite (Ndouble_plus_one_div2 a).
elim (in_dom_some _ _ _ H3).
intros y H4.
rewrite H4.

*****
H4 : eq (MapGet A m1 a) (Some y)
y : A
H3 : eq (in_dom A a m1) true
a : ad
H2 : eq O (MapCard A m0)
H1 : eq (MapCard A m1) (S n)
n : nat
H0 : forall (n : nat) (_ : eq (MapCard A m1) (S n)),\nsig (fun a : ad => eq (in_dom A a m1) true)
m1 : Map A
H : forall (n : nat) (_ : eq (MapCard A m0) (S n)),\nsig (fun a : ad => eq (in_dom A a m0) true)
m,m0 : Map A
A,B : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapCard_is_Sn : forall (m:Map A) (n:nat), MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
End MapCard.
-----
Section MapCard2.
-----
Variables A B : Type.
-----
Lemma MapSubset_card_eq_1 :\n   forall (n:nat) (m:Map A) (m':Map B),\n     MapSubset _ _ m m' ->\n     MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.

*****
A,B : Type
*****
forall (n : nat) (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : eq (MapCard A m) n) (_ : eq (MapCard B m') n), MapSubset B A m' m
+++++
Proof.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.

*****
A,B : Type
*****
forall (n : nat) (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : eq (MapCard A m) n) (_ : eq (MapCard B m') n), MapSubset B A m' m
+++++
simple induction n.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.

*****
n : nat
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : eq (MapCard A m) O) (_ : eq (MapCard B m') O), MapSubset B A m' m
+++++
intros.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.

*****
H1 : eq (MapCard B m') O
H0 : eq (MapCard A m) O
H : MapSubset A B m m'
m' : Map B
m : Map A
n : nat
A,B : Type
*****
MapSubset B A m' m
+++++
unfold MapSubset in |- *.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
unfold MapSubset in |- *.

*****
H1 : eq (MapCard B m') O
H0 : eq (MapCard A m) O
H : MapSubset A B m m'
m' : Map B
m : Map A
n : nat
A,B : Type
*****
forall (a : ad) (_ : eq (in_dom B a m') true), eq (in_dom A a m) true
+++++
unfold in_dom in |- *.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
unfold MapSubset in |- *.
unfold in_dom in |- *.

*****
H1 : eq (MapCard B m') O
H0 : eq (MapCard A m) O
H : MapSubset A B m m'
m' : Map B
m : Map A
n : nat
A,B : Type
*****
forall (a : ad) (_ : eq match MapGet B m' a with | Some _ => true | None => false end true), eq match MapGet A m a with | Some _ => true | None => false end true
+++++
intro.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
unfold MapSubset in |- *.
unfold in_dom in |- *.
intro.

*****
a : ad
H1 : eq (MapCard B m') O
H0 : eq (MapCard A m) O
H : MapSubset A B m m'
m' : Map B
m : Map A
n : nat
A,B : Type
*****
forall _ : eq match MapGet B m' a with | Some _ => true | None => false end true, eq match MapGet A m a with | Some _ => true | None => false end true
+++++
rewrite (MapCard_is_O _ m H0 a).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
unfold MapSubset in |- *.
unfold in_dom in |- *.
intro.
rewrite (MapCard_is_O _ m H0 a).

*****
a : ad
H1 : eq (MapCard B m') O
H0 : eq (MapCard A m) O
H : MapSubset A B m m'
m' : Map B
m : Map A
n : nat
A,B : Type
*****
forall _ : eq match MapGet B m' a with | Some _ => true | None => false end true, eq false true
+++++
rewrite (MapCard_is_O _ m' H1 a).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
unfold MapSubset in |- *.
unfold in_dom in |- *.
intro.
rewrite (MapCard_is_O _ m H0 a).
rewrite (MapCard_is_O _ m' H1 a).

*****
a : ad
H1 : eq (MapCard B m') O
H0 : eq (MapCard A m) O
H : MapSubset A B m m'
m' : Map B
m : Map A
n : nat
A,B : Type
*****
forall _ : eq false true, eq false true
+++++
intro H2.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
unfold MapSubset in |- *.
unfold in_dom in |- *.
intro.
rewrite (MapCard_is_O _ m H0 a).
rewrite (MapCard_is_O _ m' H1 a).
intro H2.

*****
H2 : eq false true
a : ad
H1 : eq (MapCard B m') O
H0 : eq (MapCard A m) O
H : MapSubset A B m m'
m' : Map B
m : Map A
n : nat
A,B : Type
*****
eq false true
+++++
discriminate H2.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.

*****
n : nat
A,B : Type
*****
forall (n : nat) (_ : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : eq (MapCard A m) n) (_ : eq (MapCard B m') n), MapSubset B A m' m) (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : eq (MapCard A m) (S n)) (_ : eq (MapCard B m') (S n)), MapSubset B A m' m
+++++
intros.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.

*****
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset B A m' m
+++++
elim (MapCard_is_Sn A m n0 H1).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).

*****
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall (x : ad) (_ : eq (in_dom A x m) true), MapSubset B A m' m
+++++
intros a H3.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.

*****
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset B A m' m
+++++
elim (in_dom_some _ _ _ H3).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).

*****
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), MapSubset B A m' m
+++++
intros y H4.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.

*****
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset B A m' m
+++++
elim (in_dom_some _ _ _ (H0 _ H3)).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).

*****
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m' a) (Some x)), MapSubset B A m' m
+++++
intros y' H6.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.

*****
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset B A m' m
+++++
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).

*****
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall _ : eqmap A (MapPut A (MapRemove A m a) a y) m, MapSubset B A m' m
+++++
intro.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.

*****
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset B A m' m
+++++
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').

*****
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall _ : eqmap B (MapPut B (MapRemove B m' a) a y') m', MapSubset B A m' m
+++++
intro.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset B A m' m
+++++
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eqmap B (MapPut B (MapRemove B m' a) a y') m'
+++++
assumption.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eqmap A (MapPut A (MapRemove A m a) a y) m
+++++
assumption.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset B A (MapPut B (MapRemove B m' a) a y') (MapPut A (MapRemove A m a) a y)
+++++
apply MapSubset_Put_mono.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset B A (MapRemove B m' a) (MapRemove A m a)
+++++
apply H.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.
apply H.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset A B (MapRemove A m a) (MapRemove B m' a)
+++++
apply MapSubset_Remove_mono.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.
apply H.
apply MapSubset_Remove_mono.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
MapSubset A B m m'
+++++
assumption.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.
apply H.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) n0
+++++
rewrite <- (MapCard_Remove_2_conv _ m a y H4) in H1.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.
apply H.
rewrite <- (MapCard_Remove_2_conv _ m a y H4) in H1.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
H2 : eq (MapCard B m') (S n0)
H1 : eq (S (MapCard A (MapRemove A m a))) (S n0)
a : ad
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) n0
+++++
inversion_clear H1.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.
apply H.
rewrite <- (MapCard_Remove_2_conv _ m a y H4) in H1.
inversion_clear H1.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
H2 : eq (MapCard B m') (S n0)
a : ad
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapCard A (MapRemove A m a)) (MapCard A (MapRemove A m a))
+++++
reflexivity.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.
apply H.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapCard B (MapRemove B m' a)) n0
+++++
rewrite <- (MapCard_Remove_2_conv _ m' a y' H6) in H2.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.
apply H.
rewrite <- (MapCard_Remove_2_conv _ m' a y' H6) in H2.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
H2 : eq (S (MapCard B (MapRemove B m' a))) (S n0)
a : ad
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapCard B (MapRemove B m' a)) n0
+++++
inversion_clear H2.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
intro.
apply MapSubset_ext with (m0 := MapPut _ (MapRemove _ m' a) a y') (m2 := MapPut _ (MapRemove _ m a) a y).
apply MapSubset_Put_mono.
apply H.
rewrite <- (MapCard_Remove_2_conv _ m' a y' H6) in H2.
inversion_clear H2.

*****
H7 : eqmap B (MapPut B (MapRemove B m' a) a y') m'
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapCard B (MapRemove B m' a)) (MapCard B (MapRemove B m' a))
+++++
reflexivity.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').

*****
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eqmap B (MapPut B (MapRemove B m' a) a y') m'
+++++
unfold eqmap in |- *.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.

*****
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eqm B (MapGet B (MapPut B (MapRemove B m' a) a y')) (MapGet B m')
+++++
unfold eqm in |- *.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.

*****
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall a0 : ad, eq (MapGet B (MapPut B (MapRemove B m' a) a y') a0) (MapGet B m' a0)
+++++
intro.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.

*****
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapGet B (MapPut B (MapRemove B m' a) a y') a0) (MapGet B m' a0)
+++++
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).

*****
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (if N.eqb a a0 then Some y' else MapGet B (MapRemove B m' a) a0) (MapGet B m' a0)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb a a0 then Some y' else MapGet B (MapRemove B m' a) a0) (MapGet B m' a0)
+++++
intro H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.

*****
H7 : eq (N.eqb a a0) true
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (if N.eqb a a0 then Some y' else MapGet B (MapRemove B m' a) a0) (MapGet B m' a0)
+++++
rewrite H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.

*****
H7 : eq (N.eqb a a0) true
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (Some y') (MapGet B m' a0)
+++++
rewrite <- (Neqb_complete _ _ H7).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.
rewrite <- (Neqb_complete _ _ H7).

*****
H7 : eq (N.eqb a a0) true
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (Some y') (MapGet B m' a)
+++++
apply sym_eq.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.
rewrite <- (Neqb_complete _ _ H7).
apply sym_eq.

*****
H7 : eq (N.eqb a a0) true
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapGet B m' a) (Some y')
+++++
assumption.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb a a0 then Some y' else MapGet B (MapRemove B m' a) a0) (MapGet B m' a0)
+++++
intro H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.

*****
H7 : eq (N.eqb a a0) false
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (if N.eqb a a0 then Some y' else MapGet B (MapRemove B m' a) a0) (MapGet B m' a0)
+++++
rewrite H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.

*****
H7 : eq (N.eqb a a0) false
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapGet B (MapRemove B m' a) a0) (MapGet B m' a0)
+++++
rewrite (MapRemove_semantics _ m' a a0).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.
rewrite (MapRemove_semantics _ m' a a0).

*****
H7 : eq (N.eqb a a0) false
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (if N.eqb a a0 then None else MapGet B m' a0) (MapGet B m' a0)
+++++
rewrite H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
intro.
cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m').
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.
rewrite (MapRemove_semantics _ m' a a0).
rewrite H7.

*****
H7 : eq (N.eqb a a0) false
a0 : ad
H5 : eqmap A (MapPut A (MapRemove A m a) a y) m
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapGet B m' a0) (MapGet B m' a0)
+++++
reflexivity.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).

*****
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eqmap A (MapPut A (MapRemove A m a) a y) m
+++++
unfold eqmap in |- *.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.

*****
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eqm A (MapGet A (MapPut A (MapRemove A m a) a y)) (MapGet A m)
+++++
unfold eqm in |- *.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.

*****
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall a0 : ad, eq (MapGet A (MapPut A (MapRemove A m a) a y) a0) (MapGet A m a0)
+++++
intro.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.

*****
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapGet A (MapPut A (MapRemove A m a) a y) a0) (MapGet A m a0)
+++++
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).

*****
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (if N.eqb a a0 then Some y else MapGet A (MapRemove A m a) a0) (MapGet A m a0)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall _ : eq (N.eqb a a0) true, eq (if N.eqb a a0 then Some y else MapGet A (MapRemove A m a) a0) (MapGet A m a0)
+++++
intro H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.

*****
H7 : eq (N.eqb a a0) true
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (if N.eqb a a0 then Some y else MapGet A (MapRemove A m a) a0) (MapGet A m a0)
+++++
rewrite H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.

*****
H7 : eq (N.eqb a a0) true
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (Some y) (MapGet A m a0)
+++++
rewrite <- (Neqb_complete _ _ H7).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.
rewrite <- (Neqb_complete _ _ H7).

*****
H7 : eq (N.eqb a a0) true
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (Some y) (MapGet A m a)
+++++
apply sym_eq.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.
rewrite <- (Neqb_complete _ _ H7).
apply sym_eq.

*****
H7 : eq (N.eqb a a0) true
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapGet A m a) (Some y)
+++++
assumption.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
forall _ : eq (N.eqb a a0) false, eq (if N.eqb a a0 then Some y else MapGet A (MapRemove A m a) a0) (MapGet A m a0)
+++++
intro H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.

*****
H7 : eq (N.eqb a a0) false
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (if N.eqb a a0 then Some y else MapGet A (MapRemove A m a) a0) (MapGet A m a0)
+++++
rewrite H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.

*****
H7 : eq (N.eqb a a0) false
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapGet A (MapRemove A m a) a0) (MapGet A m a0)
+++++
rewrite (MapRemove_semantics A m a a0).
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.
rewrite (MapRemove_semantics A m a a0).

*****
H7 : eq (N.eqb a a0) false
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (if N.eqb a a0 then None else MapGet A m a0) (MapGet A m a0)
+++++
rewrite H7.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.
intros.
elim (MapCard_is_Sn A m n0 H1).
intros a H3.
elim (in_dom_some _ _ _ H3).
intros y H4.
elim (in_dom_some _ _ _ (H0 _ H3)).
intros y' H6.
cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m).
unfold eqmap in |- *.
unfold eqm in |- *.
intro.
rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).
elim (sumbool_of_bool (Neqb a a0)).
intro H7.
rewrite H7.
rewrite (MapRemove_semantics A m a a0).
rewrite H7.

*****
H7 : eq (N.eqb a a0) false
a0 : ad
H6 : eq (MapGet B m' a) (Some y')
y' : B
H4 : eq (MapGet A m a) (Some y)
y : A
H3 : eq (in_dom A a m) true
a : ad
H2 : eq (MapCard B m') (S n0)
H1 : eq (MapCard A m) (S n0)
H0 : MapSubset A B m m'
m' : Map B
m : Map A
H : forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m')\n (_ : eq (MapCard A m) n0) (_ : eq (MapCard B m') n0),\nMapSubset B A m' m
n,n0 : nat
A,B : Type
*****
eq (MapGet A m a0) (MapGet A m a0)
+++++
reflexivity.
-----
Lemma MapSubset_card_eq_1 : forall (n:nat) (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.
Proof.
simple induction n.

*****

*****

+++++
Qed.
-----
Lemma MapDomRestrTo_Card_ub_r :\n   forall (m:Map A) (m':Map B),\n     MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), le (MapCard A (MapDomRestrTo A B m m')) (MapCard B m')
+++++
Proof.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), le (MapCard A (MapDomRestrTo A B m m')) (MapCard B m')
+++++
simple induction m.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall m' : Map B, le (MapCard A (MapDomRestrTo A B (M0 A) m')) (MapCard B m')
+++++
intro.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intro.

*****
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B (M0 A) m')) (MapCard B m')
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intro.
simpl in |- *.

*****
m' : Map B
m : Map A
A,B : Type
*****
le O (MapCard B m')
+++++
apply le_O_n.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (a : ad) (a0 : A) (m' : Map B), le (MapCard A (MapDomRestrTo A B (M1 A a a0) m')) (MapCard B m')
+++++
intros a y m'.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.

*****
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B (M1 A a y) m')) (MapCard B m')
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.

*****
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A match MapGet B m' a with | Some _ => M1 A a y | None => M0 A end) (MapCard B m')
+++++
elim (option_sum B (MapGet B m' a)).
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).

*****
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : sig (fun y : B => eq (MapGet B m' a) (Some y)), le (MapCard A match MapGet B m' a with | Some _ => M1 A a y | None => M0 A end) (MapCard B m')
+++++
intro H.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.

*****
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A match MapGet B m' a with | Some _ => M1 A a y | None => M0 A end) (MapCard B m')
+++++
elim H.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.

*****
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
forall (x : B) (_ : eq (MapGet B m' a) (Some x)), le (MapCard A match MapGet B m' a with | Some _ => M1 A a y | None => M0 A end) (MapCard B m')
+++++
intros y0 H0.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y0 H0.

*****
H0 : eq (MapGet B m' a) (Some y0)
y0 : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A match MapGet B m' a with | Some _ => M1 A a y | None => M0 A end) (MapCard B m')
+++++
rewrite H0.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.

*****
H0 : eq (MapGet B m' a) (Some y0)
y0 : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (M1 A a y)) (MapCard B m')
+++++
elim (MapCard_is_not_O B m' a y0 H0).
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
elim (MapCard_is_not_O B m' a y0 H0).

*****
H0 : eq (MapGet B m' a) (Some y0)
y0 : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
forall (x : nat) (_ : eq (MapCard B m') (S x)), le (MapCard A (M1 A a y)) (MapCard B m')
+++++
intros n H1.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
elim (MapCard_is_not_O B m' a y0 H0).
intros n H1.

*****
H1 : eq (MapCard B m') (S n)
n : nat
H0 : eq (MapGet B m' a) (Some y0)
y0 : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (M1 A a y)) (MapCard B m')
+++++
rewrite H1.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
elim (MapCard_is_not_O B m' a y0 H0).
intros n H1.
rewrite H1.

*****
H1 : eq (MapCard B m') (S n)
n : nat
H0 : eq (MapGet B m' a) (Some y0)
y0 : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (M1 A a y)) (S n)
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
elim (MapCard_is_not_O B m' a y0 H0).
intros n H1.
rewrite H1.
simpl in |- *.

*****
H1 : eq (MapCard B m') (S n)
n : nat
H0 : eq (MapGet B m' a) (Some y0)
y0 : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (S O) (S n)
+++++
apply le_n_S.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
elim H.
intros y0 H0.
rewrite H0.
elim (MapCard_is_not_O B m' a y0 H0).
intros n H1.
rewrite H1.
simpl in |- *.
apply le_n_S.

*****
H1 : eq (MapCard B m') (S n)
n : nat
H0 : eq (MapGet B m' a) (Some y0)
y0 : B
H : sig (fun y : B => eq (MapGet B m' a) (Some y))
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le O n
+++++
apply le_O_n.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).

*****
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
forall _ : eq (MapGet B m' a) None, le (MapCard A match MapGet B m' a with | Some _ => M1 A a y | None => M0 A end) (MapCard B m')
+++++
intro H.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.

*****
H : eq (MapGet B m' a) None
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A match MapGet B m' a with | Some _ => M1 A a y | None => M0 A end) (MapCard B m')
+++++
rewrite H.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
rewrite H.

*****
H : eq (MapGet B m' a) None
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le (MapCard A (M0 A)) (MapCard B m')
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
intros a y m'.
simpl in |- *.
elim (option_sum B (MapGet B m' a)).
intro H.
rewrite H.
simpl in |- *.

*****
H : eq (MapGet B m' a) None
m' : Map B
y : A
a : ad
m : Map A
A,B : Type
*****
le O (MapCard B m')
+++++
apply le_O_n.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.

*****
m : Map A
A,B : Type
*****
forall (m : Map A) (_ : forall m' : Map B, le (MapCard A (MapDomRestrTo A B m m')) (MapCard B m')) (m0 : Map A) (_ : forall m' : Map B, le (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')) (m' : Map B), le (MapCard A (MapDomRestrTo A B (M2 A m m0) m')) (MapCard B m')
+++++
simple induction m'.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) (M0 B))) (MapCard B (M0 B))
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
simpl in |- *.

*****
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le O O
+++++
apply le_O_n.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
forall (a : ad) (a0 : B), le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) (M1 B a a0))) (MapCard B (M1 B a a0))
+++++
intros a y.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros a y.

*****
y : B
a : ad
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) (M1 B a y))) (MapCard B (M1 B a y))
+++++
unfold MapDomRestrTo in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros a y.
unfold MapDomRestrTo in |- *.

*****
y : B
a : ad
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (MapCard A match MapGet A (M2 A m0 m1) a with | Some y => M1 A a y | None => M0 A end) (MapCard B (M1 B a y))
+++++
case (MapGet A (M2 A m0 m1) a).
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros a y.
unfold MapDomRestrTo in |- *.
case (MapGet A (M2 A m0 m1) a).

*****
y : B
a : ad
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
forall a0 : A, le (MapCard A (M1 A a a0)) (MapCard B (M1 B a y))
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros a y.
unfold MapDomRestrTo in |- *.
case (MapGet A (M2 A m0 m1) a).
simpl in |- *.

*****
y : B
a : ad
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
forall _ : A, le (S O) (S O)
+++++
intro.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros a y.
unfold MapDomRestrTo in |- *.
case (MapGet A (M2 A m0 m1) a).
simpl in |- *.
intro.

*****
a0 : A
y : B
a : ad
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (S O) (S O)
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros a y.
unfold MapDomRestrTo in |- *.
case (MapGet A (M2 A m0 m1) a).
simpl in |- *.
intro.
simpl in |- *.

*****
a0 : A
y : B
a : ad
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (S O) (S O)
+++++
apply le_n.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros a y.
unfold MapDomRestrTo in |- *.
case (MapGet A (M2 A m0 m1) a).

*****
y : B
a : ad
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (MapCard A (M0 A)) (MapCard B (M1 B a y))
+++++
apply le_O_n.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.

*****
m' : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
forall (m : Map B) (_ : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m)) (MapCard B m)) (m2 : Map B) (_ : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m2)) (MapCard B m2)), le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) (M2 B m m2))) (MapCard B (M2 B m m2))
+++++
intros.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros.

*****
H2 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m3)) (MapCard B m3)
m3 : Map B
H1 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m2)) (MapCard B m2)
m',m2 : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) (M2 B m2 m3))) (MapCard B (M2 B m2 m3))
+++++
simpl in |- *.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.

*****
H2 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m3)) (MapCard B m3)
m3 : Map B
H1 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m2)) (MapCard B m2)
m',m2 : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (MapCard A (makeM2 A (MapDomRestrTo A B m0 m2) (MapDomRestrTo A B m1 m3))) (Init.Nat.add (MapCard B m2) (MapCard B m3))
+++++
rewrite (MapCard_makeM2 A (MapDomRestrTo A B m0 m2) (MapDomRestrTo A B m1 m3)).
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (MapCard_makeM2 A (MapDomRestrTo A B m0 m2) (MapDomRestrTo A B m1 m3)).

*****
H2 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m3)) (MapCard B m3)
m3 : Map B
H1 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m2)) (MapCard B m2)
m',m2 : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A (MapDomRestrTo A B m0 m2)) (MapCard A (MapDomRestrTo A B m1 m3))) (Init.Nat.add (MapCard B m2) (MapCard B m3))
+++++
apply plus_le_compat.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (MapCard_makeM2 A (MapDomRestrTo A B m0 m2) (MapDomRestrTo A B m1 m3)).
apply plus_le_compat.

*****
H2 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m3)) (MapCard B m3)
m3 : Map B
H1 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m2)) (MapCard B m2)
m',m2 : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B m0 m2)) (MapCard B m2)
+++++
apply H.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.
simple induction m'.
intros.
simpl in |- *.
rewrite (MapCard_makeM2 A (MapDomRestrTo A B m0 m2) (MapDomRestrTo A B m1 m3)).
apply plus_le_compat.

*****
H2 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m3)) (MapCard B m3)
m3 : Map B
H1 : le (MapCard A (MapDomRestrTo A B (M2 A m0 m1) m2)) (MapCard B m2)
m',m2 : Map B
H0 : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m1 m')) (MapCard B m')
m1 : Map A
H : forall m' : Map B,\nle (MapCard A (MapDomRestrTo A B m0 m')) (MapCard B m')
m,m0 : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B m1 m3)) (MapCard B m3)
+++++
apply H0.
-----
Lemma MapDomRestrTo_Card_ub_r : forall (m:Map A) (m':Map B), MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
End MapCard2.
-----
Section MapCard3.
-----
Variables A B : Type.
-----
Lemma MapMerge_Card_lb_l :\n   forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.

*****
A,B : Type
*****
forall m m' : Map A, ge (MapCard A (MapMerge A m m')) (MapCard A m)
+++++
Proof.
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.

*****
A,B : Type
*****
forall m m' : Map A, ge (MapCard A (MapMerge A m m')) (MapCard A m)
+++++
unfold ge in |- *.
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.
unfold ge in |- *.

*****
A,B : Type
*****
forall m m' : Map A, le (MapCard A m) (MapCard A (MapMerge A m m'))
+++++
intros.
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.

*****
m,m' : Map A
A,B : Type
*****
le (MapCard A m) (MapCard A (MapMerge A m m'))
+++++
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m')).
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m')).

*****
m,m' : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A m') (MapCard A m)) (Init.Nat.add (MapCard A m') (MapCard A (MapMerge A m m')))
+++++
rewrite (plus_comm (MapCard A m') (MapCard A m)).
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m')).
rewrite (plus_comm (MapCard A m') (MapCard A m)).

*****
m,m' : Map A
A,B : Type
*****
le (Nat.add (MapCard A m) (MapCard A m')) (Init.Nat.add (MapCard A m') (MapCard A (MapMerge A m m')))
+++++
rewrite (plus_comm (MapCard A m') (MapCard A (MapMerge A m m'))).
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m')).
rewrite (plus_comm (MapCard A m') (MapCard A m)).
rewrite (plus_comm (MapCard A m') (MapCard A (MapMerge A m m'))).

*****
m,m' : Map A
A,B : Type
*****
le (Nat.add (MapCard A m) (MapCard A m')) (Nat.add (MapCard A (MapMerge A m m')) (MapCard A m'))
+++++
rewrite (MapMerge_Restr_Card A m m').
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m')).
rewrite (plus_comm (MapCard A m') (MapCard A m)).
rewrite (plus_comm (MapCard A m') (MapCard A (MapMerge A m m'))).
rewrite (MapMerge_Restr_Card A m m').

*****
m,m' : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m'))) (Nat.add (MapCard A (MapMerge A m m')) (MapCard A m'))
+++++
apply plus_le_compat_l.
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m')).
rewrite (plus_comm (MapCard A m') (MapCard A m)).
rewrite (plus_comm (MapCard A m') (MapCard A (MapMerge A m m'))).
rewrite (MapMerge_Restr_Card A m m').
apply plus_le_compat_l.

*****
m,m' : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A A m m')) (MapCard A m')
+++++
apply MapDomRestrTo_Card_ub_r.
-----
Lemma MapMerge_Card_lb_l : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m')).
rewrite (plus_comm (MapCard A m') (MapCard A m)).
rewrite (plus_comm (MapCard A m') (MapCard A (MapMerge A m m'))).
rewrite (MapMerge_Restr_Card A m m').
apply plus_le_compat_l.
apply MapDomRestrTo_Card_ub_r.

*****

*****

+++++
Qed.
-----
Lemma MapMerge_Card_lb_r :\n   forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.

*****
A,B : Type
*****
forall m m' : Map A, ge (MapCard A (MapMerge A m m')) (MapCard A m')
+++++
Proof.
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
Proof.

*****
A,B : Type
*****
forall m m' : Map A, ge (MapCard A (MapMerge A m m')) (MapCard A m')
+++++
unfold ge in |- *.
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
Proof.
unfold ge in |- *.

*****
A,B : Type
*****
forall m m' : Map A, le (MapCard A m') (MapCard A (MapMerge A m m'))
+++++
intros.
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
Proof.
unfold ge in |- *.
intros.

*****
m,m' : Map A
A,B : Type
*****
le (MapCard A m') (MapCard A (MapMerge A m m'))
+++++
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m)).
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m)).

*****
m,m' : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A m) (MapCard A m')) (Init.Nat.add (MapCard A m) (MapCard A (MapMerge A m m')))
+++++
rewrite (MapMerge_Restr_Card A m m').
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m)).
rewrite (MapMerge_Restr_Card A m m').

*****
m,m' : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m'))) (Init.Nat.add (MapCard A m) (MapCard A (MapMerge A m m')))
+++++
rewrite (plus_comm (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m'))).
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m)).
rewrite (MapMerge_Restr_Card A m m').
rewrite (plus_comm (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m'))).

*****
m,m' : Map A
A,B : Type
*****
le (Nat.add (MapCard A (MapDomRestrTo A A m m')) (MapCard A (MapMerge A m m'))) (Init.Nat.add (MapCard A m) (MapCard A (MapMerge A m m')))
+++++
apply plus_le_compat_r.
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m)).
rewrite (MapMerge_Restr_Card A m m').
rewrite (plus_comm (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m'))).
apply plus_le_compat_r.

*****
m,m' : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A A m m')) (MapCard A m)
+++++
apply MapDomRestrTo_Card_ub_l.
-----
Lemma MapMerge_Card_lb_r : forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.
Proof.
unfold ge in |- *.
intros.
apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m)).
rewrite (MapMerge_Restr_Card A m m').
rewrite (plus_comm (MapCard A (MapMerge A m m')) (MapCard A (MapDomRestrTo A A m m'))).
apply plus_le_compat_r.
apply MapDomRestrTo_Card_ub_l.

*****

*****

+++++
Qed.
-----
Lemma MapDomRestrBy_Card_lb :\n   forall (m:Map A) (m':Map B),\n     MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.
-----
Lemma MapDomRestrBy_Card_lb : forall (m:Map A) (m':Map B), MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), ge (Init.Nat.add (MapCard B m') (MapCard A (MapDomRestrBy A B m m'))) (MapCard A m)
+++++
Proof.
-----
Lemma MapDomRestrBy_Card_lb : forall (m:Map A) (m':Map B), MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), ge (Init.Nat.add (MapCard B m') (MapCard A (MapDomRestrBy A B m m'))) (MapCard A m)
+++++
unfold ge in |- *.
-----
Lemma MapDomRestrBy_Card_lb : forall (m:Map A) (m':Map B), MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.
Proof.
unfold ge in |- *.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B), le (MapCard A m) (Init.Nat.add (MapCard B m') (MapCard A (MapDomRestrBy A B m m')))
+++++
intros.
-----
Lemma MapDomRestrBy_Card_lb : forall (m:Map A) (m':Map B), MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.

*****
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A m) (Init.Nat.add (MapCard B m') (MapCard A (MapDomRestrBy A B m m')))
+++++
rewrite (MapSplit_Card A B m m').
-----
Lemma MapDomRestrBy_Card_lb : forall (m:Map A) (m':Map B), MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
rewrite (MapSplit_Card A B m m').

*****
m' : Map B
m : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard A (MapDomRestrTo A B m m')) (MapCard A (MapDomRestrBy A B m m'))) (Init.Nat.add (MapCard B m') (MapCard A (MapDomRestrBy A B m m')))
+++++
apply plus_le_compat_r.
-----
Lemma MapDomRestrBy_Card_lb : forall (m:Map A) (m':Map B), MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
rewrite (MapSplit_Card A B m m').
apply plus_le_compat_r.

*****
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A (MapDomRestrTo A B m m')) (MapCard B m')
+++++
apply MapDomRestrTo_Card_ub_r.
-----
Lemma MapDomRestrBy_Card_lb : forall (m:Map A) (m':Map B), MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.
Proof.
unfold ge in |- *.
intros.
rewrite (MapSplit_Card A B m m').
apply plus_le_compat_r.
apply MapDomRestrTo_Card_ub_r.

*****

*****

+++++
Qed.
-----
Lemma MapSubset_Card_le :\n   forall (m:Map A) (m':Map B),\n     MapSubset A B m m' -> MapCard A m <= MapCard B m'.
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m'), le (MapCard A m) (MapCard B m')
+++++
Proof.
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m'), le (MapCard A m) (MapCard B m')
+++++
intros.
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.
Proof.
intros.

*****
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A m) (MapCard B m')
+++++
apply le_trans with (m := MapCard B m' + MapCard A (MapDomRestrBy A B m m')).
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.
Proof.
intros.
apply le_trans with (m := MapCard B m' + MapCard A (MapDomRestrBy A B m m')).

*****
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A m) (Init.Nat.add (MapCard B m') (MapCard A (MapDomRestrBy A B m m')))
+++++
exact (MapDomRestrBy_Card_lb m m').
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.
Proof.
intros.
apply le_trans with (m := MapCard B m' + MapCard A (MapDomRestrBy A B m m')).

*****
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard B m') (MapCard A (MapDomRestrBy A B m m'))) (MapCard B m')
+++++
rewrite (MapCard_ext _ _ _ (MapSubset_imp_2 _ _ _ _ H)).
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.
Proof.
intros.
apply le_trans with (m := MapCard B m' + MapCard A (MapDomRestrBy A B m m')).
rewrite (MapCard_ext _ _ _ (MapSubset_imp_2 _ _ _ _ H)).

*****
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard B m') (MapCard A (M0 A))) (MapCard B m')
+++++
simpl in |- *.
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.
Proof.
intros.
apply le_trans with (m := MapCard B m' + MapCard A (MapDomRestrBy A B m m')).
rewrite (MapCard_ext _ _ _ (MapSubset_imp_2 _ _ _ _ H)).
simpl in |- *.

*****
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
le (Init.Nat.add (MapCard B m') O) (MapCard B m')
+++++
rewrite <- plus_n_O.
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.
Proof.
intros.
apply le_trans with (m := MapCard B m' + MapCard A (MapDomRestrBy A B m m')).
rewrite (MapCard_ext _ _ _ (MapSubset_imp_2 _ _ _ _ H)).
simpl in |- *.
rewrite <- plus_n_O.

*****
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard B m') (MapCard B m')
+++++
apply le_n.
-----
Lemma MapSubset_Card_le : forall (m:Map A) (m':Map B), MapSubset A B m m' -> MapCard A m <= MapCard B m'.
Proof.
intros.
apply le_trans with (m := MapCard B m' + MapCard A (MapDomRestrBy A B m m')).

*****

*****

+++++
Qed.
-----
Lemma MapSubset_card_eq :\n   forall (m:Map A) (m':Map B),\n     MapSubset _ _ m m' ->\n     MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : le (MapCard B m') (MapCard A m)), eqmap unit (MapDom A m) (MapDom B m')
+++++
Proof.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.

*****
A,B : Type
*****
forall (m : Map A) (m' : Map B) (_ : MapSubset A B m m') (_ : le (MapCard B m') (MapCard A m)), eqmap unit (MapDom A m) (MapDom B m')
+++++
intros.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.

*****
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
eqmap unit (MapDom A m) (MapDom B m')
+++++
apply MapSubset_antisym.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.

*****
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
MapSubset A B m m'
+++++
assumption.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.

*****
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
MapSubset B A m' m
+++++
cut (MapCard B m' = MapCard A m).
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).

*****
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
forall _ : eq (MapCard B m') (MapCard A m), MapSubset B A m' m
+++++
intro.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).
intro.

*****
H1 : eq (MapCard B m') (MapCard A m)
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
MapSubset B A m' m
+++++
apply (MapSubset_card_eq_1 A B (MapCard A m)).
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).
intro.
apply (MapSubset_card_eq_1 A B (MapCard A m)).

*****
H1 : eq (MapCard B m') (MapCard A m)
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
MapSubset A B m m'
+++++
assumption.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).
intro.
apply (MapSubset_card_eq_1 A B (MapCard A m)).

*****
H1 : eq (MapCard B m') (MapCard A m)
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
eq (MapCard A m) (MapCard A m)
+++++
reflexivity.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).
intro.
apply (MapSubset_card_eq_1 A B (MapCard A m)).

*****
H1 : eq (MapCard B m') (MapCard A m)
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
eq (MapCard B m') (MapCard A m)
+++++
assumption.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).

*****
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
eq (MapCard B m') (MapCard A m)
+++++
apply le_antisym.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).
apply le_antisym.

*****
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard B m') (MapCard A m)
+++++
assumption.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).
apply le_antisym.

*****
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
le (MapCard A m) (MapCard B m')
+++++
apply MapSubset_Card_le.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.
cut (MapCard B m' = MapCard A m).
apply le_antisym.
apply MapSubset_Card_le.

*****
H0 : le (MapCard B m') (MapCard A m)
H : MapSubset A B m m'
m' : Map B
m : Map A
A,B : Type
*****
MapSubset A B m m'
+++++
assumption.
-----
Lemma MapSubset_card_eq : forall (m:Map A) (m':Map B), MapSubset _ _ m m' -> MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').
Proof.
intros.
apply MapSubset_antisym.

*****

*****

+++++
Qed.
-----
End MapCard3.
-----
