Require Export e_sequent_calculus.
-----
Require Import Coq.Arith.Plus Coq.Arith.Le Coq.Arith.Lt.
-----
Set Implicit Arguments.
-----
Module Type cut_mod (B: base_mod) (S: sound_mod B) (C: complete_mod B S) (G: sequent_mod B S C).
-----
Import B S C G.
-----
Reserved Notation "Γ ⊃c A" (at level 80).
-----
Inductive Gcf : list PropF->list PropF->Prop :=\n| Gcax  : forall v Γ Δ      , In #v Γ            -> In #v Δ          -> Γ ⊃c Δ\n| GcBot : forall Γ Δ        , In ⊥ Γ                                 -> Γ ⊃c Δ\n| cAndL : forall A B Γ1 Γ2 Δ, Γ1++A::B::Γ2 ⊃c Δ                      -> Γ1++A∧B::Γ2 ⊃c Δ\n| cAndR : forall A B Γ Δ1 Δ2, Γ ⊃c Δ1++A::Δ2    -> Γ ⊃c Δ1++B::Δ2   -> Γ ⊃c Δ1++A∧B::Δ2\n| cOrL  : forall A B Γ1 Γ2 Δ, Γ1++A::Γ2 ⊃c Δ    -> Γ1++B::Γ2 ⊃c Δ   -> Γ1++A∨B::Γ2 ⊃c Δ\n| cOrR  : forall A B Γ Δ1 Δ2, Γ ⊃c Δ1++A::B::Δ2                      -> Γ ⊃c Δ1++A∨B::Δ2\n| cImpL : forall A B Γ1 Γ2 Δ, Γ1++B::Γ2 ⊃c Δ    -> Γ1++Γ2 ⊃c A::Δ   -> Γ1++A→B::Γ2 ⊃c Δ\n| cImpR : forall A B Γ Δ1 Δ2, A::Γ ⊃c Δ1++B::Δ2                     -> Γ ⊃c Δ1++A→B::Δ2\nwhere "Γ ⊃c Δ" := (Gcf Γ Δ) : My_scope.
-----
Notation "Γ =⊃ Δ" := (forall v,Satisfies v Γ->Validates v Δ) (at level 80).
-----
Inductive Atomic : Set :=\n | AVar : PropVars -> Atomic\n | ABot : Atomic.
-----
Fixpoint AtomicF (P:Atomic) : PropF := match P with\n| AVar P => #P\n| ABot   => ⊥\nend.
-----
Fixpoint size A : nat := match A with\n | # P   => 0\n | ⊥     => 0\n | B ∨ C => S (size B + size C)\n | B ∧ C => S (size B + size C)\n | B → C => S (size B + size C)\nend.
-----
Definition sizel := map_fold_right size plus 0.
-----
Definition sizes Γ Δ:= sizel Γ + sizel Δ.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.

*****

*****
forall (Γ Δ : list PropF) (_ : Gcf Γ Δ), G Γ Δ
+++++
induction 1.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****
v : PropVars
Γ, Δ : list PropF
H : In (Var v) Γ
H0 : In (Var v) Δ
*****
G Γ Δ
+++++
econstructor.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
econstructor.

*****
v : PropVars
Γ, Δ : list PropF
H : In (Var v) Γ
H0 : In (Var v) Δ
*****
In ?A Γ
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
econstructor.

*****
v : PropVars
Γ, Δ : list PropF
H : In (Var v) Γ
H0 : In (Var v) Δ
*****
In (Var v) Δ
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****
Γ, Δ : list PropF
H : In Bot Γ
*****
G Γ Δ
+++++
constructor.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constructor.

*****
Γ, Δ : list PropF
H : In Bot Γ
*****
In Bot Γ
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****
A, B : PropF
Γ1, Γ2, Δ : list PropF
H : Gcf (app Γ1 (cons A (cons B Γ2))) Δ
IHGcf : G (app Γ1 (cons A (cons B Γ2))) Δ
*****
G (app Γ1 (cons (Conj A B) Γ2)) Δ
+++++
constr.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ1, Γ2, Δ : list PropF
H : Gcf (app Γ1 (cons A (cons B Γ2))) Δ
IHGcf : G (app Γ1 (cons A (cons B Γ2))) Δ
*****
G (app Γ1 (cons A (cons B Γ2))) Δ
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****
A, B : PropF
Γ, Δ1, Δ2 : list PropF
H : Gcf Γ (app Δ1 (cons A Δ2))
H0 : Gcf Γ (app Δ1 (cons B Δ2))
IHGcf1 : G Γ (app Δ1 (cons A Δ2))
IHGcf2 : G Γ (app Δ1 (cons B Δ2))
*****
G Γ (app Δ1 (cons (Conj A B) Δ2))
+++++
constr.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ, Δ1, Δ2 : list PropF
H : Gcf Γ (app Δ1 (cons A Δ2))
H0 : Gcf Γ (app Δ1 (cons B Δ2))
IHGcf1 : G Γ (app Δ1 (cons A Δ2))
IHGcf2 : G Γ (app Δ1 (cons B Δ2))
*****
G Γ (app Δ1 (cons A Δ2))
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ, Δ1, Δ2 : list PropF
H : Gcf Γ (app Δ1 (cons A Δ2))
H0 : Gcf Γ (app Δ1 (cons B Δ2))
IHGcf1 : G Γ (app Δ1 (cons A Δ2))
IHGcf2 : G Γ (app Δ1 (cons B Δ2))
*****
G Γ (app Δ1 (cons B Δ2))
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****
A, B : PropF
Γ1, Γ2, Δ : list PropF
H : Gcf (app Γ1 (cons A Γ2)) Δ
H0 : Gcf (app Γ1 (cons B Γ2)) Δ
IHGcf1 : G (app Γ1 (cons A Γ2)) Δ
IHGcf2 : G (app Γ1 (cons B Γ2)) Δ
*****
G (app Γ1 (cons (Disj A B) Γ2)) Δ
+++++
constr.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ1, Γ2, Δ : list PropF
H : Gcf (app Γ1 (cons A Γ2)) Δ
H0 : Gcf (app Γ1 (cons B Γ2)) Δ
IHGcf1 : G (app Γ1 (cons A Γ2)) Δ
IHGcf2 : G (app Γ1 (cons B Γ2)) Δ
*****
G (app Γ1 (cons A Γ2)) Δ
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ1, Γ2, Δ : list PropF
H : Gcf (app Γ1 (cons A Γ2)) Δ
H0 : Gcf (app Γ1 (cons B Γ2)) Δ
IHGcf1 : G (app Γ1 (cons A Γ2)) Δ
IHGcf2 : G (app Γ1 (cons B Γ2)) Δ
*****
G (app Γ1 (cons B Γ2)) Δ
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****
A, B : PropF
Γ, Δ1, Δ2 : list PropF
H : Gcf Γ (app Δ1 (cons A (cons B Δ2)))
IHGcf : G Γ (app Δ1 (cons A (cons B Δ2)))
*****
G Γ (app Δ1 (cons (Disj A B) Δ2))
+++++
constr.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ, Δ1, Δ2 : list PropF
H : Gcf Γ (app Δ1 (cons A (cons B Δ2)))
IHGcf : G Γ (app Δ1 (cons A (cons B Δ2)))
*****
G Γ (app Δ1 (cons A (cons B Δ2)))
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****
A, B : PropF
Γ1, Γ2, Δ : list PropF
H : Gcf (app Γ1 (cons B Γ2)) Δ
H0 : Gcf (app Γ1 Γ2) (cons A Δ)
IHGcf1 : G (app Γ1 (cons B Γ2)) Δ
IHGcf2 : G (app Γ1 Γ2) (cons A Δ)
*****
G (app Γ1 (cons (Impl A B) Γ2)) Δ
+++++
constr.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ1, Γ2, Δ : list PropF
H : Gcf (app Γ1 (cons B Γ2)) Δ
H0 : Gcf (app Γ1 Γ2) (cons A Δ)
IHGcf1 : G (app Γ1 (cons B Γ2)) Δ
IHGcf2 : G (app Γ1 Γ2) (cons A Δ)
*****
G (app Γ1 (cons B Γ2)) Δ
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ1, Γ2, Δ : list PropF
H : Gcf (app Γ1 (cons B Γ2)) Δ
H0 : Gcf (app Γ1 Γ2) (cons A Δ)
IHGcf1 : G (app Γ1 (cons B Γ2)) Δ
IHGcf2 : G (app Γ1 Γ2) (cons A Δ)
*****
G (app Γ1 Γ2) (cons A Δ)
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****
A, B : PropF
Γ, Δ1, Δ2 : list PropF
H : Gcf (cons A Γ) (app Δ1 (cons B Δ2))
IHGcf : G (cons A Γ) (app Δ1 (cons B Δ2))
*****
G Γ (app Δ1 (cons (Impl A B) Δ2))
+++++
constr.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.
constr.

*****
A, B : PropF
Γ, Δ1, Δ2 : list PropF
H : Gcf (cons A Γ) (app Δ1 (cons B Δ2))
IHGcf : G (cons A Γ) (app Δ1 (cons B Δ2))
*****
G (cons A Γ) (app Δ1 (cons B Δ2))
+++++
eassumption.
-----
Theorem G_to_Gcf : forall Γ Δ, Γ ⊃c Δ -> Γ ⊃ Δ.
induction 1.

*****

*****

+++++
Qed.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.

*****

*****
forall (Γ Δ : list PropF) (_ : G Γ Δ) (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v Δ
+++++
intros.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.

*****
Γ, Δ : list PropF
H : G Γ Δ
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
*****
Validates v Δ
+++++
apply G_to_Nc in H.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.

*****
Γ, Δ : list PropF
H : Nc Γ (BigOr Δ)
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
*****
Validates v Δ
+++++
apply Soundness_general in H.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.

*****
Γ, Δ : list PropF
H : Models Γ (BigOr Δ)
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
*****
Validates v Δ
+++++
remember (H v H0).
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).

*****
Γ, Δ : list PropF
H : Models Γ (BigOr Δ)
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr Δ))
Heqi : eq i (H v H0)
*****
Validates v Δ
+++++
clear -i H0.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.

*****
Γ, Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr Δ))
*****
Validates v Δ
+++++
induction Δ.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.

*****
Γ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr nil))
*****
Validates v nil
+++++
contradiction.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr (cons a Δ)))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
*****
Validates v (cons a Δ)
+++++
simpl in i.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (orb (TrueQ v a) (TrueQ v (BigOr Δ)))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
*****
Validates v (cons a Δ)
+++++
case_eq (TrueQ v a).
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (orb (TrueQ v a) (TrueQ v (BigOr Δ)))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
*****
forall _ : eq (TrueQ v a) true, Validates v (cons a Δ)
+++++
intro K.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (orb (TrueQ v a) (TrueQ v (BigOr Δ)))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) true
*****
Validates v (cons a Δ)
+++++
rewrite K in *.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (orb true (TrueQ v (BigOr Δ)))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) true
*****
Validates v (cons a Δ)
+++++
simpl in *.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : True
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) true
*****
Validates v (cons a Δ)
+++++
exists a.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.
exists a.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : True
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) true
*****
and (In a (cons a Δ)) (Is_true (TrueQ v a))
+++++
split.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.
exists a.
split.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : True
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) true
*****
In a (cons a Δ)
+++++
in_solve.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.
exists a.
split.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : True
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) true
*****
Is_true (TrueQ v a)
+++++
rewrite K.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.
exists a.
split.
rewrite K.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : True
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) true
*****
Is_true true
+++++
trivial.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (orb (TrueQ v a) (TrueQ v (BigOr Δ)))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
*****
forall _ : eq (TrueQ v a) false, Validates v (cons a Δ)
+++++
intro K.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (orb (TrueQ v a) (TrueQ v (BigOr Δ)))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) false
*****
Validates v (cons a Δ)
+++++
rewrite K in *.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (orb false (TrueQ v (BigOr Δ)))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) false
*****
Validates v (cons a Δ)
+++++
simpl in *.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr Δ))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) false
*****
Validates v (cons a Δ)
+++++
destruct (IHΔ i) as (?&?&?).
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.
destruct (IHΔ i) as (?&?&?).

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr Δ))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) false
x : PropF
H : In x Δ
H1 : Is_true (TrueQ v x)
*****
Validates v (cons a Δ)
+++++
exists x.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.
destruct (IHΔ i) as (?&?&?).
exists x.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr Δ))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) false
x : PropF
H : In x Δ
H1 : Is_true (TrueQ v x)
*****
and (In x (cons a Δ)) (Is_true (TrueQ v x))
+++++
split.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.
destruct (IHΔ i) as (?&?&?).
exists x.
split.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr Δ))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) false
x : PropF
H : In x Δ
H1 : Is_true (TrueQ v x)
*****
In x (cons a Δ)
+++++
in_solve.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.
simpl in i.
case_eq (TrueQ v a).
intro K.
rewrite K in *.
simpl in *.
destruct (IHΔ i) as (?&?&?).
exists x.
split.

*****
Γ : list PropF
a : PropF
Δ : list PropF
v : forall _ : PropVars, bool
H0 : Satisfies v Γ
i : Is_true (TrueQ v (BigOr Δ))
IHΔ : forall _ : Is_true (TrueQ v (BigOr Δ)), Validates v Δ
K : eq (TrueQ v a) false
x : PropF
H : In x Δ
H1 : Is_true (TrueQ v x)
*****
Is_true (TrueQ v x)
+++++
assumption.
-----
Theorem G_sound : forall Γ Δ, Γ ⊃ Δ -> Γ =⊃ Δ.
intros.
apply G_to_Nc in H.
apply Soundness_general in H.
remember (H v H0).
clear -i H0.
induction Δ.

*****

*****

+++++
Qed.
-----
Lemma Atomic_eqdec : forall x y : Atomic, {x = y} + {x <> y}.
-----
Lemma Atomic_eqdec : forall x y : Atomic, {x = y} + {x <> y}.

*****

*****
forall x y : Atomic, sumbool (eq x y) (not (eq x y))
+++++
intros;destruct x;destruct y;try (right;discriminate);try (left;reflexivity); destruct (Varseq_dec p p0); (left;f_equal;assumption)||(right;intro HH;injection HH;contradiction).
-----
Lemma Atomic_eqdec : forall x y : Atomic, {x = y} + {x <> y}.
intros;destruct x;destruct y;try (right;discriminate);try (left;reflexivity); destruct (Varseq_dec p p0); (left;f_equal;assumption)||(right;intro HH;injection HH;contradiction).

*****

*****

+++++
Qed.
-----
Lemma sizes_comm : forall Γ Δ, sizes Γ Δ = sizes Δ Γ.
-----
Lemma sizes_comm : forall Γ Δ, sizes Γ Δ = sizes Δ Γ.

*****

*****
forall Γ Δ : list PropF, eq (sizes Γ Δ) (sizes Δ Γ)
+++++
intros.
-----
Lemma sizes_comm : forall Γ Δ, sizes Γ Δ = sizes Δ Γ.
intros.

*****
Γ, Δ : list PropF
*****
eq (sizes Γ Δ) (sizes Δ Γ)
+++++
unfold sizes.
-----
Lemma sizes_comm : forall Γ Δ, sizes Γ Δ = sizes Δ Γ.
intros.
unfold sizes.

*****
Γ, Δ : list PropF
*****
eq (Nat.add (sizel Γ) (sizel Δ)) (Nat.add (sizel Δ) (sizel Γ))
+++++
apply plus_comm.
-----
Lemma sizes_comm : forall Γ Δ, sizes Γ Δ = sizes Δ Γ.
intros.
unfold sizes.
apply plus_comm.

*****

*****

+++++
Qed.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.

*****

*****
forall (Γ1 Γ2 : list PropF) (A : PropF) (Δ : list PropF), eq (sizes (app Γ1 Γ2) (cons A Δ)) (sizes (app Γ1 (cons A Γ2)) Δ)
+++++
intros.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.

*****
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (sizes (app Γ1 Γ2) (cons A Δ)) (sizes (app Γ1 (cons A Γ2)) Δ)
+++++
induction Γ1.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.

*****
Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (sizes (app nil Γ2) (cons A Δ)) (sizes (app nil (cons A Γ2)) Δ)
+++++
unfold sizes.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.

*****
Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (Nat.add (sizel (app nil Γ2)) (sizel (cons A Δ))) (Nat.add (sizel (app nil (cons A Γ2))) (sizel Δ))
+++++
unfold sizel.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.
unfold sizel.

*****
Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (Nat.add (map_fold_right size Nat.add O (app nil Γ2)) (map_fold_right size Nat.add O (cons A Δ))) (Nat.add (map_fold_right size Nat.add O (app nil (cons A Γ2))) (map_fold_right size Nat.add O Δ))
+++++
simpl.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.
unfold sizel.
simpl.

*****
Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (Nat.add (map_fold_right size Nat.add O Γ2) (Nat.add (size A) (map_fold_right size Nat.add O Δ))) (Nat.add (Nat.add (size A) (map_fold_right size Nat.add O Γ2)) (map_fold_right size Nat.add O Δ))
+++++
rewrite plus_assoc.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.
unfold sizel.
simpl.
rewrite plus_assoc.

*****
Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (PeanoNat.Nat.add (PeanoNat.Nat.add (map_fold_right size Nat.add O Γ2) (size A)) (map_fold_right size Nat.add O Δ)) (Nat.add (Nat.add (size A) (map_fold_right size Nat.add O Γ2)) (map_fold_right size Nat.add O Δ))
+++++
f_equal.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.
unfold sizel.
simpl.
rewrite plus_assoc.
f_equal.

*****
Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (PeanoNat.Nat.add (map_fold_right size Nat.add O Γ2) (size A)) (Nat.add (size A) (map_fold_right size Nat.add O Γ2))
+++++
apply plus_comm.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.

*****
a : PropF
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
IHΓ1 : eq (sizes (app Γ1 Γ2) (cons A Δ))\n (sizes (app Γ1 (cons A Γ2)) Δ)
*****
eq (sizes (app (cons a Γ1) Γ2) (cons A Δ)) (sizes (app (cons a Γ1) (cons A Γ2)) Δ)
+++++
unfold sizes.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.

*****
a : PropF
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
IHΓ1 : eq (sizes (app Γ1 Γ2) (cons A Δ))\n (sizes (app Γ1 (cons A Γ2)) Δ)
*****
eq (Nat.add (sizel (app (cons a Γ1) Γ2)) (sizel (cons A Δ))) (Nat.add (sizel (app (cons a Γ1) (cons A Γ2))) (sizel Δ))
+++++
unfold sizel.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.
unfold sizel.

*****
a : PropF
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
IHΓ1 : eq (sizes (app Γ1 Γ2) (cons A Δ))\n (sizes (app Γ1 (cons A Γ2)) Δ)
*****
eq (Nat.add (map_fold_right size Nat.add O (app (cons a Γ1) Γ2)) (map_fold_right size Nat.add O (cons A Δ))) (Nat.add (map_fold_right size Nat.add O (app (cons a Γ1) (cons A Γ2))) (map_fold_right size Nat.add O Δ))
+++++
simpl.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.
unfold sizel.
simpl.

*****
a : PropF
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
IHΓ1 : eq (sizes (app Γ1 Γ2) (cons A Δ))\n (sizes (app Γ1 (cons A Γ2)) Δ)
*****
eq (Nat.add (Nat.add (size a) (map_fold_right size Nat.add O (app Γ1 Γ2))) (Nat.add (size A) (map_fold_right size Nat.add O Δ))) (Nat.add (Nat.add (size a) (map_fold_right size Nat.add O (app Γ1 (cons A Γ2)))) (map_fold_right size Nat.add O Δ))
+++++
rewrite <- !plus_assoc.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.
unfold sizel.
simpl.
rewrite <- !plus_assoc.

*****
a : PropF
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
IHΓ1 : eq (sizes (app Γ1 Γ2) (cons A Δ))\n (sizes (app Γ1 (cons A Γ2)) Δ)
*****
eq (PeanoNat.Nat.add (size a) (PeanoNat.Nat.add (map_fold_right size Nat.add O (app Γ1 Γ2)) (Nat.add (size A) (map_fold_right size Nat.add O Δ)))) (PeanoNat.Nat.add (size a) (PeanoNat.Nat.add (map_fold_right size Nat.add O (app Γ1 (cons A Γ2))) (map_fold_right size Nat.add O Δ)))
+++++
f_equal.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.
unfold sizes.
unfold sizel.
simpl.
rewrite <- !plus_assoc.
f_equal.

*****
a : PropF
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
IHΓ1 : eq (sizes (app Γ1 Γ2) (cons A Δ))\n (sizes (app Γ1 (cons A Γ2)) Δ)
*****
eq (PeanoNat.Nat.add (map_fold_right size Nat.add O (app Γ1 Γ2)) (Nat.add (size A) (map_fold_right size Nat.add O Δ))) (PeanoNat.Nat.add (map_fold_right size Nat.add O (app Γ1 (cons A Γ2))) (map_fold_right size Nat.add O Δ))
+++++
apply IHΓ1.
-----
Lemma sizes_comm_r : forall Γ1 Γ2 A Δ, sizes (Γ1 ++ Γ2) (A :: Δ) = sizes (Γ1 ++ A::Γ2) Δ.
intros.
induction Γ1.

*****

*****

+++++
Qed.
-----
Lemma sizes_comm_l : forall Γ1 Γ2 A Δ, sizes (A :: Δ) (Γ1 ++ Γ2) = sizes Δ (Γ1 ++ A::Γ2).
-----
Lemma sizes_comm_l : forall Γ1 Γ2 A Δ, sizes (A :: Δ) (Γ1 ++ Γ2) = sizes Δ (Γ1 ++ A::Γ2).

*****

*****
forall (Γ1 Γ2 : list PropF) (A : PropF) (Δ : list PropF), eq (sizes (cons A Δ) (app Γ1 Γ2)) (sizes Δ (app Γ1 (cons A Γ2)))
+++++
intros.
-----
Lemma sizes_comm_l : forall Γ1 Γ2 A Δ, sizes (A :: Δ) (Γ1 ++ Γ2) = sizes Δ (Γ1 ++ A::Γ2).
intros.

*****
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (sizes (cons A Δ) (app Γ1 Γ2)) (sizes Δ (app Γ1 (cons A Γ2)))
+++++
rewrite sizes_comm.
-----
Lemma sizes_comm_l : forall Γ1 Γ2 A Δ, sizes (A :: Δ) (Γ1 ++ Γ2) = sizes Δ (Γ1 ++ A::Γ2).
intros.
rewrite sizes_comm.

*****
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (sizes (app Γ1 Γ2) (cons A Δ)) (sizes Δ (app Γ1 (cons A Γ2)))
+++++
rewrite sizes_comm_r.
-----
Lemma sizes_comm_l : forall Γ1 Γ2 A Δ, sizes (A :: Δ) (Γ1 ++ Γ2) = sizes Δ (Γ1 ++ A::Γ2).
intros.
rewrite sizes_comm.
rewrite sizes_comm_r.

*****
Γ1, Γ2 : list PropF
A : PropF
Δ : list PropF
*****
eq (sizes (app Γ1 (cons A Γ2)) Δ) (sizes Δ (app Γ1 (cons A Γ2)))
+++++
apply sizes_comm.
-----
Lemma sizes_comm_l : forall Γ1 Γ2 A Δ, sizes (A :: Δ) (Γ1 ++ Γ2) = sizes Δ (Γ1 ++ A::Γ2).
intros.
rewrite sizes_comm.
rewrite sizes_comm_r.
apply sizes_comm.

*****

*****

+++++
Qed.
-----
Lemma le_plus_trans_r : forall n m p, n <= m -> n <= p + m.
-----
Lemma le_plus_trans_r : forall n m p, n <= m -> n <= p + m.

*****

*****
forall (n m p : nat) (_ : le n m), le n (Nat.add p m)
+++++
intros.
-----
Lemma le_plus_trans_r : forall n m p, n <= m -> n <= p + m.
intros.

*****
H : le n m
n,m,p : nat
*****
le n (Nat.add p m)
+++++
rewrite plus_comm.
-----
Lemma le_plus_trans_r : forall n m p, n <= m -> n <= p + m.
intros.
rewrite plus_comm.

*****
H : le n m
n,m,p : nat
*****
le n (PeanoNat.Nat.add m p)
+++++
apply le_plus_trans.
-----
Lemma le_plus_trans_r : forall n m p, n <= m -> n <= p + m.
intros.
rewrite plus_comm.
apply le_plus_trans.

*****
H : le n m
n,m,p : nat
*****
le n m
+++++
assumption.
-----
Lemma le_plus_trans_r : forall n m p, n <= m -> n <= p + m.
intros.
rewrite plus_comm.
apply le_plus_trans.
assumption.

*****

*****

+++++
Qed.
-----
Lemma sizes_decr : \n (forall A B Γ1 Γ2 Δ, sizes (Γ1++A::B::Γ2) Δ < sizes (Γ1++A∧B::Γ2) Δ)/\\n (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++A::Δ2)    < sizes Γ (Δ1++A∧B::Δ2))/\\n (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++B::Δ2)    < sizes Γ (Δ1++A∧B::Δ2))/\\n (forall A B Γ1 Γ2 Δ, sizes (Γ1++A::Γ2) Δ    < sizes (Γ1++A∨B::Γ2) Δ)/\\n (forall A B Γ1 Γ2 Δ, sizes (Γ1++B::Γ2) Δ    < sizes (Γ1++A∨B::Γ2) Δ)/\\n (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++A::B::Δ2) < sizes Γ (Δ1++A∨B::Δ2))/\\n (forall A B Γ1 Γ2 Δ, sizes (Γ1++B::Γ2)  Δ   < sizes (Γ1++A→B::Γ2) Δ)/\\n (forall A B Γ1 Γ2 Δ, sizes (Γ1++Γ2) (A::Δ)  < sizes (Γ1++A→B::Γ2) Δ)/\\n (forall A B Γ Δ1 Δ2, sizes (A::Γ)(Δ1++B::Δ2)< sizes Γ (Δ1++A→B::Δ2)).
-----
Lemma sizes_decr : (forall A B Γ1 Γ2 Δ, sizes (Γ1++A::B::Γ2) Δ < sizes (Γ1++A∧B::Γ2) Δ)/\\ (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++A::Δ2) < sizes Γ (Δ1++A∧B::Δ2))/\\ (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++B::Δ2) < sizes Γ (Δ1++A∧B::Δ2))/\\ (forall A B Γ1 Γ2 Δ, sizes (Γ1++A::Γ2) Δ < sizes (Γ1++A∨B::Γ2) Δ)/\\ (forall A B Γ1 Γ2 Δ, sizes (Γ1++B::Γ2) Δ < sizes (Γ1++A∨B::Γ2) Δ)/\\ (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++A::B::Δ2) < sizes Γ (Δ1++A∨B::Δ2))/\\ (forall A B Γ1 Γ2 Δ, sizes (Γ1++B::Γ2) Δ < sizes (Γ1++A→B::Γ2) Δ)/\\ (forall A B Γ1 Γ2 Δ, sizes (Γ1++Γ2) (A::Δ) < sizes (Γ1++A→B::Γ2) Δ)/\\ (forall A B Γ Δ1 Δ2, sizes (A::Γ)(Δ1++B::Δ2)< sizes Γ (Δ1++A→B::Δ2)).

*****

*****
and (forall (A B : PropF) (Γ1 Γ2 Δ : list PropF), lt (sizes (app Γ1 (cons A (cons B Γ2))) Δ) (sizes (app Γ1 (cons (Conj A B) Γ2)) Δ)) (and (forall (A B : PropF) (Γ Δ1 Δ2 : list PropF), lt (sizes Γ (app Δ1 (cons A Δ2))) (sizes Γ (app Δ1 (cons (Conj A B) Δ2)))) (and (forall (A B : PropF) (Γ Δ1 Δ2 : list PropF), lt (sizes Γ (app Δ1 (cons B Δ2))) (sizes Γ (app Δ1 (cons (Conj A B) Δ2)))) (and (forall (A B : PropF) (Γ1 Γ2 Δ : list PropF), lt (sizes (app Γ1 (cons A Γ2)) Δ) (sizes (app Γ1 (cons (Disj A B) Γ2)) Δ)) (and (forall (A B : PropF) (Γ1 Γ2 Δ : list PropF), lt (sizes (app Γ1 (cons B Γ2)) Δ) (sizes (app Γ1 (cons (Disj A B) Γ2)) Δ)) (and (forall (A B : PropF) (Γ Δ1 Δ2 : list PropF), lt (sizes Γ (app Δ1 (cons A (cons B Δ2)))) (sizes Γ (app Δ1 (cons (Disj A B) Δ2)))) (and (forall (A B : PropF) (Γ1 Γ2 Δ : list PropF), lt (sizes (app Γ1 (cons B Γ2)) Δ) (sizes (app Γ1 (cons (Impl A B) Γ2)) Δ)) (and (forall (A B : PropF) (Γ1 Γ2 Δ : list PropF), lt (sizes (app Γ1 Γ2) (cons A Δ)) (sizes (app Γ1 (cons (Impl A B) Γ2)) Δ)) (forall (A B : PropF) (Γ Δ1 Δ2 : list PropF), lt (sizes (cons A Γ) (app Δ1 (cons B Δ2))) (sizes Γ (app Δ1 (cons (Impl A B) Δ2)))))))))))
+++++
repeat split;intros;try (rewrite sizes_comm_l||rewrite sizes_comm_r); apply plus_lt_compat_l||apply plus_lt_compat_r;induction Γ1||induction Δ1; unfold sizel;simpl;try (apply plus_lt_compat_l;apply IHΓ1||apply IHΔ1); apply le_lt_n_Sm;rewrite <- plus_assoc;try constructor; try apply plus_le_compat_l;apply le_plus_trans_r;constructor.
-----
Lemma sizes_decr : (forall A B Γ1 Γ2 Δ, sizes (Γ1++A::B::Γ2) Δ < sizes (Γ1++A∧B::Γ2) Δ)/\\ (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++A::Δ2) < sizes Γ (Δ1++A∧B::Δ2))/\\ (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++B::Δ2) < sizes Γ (Δ1++A∧B::Δ2))/\\ (forall A B Γ1 Γ2 Δ, sizes (Γ1++A::Γ2) Δ < sizes (Γ1++A∨B::Γ2) Δ)/\\ (forall A B Γ1 Γ2 Δ, sizes (Γ1++B::Γ2) Δ < sizes (Γ1++A∨B::Γ2) Δ)/\\ (forall A B Γ Δ1 Δ2, sizes Γ (Δ1++A::B::Δ2) < sizes Γ (Δ1++A∨B::Δ2))/\\ (forall A B Γ1 Γ2 Δ, sizes (Γ1++B::Γ2) Δ < sizes (Γ1++A→B::Γ2) Δ)/\\ (forall A B Γ1 Γ2 Δ, sizes (Γ1++Γ2) (A::Δ) < sizes (Γ1++A→B::Γ2) Δ)/\\ (forall A B Γ Δ1 Δ2, sizes (A::Γ)(Δ1++B::Δ2)< sizes Γ (Δ1++A→B::Δ2)).
repeat split;intros;try (rewrite sizes_comm_l||rewrite sizes_comm_r); apply plus_lt_compat_l||apply plus_lt_compat_r;induction Γ1||induction Δ1; unfold sizel;simpl;try (apply plus_lt_compat_l;apply IHΓ1||apply IHΔ1); apply le_lt_n_Sm;rewrite <- plus_assoc;try constructor; try apply plus_le_compat_l;apply le_plus_trans_r;constructor.

*****

*****

+++++
Qed.
-----
Lemma size_O_atomic : forall Γ, sizel Γ=0 -> exists l, Γ = map AtomicF l.
-----
Lemma size_O_atomic : forall Γ, sizel Γ=0 -> exists l, Γ = map AtomicF l.

*****

*****
forall (Γ : list PropF) (_ : eq (sizel Γ) O), ex (fun l : list Atomic => eq Γ (map AtomicF l))
+++++
intros;induction Γ.
-----
Lemma size_O_atomic : forall Γ, sizel Γ=0 -> exists l, Γ = map AtomicF l.
intros;induction Γ.

*****
H : eq (sizel nil) O
*****
ex (fun l : list Atomic => eq nil (map AtomicF l))
+++++
exists [];reflexivity.
-----
Lemma size_O_atomic : forall Γ, sizel Γ=0 -> exists l, Γ = map AtomicF l.
intros;induction Γ.
exists [];reflexivity.

*****
a : PropF
Γ : list PropF
H : eq (sizel (cons a Γ)) O
IHΓ : forall _ : eq (sizel Γ) O,\n ex (fun l : list Atomic => eq Γ (map AtomicF l))
*****
ex (fun l : list Atomic => eq (cons a Γ) (map AtomicF l))
+++++
destruct a;try (apply plus_is_O in H as (?&_);simpl in H;discriminate); unfold sizel in H;simpl in H; destruct (IHΓ H);[exists (AVar p::x)|exists (ABot::x)];simpl;f_equal;assumption.
-----
Lemma size_O_atomic : forall Γ, sizel Γ=0 -> exists l, Γ = map AtomicF l.
intros;induction Γ.
exists [];reflexivity.
destruct a;try (apply plus_is_O in H as (?&_);simpl in H;discriminate); unfold sizel in H;simpl in H; destruct (IHΓ H);[exists (AVar p::x)|exists (ABot::x)];simpl;f_equal;assumption.

*****

*****

+++++
Qed.
-----
Ltac temp4 := try contradiction;do 2 econstructor;repeat ((left;in_solve;fail)||right);in_solve.
-----
Lemma bool_false : forall b, b=false -> ~Is_true b.
-----
Lemma bool_false : forall b, b=false -> ~Is_true b.

*****

*****
forall (b : bool) (_ : eq b false), not (Is_true b)
+++++
intros.
-----
Lemma bool_false : forall b, b=false -> ~Is_true b.
intros.

*****
H : eq b false
b : bool
*****
not (Is_true b)
+++++
subst.
-----
Lemma bool_false : forall b, b=false -> ~Is_true b.
intros.
subst.

*****

*****
not (Is_true false)
+++++
auto.
-----
Lemma bool_false : forall b, b=false -> ~Is_true b.
intros.
subst.
auto.

*****

*****

+++++
Qed.
-----
Lemma size_S : forall n Γ Δ, sizes Γ Δ = S n -> exists A B, \nIn (A→B) Γ \/ In (A→B) Δ \/ In (A∨B) Γ \/ In (A∨B) Δ \/ In (A∧B) Γ \/ In (A∧B) Δ.
-----
Lemma size_S : forall n Γ Δ, sizes Γ Δ = S n -> exists A B, In (A→B) Γ \\/ In (A→B) Δ \\/ In (A∨B) Γ \\/ In (A∨B) Δ \\/ In (A∧B) Γ \\/ In (A∧B) Δ.

*****

*****
forall (n : nat) (Γ Δ : list PropF) (_ : eq (sizes Γ Δ) (S n)), ex (fun A : PropF => ex (fun B : PropF => or (In (Impl A B) Γ) (or (In (Impl A B) Δ) (or (In (Disj A B) Γ) (or (In (Disj A B) Δ) (or (In (Conj A B) Γ) (In (Conj A B) Δ)))))))
+++++
intros.
-----
Lemma size_S : forall n Γ Δ, sizes Γ Δ = S n -> exists A B, In (A→B) Γ \\/ In (A→B) Δ \\/ In (A∨B) Γ \\/ In (A∨B) Δ \\/ In (A∧B) Γ \\/ In (A∧B) Δ.
intros.

*****
n : nat
Γ, Δ : list PropF
H : eq (sizes Γ Δ) (S n)
*****
ex (fun A : PropF => ex (fun B : PropF => or (In (Impl A B) Γ) (or (In (Impl A B) Δ) (or (In (Disj A B) Γ) (or (In (Disj A B) Δ) (or (In (Conj A B) Γ) (In (Conj A B) Δ)))))))
+++++
induction Γ;[unfold sizes in H;simpl in H;induction Δ;[discriminate|]|]; (destruct a;[| |temp4..]);unfold sizel in H;simpl in H; destruct (IHΔ H) as (?&?&[|[|[|[|[]]]]])||destruct (IHΓ H) as (?&?&[|[|[|[|[]]]]]);temp4.
-----
Lemma size_S : forall n Γ Δ, sizes Γ Δ = S n -> exists A B, In (A→B) Γ \\/ In (A→B) Δ \\/ In (A∨B) Γ \\/ In (A∨B) Δ \\/ In (A∧B) Γ \\/ In (A∧B) Δ.
intros.
induction Γ;[unfold sizes in H;simpl in H;induction Δ;[discriminate|]|]; (destruct a;[| |temp4..]);unfold sizel in H;simpl in H; destruct (IHΔ H) as (?&?&[|[|[|[|[]]]]])||destruct (IHΓ H) as (?&?&[|[|[|[|[]]]]]);temp4.

*****

*****

+++++
Qed.
-----
Ltac temp5 A B Hy := let C:= fresh "C" with K1 := fresh "K" with K2 := fresh "KK" in\nintros v L;case_eq (TrueQ v A);case_eq (TrueQ v B);intros K1 K2;\ntry (exists A;split;[in_solve|rewrite K2;simpl;exact I];fail);\ntry (exists B;split;[in_solve|rewrite K1;simpl;exact I];fail);\ntry (exfalso;apply (bool_false K1);apply L;in_solve;fail);\ntry (exfalso;apply (bool_false K2);apply L;in_solve;fail);\n(destruct (Hy v) as (C&?&?);\n[intros ? ?;in_solve;try (apply L;in_solve;fail);\nsimpl;try rewrite K1;try rewrite K2;simpl;exact I|\nin_solve;try (exists C;split;[in_solve|assumption];fail);\nsimpl in *;rewrite K1 in *;rewrite K2 in *;simpl in *;contradiction\n]).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.

*****

*****
forall (n : nat) (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n) (_ : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v Δ), Gcf Γ Δ
+++++
induction n.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.

*****

*****
forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) O) (_ : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v Δ), Gcf Γ Δ
+++++
intros.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.

*****
Γ, Δ : list PropF
H : le (sizes Γ Δ) O
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
*****
Gcf Γ Δ
+++++
inversion H.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.

*****
Γ, Δ : list PropF
H : le (sizes Γ Δ) O
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) O
*****
Gcf Γ Δ
+++++
apply plus_is_O in H2 as (?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).

*****
Γ, Δ : list PropF
H : le (sizes Γ Δ) O
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H1 : eq (sizel Γ) O
H2 : eq (sizel Δ) O
*****
Gcf Γ Δ
+++++
apply size_O_atomic in H1 as (?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).

*****
Γ, Δ : list PropF
H : le (sizes Γ Δ) O
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
x : list Atomic
H1 : eq Γ (map AtomicF x)
H2 : eq (sizel Δ) O
*****
Gcf Γ Δ
+++++
apply size_O_atomic in H2 as (?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).

*****
Γ, Δ : list PropF
H : le (sizes Γ Δ) O
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
x : list Atomic
H1 : eq Γ (map AtomicF x)
x0 : list Atomic
H2 : eq Δ (map AtomicF x0)
*****
Gcf Γ Δ
+++++
subst.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
destruct (in_dec Atomic_eqdec ABot x).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
i : In ABot x
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
constructor 2.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
constructor 2.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
i : In ABot x
*****
In Bot (map AtomicF x)
+++++
change ⊥ with (AtomicF ABot).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
constructor 2.
change ⊥ with (AtomicF ABot).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
i : In ABot x
*****
In (AtomicF ABot) (map AtomicF x)
+++++
eapply in_map.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
constructor 2.
change ⊥ with (AtomicF ABot).
eapply in_map.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
i : In ABot x
*****
In ABot x
+++++
assumption.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
destruct (H0 v) as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
*****
Satisfies v (map AtomicF x)
+++++
intros ? ?.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
A : PropF
H1 : In A (map AtomicF x)
*****
Is_true (TrueQ v A)
+++++
apply in_map_iff in H1 as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
A : PropF
x1 : Atomic
H1 : eq (AtomicF x1) A
H2 : In x1 x
*****
Is_true (TrueQ v A)
+++++
subst A.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).
subst A.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
x1 : Atomic
H2 : In x1 x
*****
Is_true (TrueQ v (AtomicF x1))
+++++
simpl.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).
subst A.
simpl.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
x1 : Atomic
H2 : In x1 x
*****
Is_true (TrueQ v (AtomicF x1))
+++++
destruct x1.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).
subst A.
simpl.
destruct x1.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H2 : In (AVar p) x
*****
Is_true (TrueQ v (AtomicF (AVar p)))
+++++
rewrite Heqv.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).
subst A.
simpl.
destruct x1.
rewrite Heqv.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H2 : In (AVar p) x
*****
Is_true (TrueQ (fun P : PropVars => if in_dec Atomic_eqdec (AVar P) x then true else false) (AtomicF (AVar p)))
+++++
simpl.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).
subst A.
simpl.
destruct x1.
rewrite Heqv.
simpl.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H2 : In (AVar p) x
*****
Is_true (if in_dec Atomic_eqdec (AVar p) x then true else false)
+++++
destruct (in_dec Atomic_eqdec (AVar p) x).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).
subst A.
simpl.
destruct x1.
rewrite Heqv.
simpl.
destruct (in_dec Atomic_eqdec (AVar p) x).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H2, i : In (AVar p) x
*****
Is_true true
+++++
exact I.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).
subst A.
simpl.
destruct x1.
rewrite Heqv.
simpl.
destruct (in_dec Atomic_eqdec (AVar p) x).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H2 : In (AVar p) x
n0 : not (In (AVar p) x)
*****
Is_true false
+++++
contradiction.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
intros ? ?.
apply in_map_iff in H1 as (?&?&?).
subst A.
simpl.
destruct x1.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
H2 : In ABot x
*****
Is_true (TrueQ v (AtomicF ABot))
+++++
contradiction.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
x1 : PropF
H1 : In x1 (map AtomicF x0)
H2 : Is_true (TrueQ v x1)
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
apply in_map_iff in H1 as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
x1 : PropF
x2 : Atomic
H1 : eq (AtomicF x2) x1
H3 : In x2 x0
H2 : Is_true (TrueQ v x1)
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
subst x1.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
x2 : Atomic
H3 : In x2 x0
H2 : Is_true (TrueQ v (AtomicF x2))
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
destruct x2.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (TrueQ v (AtomicF (AVar p)))
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
constructor 1 with p.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (TrueQ v (AtomicF (AVar p)))
*****
In (Var p) (map AtomicF x)
+++++
change #p with (AtomicF (AVar p)).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.
change #p with (AtomicF (AVar p)).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (TrueQ v (AtomicF (AVar p)))
*****
In (AtomicF (AVar p)) (map AtomicF x)
+++++
apply in_map.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.
change #p with (AtomicF (AVar p)).
apply in_map.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (TrueQ v (AtomicF (AVar p)))
*****
In (AVar p) x
+++++
simpl in H2.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.
change #p with (AtomicF (AVar p)).
apply in_map.
simpl in H2.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (v p)
*****
In (AVar p) x
+++++
rewrite Heqv in H2.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.
change #p with (AtomicF (AVar p)).
apply in_map.
simpl in H2.
rewrite Heqv in H2.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (if in_dec Atomic_eqdec (AVar p) x then true else false)
*****
In (AVar p) x
+++++
destruct (in_dec Atomic_eqdec (AVar p)).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.
change #p with (AtomicF (AVar p)).
apply in_map.
simpl in H2.
rewrite Heqv in H2.
destruct (in_dec Atomic_eqdec (AVar p)).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
i : In (AVar p) x
H2 : Is_true true
*****
In (AVar p) x
+++++
assumption.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.
change #p with (AtomicF (AVar p)).
apply in_map.
simpl in H2.
rewrite Heqv in H2.
destruct (in_dec Atomic_eqdec (AVar p)).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
n0 : not (In (AVar p) x)
H2 : Is_true false
*****
In (AVar p) x
+++++
contradiction.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (TrueQ v (AtomicF (AVar p)))
*****
In (Var p) (map AtomicF x0)
+++++
change #p with (AtomicF (AVar p)).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.
change #p with (AtomicF (AVar p)).

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (TrueQ v (AtomicF (AVar p)))
*****
In (AtomicF (AVar p)) (map AtomicF x0)
+++++
apply in_map.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.
constructor 1 with p.
change #p with (AtomicF (AVar p)).
apply in_map.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
p : PropVars
H3 : In (AVar p) x0
H2 : Is_true (TrueQ v (AtomicF (AVar p)))
*****
In (AVar p) x0
+++++
assumption.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply plus_is_O in H2 as (?&?).
apply size_O_atomic in H1 as (?&?).
apply size_O_atomic in H2 as (?&?).
subst.
remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.
destruct (in_dec Atomic_eqdec ABot x).
destruct (H0 v) as (?&?&?).
apply in_map_iff in H1 as (?&?&?).
subst x1.
destruct x2.

*****
x, x0 : list Atomic
H : le (sizes (map AtomicF x) (map AtomicF x0)) O
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (map AtomicF x)),\n Validates v (map AtomicF x0)
v : forall _ : PropVars, bool
Heqv : eq v\n (fun P : PropVars =>\n if in_dec Atomic_eqdec (AVar P) x then true else false)
n : not (In ABot x)
H3 : In ABot x0
H2 : Is_true (TrueQ v (AtomicF ABot))
*****
Gcf (map AtomicF x) (map AtomicF x0)
+++++
contradiction.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
*****
forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) (S n)) (_ : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v Δ), Gcf Γ Δ
+++++
intros.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H : le (sizes Γ Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
*****
Gcf Γ Δ
+++++
inversion H.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H : le (sizes Γ Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
*****
Gcf Γ Δ
+++++
clear H.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
*****
Gcf Γ Δ
+++++
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
H : In (Impl A B) Γ
*****
Gcf Γ Δ
+++++
apply in_split in H as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
x, x0 : list PropF
H : eq Γ (app x (cons (Impl A B) x0))
*****
Gcf Γ Δ
+++++
subst.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
Gcf (app x (cons (Impl A B) x0)) Δ
+++++
constr.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
Gcf (app x (cons B x0)) Δ
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
le (sizes (app x (cons B x0)) Δ) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x (cons B x0))), Validates v Δ
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x (cons B x0))), Validates v Δ
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
Gcf (app x x0) (cons A Δ)
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
le (sizes (app x x0) (cons A Δ)) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x x0)), Validates v (cons A Δ)
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Impl A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Impl A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x x0)), Validates v (cons A Δ)
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
H : In (Impl A B) Δ
*****
Gcf Γ Δ
+++++
apply in_split in H as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
x, x0 : list PropF
H : eq Δ (app x (cons (Impl A B) x0))
*****
Gcf Γ Δ
+++++
subst.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Impl A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Impl A B) x0))
*****
Gcf Γ (app x (cons (Impl A B) x0))
+++++
constr.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Impl A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Impl A B) x0))
*****
Gcf (cons A Γ) (app x (cons B x0))
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Impl A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Impl A B) x0))
*****
le (sizes (cons A Γ) (app x (cons B x0))) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Impl A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Impl A B) x0))
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (cons A Γ)), Validates v (app x (cons B x0))
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Impl A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Impl A B) x0))
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (cons A Γ)), Validates v (app x (cons B x0))
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
H : In (Disj A B) Γ
*****
Gcf Γ Δ
+++++
apply in_split in H as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
x, x0 : list PropF
H : eq Γ (app x (cons (Disj A B) x0))
*****
Gcf Γ Δ
+++++
subst.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
Gcf (app x (cons (Disj A B) x0)) Δ
+++++
constr.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
Gcf (app x (cons A x0)) Δ
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
le (sizes (app x (cons A x0)) Δ) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x (cons A x0))), Validates v Δ
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x (cons A x0))), Validates v Δ
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
Gcf (app x (cons B x0)) Δ
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
le (sizes (app x (cons B x0)) Δ) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x (cons B x0))), Validates v Δ
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Disj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Disj A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x (cons B x0))), Validates v Δ
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
H : In (Disj A B) Δ
*****
Gcf Γ Δ
+++++
apply in_split in H as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
x, x0 : list PropF
H : eq Δ (app x (cons (Disj A B) x0))
*****
Gcf Γ Δ
+++++
subst.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Disj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Disj A B) x0))
*****
Gcf Γ (app x (cons (Disj A B) x0))
+++++
constr.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Disj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Disj A B) x0))
*****
Gcf Γ (app x (cons A (cons B x0)))
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Disj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Disj A B) x0))
*****
le (sizes Γ (app x (cons A (cons B x0)))) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Disj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Disj A B) x0))
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v (app x (cons A (cons B x0)))
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Disj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Disj A B) x0))
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v (app x (cons A (cons B x0)))
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
H : In (Conj A B) Γ
*****
Gcf Γ Δ
+++++
apply in_split in H as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
x, x0 : list PropF
H : eq Γ (app x (cons (Conj A B) x0))
*****
Gcf Γ Δ
+++++
subst.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Conj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Conj A B) x0))), \n Validates v Δ
*****
Gcf (app x (cons (Conj A B) x0)) Δ
+++++
constr.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Conj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Conj A B) x0))), \n Validates v Δ
*****
Gcf (app x (cons A (cons B x0))) Δ
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Conj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Conj A B) x0))), \n Validates v Δ
*****
le (sizes (app x (cons A (cons B x0))) Δ) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Conj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Conj A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x (cons A (cons B x0)))), Validates v Δ
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Δ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes (app x (cons (Conj A B) x0)) Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v (app x (cons (Conj A B) x0))), \n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v (app x (cons A (cons B x0)))), Validates v Δ
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
H : In (Conj A B) Δ
*****
Gcf Γ Δ
+++++
apply in_split in H as (?&?&?).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
H2 : eq (sizes Γ Δ) (S n)
A, B : PropF
x, x0 : list PropF
H : eq Δ (app x (cons (Conj A B) x0))
*****
Gcf Γ Δ
+++++
subst.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
Gcf Γ (app x (cons (Conj A B) x0))
+++++
constr.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
Gcf Γ (app x (cons A x0))
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
le (sizes Γ (app x (cons A x0))) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v (app x (cons A x0))
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v (app x (cons A x0))
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
Gcf Γ (app x (cons B x0))
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
le (sizes Γ (app x (cons B x0))) n
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v (app x (cons B x0))
+++++
try (apply le_S_n;rewrite <- H2;apply sizes_decr).
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
clear H.
destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]).
apply in_split in H as (?&?&?).
subst.
constr.
apply IHn.
try (apply le_S_n;rewrite <- H2;apply sizes_decr).

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ : list PropF
A, B : PropF
x, x0 : list PropF
H2 : eq (sizes Γ (app x (cons (Conj A B) x0))) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v (app x (cons (Conj A B) x0))
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v (app x (cons B x0))
+++++
temp5 A B H0.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H : le (sizes Γ Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
m : nat
H2 : le (sizes Γ Δ) n
H1 : eq m n
*****
Gcf Γ Δ
+++++
apply IHn.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H : le (sizes Γ Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
m : nat
H2 : le (sizes Γ Δ) n
H1 : eq m n
*****
le (sizes Γ Δ) n
+++++
assumption.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.
intros.
inversion H.
apply IHn.

*****
n : nat
IHn : forall (Γ Δ : list PropF) (_ : le (sizes Γ Δ) n)\n (_ : forall (v : forall _ : PropVars, bool)\n (_ : Satisfies v Γ), Validates v Δ), \n Gcf Γ Δ
Γ, Δ : list PropF
H : le (sizes Γ Δ) (S n)
H0 : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
m : nat
H2 : le (sizes Γ Δ) n
H1 : eq m n
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v Δ
+++++
assumption.
-----
Theorem Gcf_complete_induction : forall n Γ Δ, sizes Γ Δ <= n -> Γ =⊃ Δ -> Γ ⊃c Δ.
induction n.

*****

*****

+++++
Qed.
-----
Theorem Gcf_complete : forall Γ Δ, Γ =⊃ Δ -> Γ ⊃c Δ.
-----
Theorem Gcf_complete : forall Γ Δ, Γ =⊃ Δ -> Γ ⊃c Δ.

*****

*****
forall (Γ Δ : list PropF) (_ : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v Δ), Gcf Γ Δ
+++++
intros.
-----
Theorem Gcf_complete : forall Γ Δ, Γ =⊃ Δ -> Γ ⊃c Δ.
intros.

*****
Γ, Δ : list PropF
H : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
*****
Gcf Γ Δ
+++++
eapply Gcf_complete_induction.
-----
Theorem Gcf_complete : forall Γ Δ, Γ =⊃ Δ -> Γ ⊃c Δ.
intros.
eapply Gcf_complete_induction.

*****
Γ, Δ : list PropF
H : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
*****
le (sizes Γ Δ) ?n
+++++
constructor.
-----
Theorem Gcf_complete : forall Γ Δ, Γ =⊃ Δ -> Γ ⊃c Δ.
intros.
eapply Gcf_complete_induction.

*****
Γ, Δ : list PropF
H : forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ),\n Validates v Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v Δ
+++++
assumption.
-----
Theorem Gcf_complete : forall Γ Δ, Γ =⊃ Δ -> Γ ⊃c Δ.
intros.
eapply Gcf_complete_induction.

*****

*****

+++++
Qed.
-----
Theorem Cut_elimination : forall Γ Δ, Γ ⊃ Δ -> Γ ⊃c Δ.
-----
Theorem Cut_elimination : forall Γ Δ, Γ ⊃ Δ -> Γ ⊃c Δ.

*****

*****
forall (Γ Δ : list PropF) (_ : G Γ Δ), Gcf Γ Δ
+++++
intros.
-----
Theorem Cut_elimination : forall Γ Δ, Γ ⊃ Δ -> Γ ⊃c Δ.
intros.

*****
Γ, Δ : list PropF
H : G Γ Δ
*****
Gcf Γ Δ
+++++
apply Gcf_complete.
-----
Theorem Cut_elimination : forall Γ Δ, Γ ⊃ Δ -> Γ ⊃c Δ.
intros.
apply Gcf_complete.

*****
Γ, Δ : list PropF
H : G Γ Δ
*****
forall (v : forall _ : PropVars, bool) (_ : Satisfies v Γ), Validates v Δ
+++++
apply G_sound.
-----
Theorem Cut_elimination : forall Γ Δ, Γ ⊃ Δ -> Γ ⊃c Δ.
intros.
apply Gcf_complete.
apply G_sound.

*****
Γ, Δ : list PropF
H : G Γ Δ
*****
G Γ Δ
+++++
assumption.
-----
Theorem Cut_elimination : forall Γ Δ, Γ ⊃ Δ -> Γ ⊃c Δ.
intros.
apply Gcf_complete.
apply G_sound.
assumption.

*****

*****

+++++
Qed.
-----
Print Assumptions Cut_elimination.
-----
End cut_mod.
-----
