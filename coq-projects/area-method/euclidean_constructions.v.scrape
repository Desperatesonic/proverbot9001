Require Export pythagoras_difference.
-----
Definition on_perp (A' B C : Point) : Prop := B <> C /\ perp A' B B C /\ S B C A' <> 0.
-----
Definition on_perp_d (Y U V : Point)  (lambda : F) : Prop := \n     U <> V  /\ perp Y U U V /\ lambda * Py U V U = (2+2) * S U V Y /\ lambda <> 0.
-----
Definition on_inter_line_perp (Y R U V P Q : Point) : Prop :=\n  Col Y U V /\ perp Y R P Q /\ ~ perp P Q U V.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.

*****

*****
forall (A P Q : Point) (_ : not (eq P Q)), ex (fun X : Point => on_foot X A P Q)
+++++
Proof.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.

*****

*****
forall (A P Q : Point) (_ : not (eq P Q)), ex (fun X : Point => on_foot X A P Q)
+++++
intros.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.

*****
H : not (eq P Q)
A,P,Q : Point
*****
ex (fun X : Point => on_foot X A P Q)
+++++
unfold on_foot.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.

*****
H : not (eq P Q)
A,P,Q : Point
*****
ex (fun X : Point => and (perp X A P Q) (and (Col X P Q) (not (eq P Q))))
+++++
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).

*****
T : sig\n (fun Y : Point =>\n and (Col Y P Q)\n (eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))))
H : not (eq P Q)
A,P,Q : Point
*****
ex (fun X : Point => and (perp X A P Q) (and (Col X P Q) (not (eq P Q))))
+++++
elim T.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.

*****
T : sig\n (fun Y : Point =>\n and (Col Y P Q)\n (eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))))
H : not (eq P Q)
A,P,Q : Point
*****
forall (x : Point) (_ : and (Col x P Q) (eq (DSeg P x) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q)))), ex (fun X : Point => and (perp X A P Q) (and (Col X P Q) (not (eq P Q))))
+++++
clear T.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.

*****
H : not (eq P Q)
A,P,Q : Point
*****
forall (x : Point) (_ : and (Col x P Q) (eq (DSeg P x) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q)))), ex (fun X : Point => and (perp X A P Q) (and (Col X P Q) (not (eq P Q))))
+++++
intros Y HY.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.

*****
HY : and (Col Y P Q)\n (eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q)))
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
ex (fun X : Point => and (perp X A P Q) (and (Col X P Q) (not (eq P Q))))
+++++
use HY.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
ex (fun X : Point => and (perp X A P Q) (and (Col X P Q) (not (eq P Q))))
+++++
exists Y.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
and (perp Y A P Q) (and (Col Y P Q) (not (eq P Q)))
+++++
repeat split.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
perp Y A P Q
+++++
auto.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
perp Y A P Q
+++++
unfold perp.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Py4 Y P A Q) F0
+++++
unfold Py4.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Fminus (Py Y P Q) (Py A P Q)) F0
+++++
rewrite col_pyth.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Fminus (Fmult (Fmult (Fplus F1 F1) (DSeg P Y)) (DSeg P Q)) (Py A P Q)) F0
+++++
idtac.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Fminus (Fmult (Fmult (Fplus F1 F1) (DSeg P Y)) (DSeg P Q)) (Py A P Q)) F0
+++++
rewrite H1.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Fminus (Fmult (Fmult (Fplus F1 F1) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))) (DSeg P Q)) (Py A P Q)) F0
+++++
unfold Py.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Fminus (Fmult (Fmult (Fplus F1 F1) (Fmult (Fdiv (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P Q) (DSeg P Q))) (Fmult (DSeg A Q) (DSeg A Q))) (Fminus (Fplus (Fmult (DSeg P Q) (DSeg P Q)) (Fmult (DSeg Q P) (DSeg Q P))) (Fmult (DSeg P P) (DSeg P P)))) (DSeg P Q))) (DSeg P Q)) (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P Q) (DSeg P Q))) (Fmult (DSeg A Q) (DSeg A Q)))) F0
+++++
basic_simpl.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.
basic_simpl.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Fminus (Fmult (Fmult (Fplus F1 F1) (Fmult (Fdiv (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P Q) (DSeg P Q))) (Fmult (DSeg A Q) (DSeg A Q))) (Fplus (Fmult (DSeg P Q) (DSeg P Q)) (Fmult (DSeg Q P) (DSeg Q P)))) (DSeg P Q))) (DSeg P Q)) (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P Q) (DSeg P Q))) (Fmult (DSeg A Q) (DSeg A Q)))) F0
+++++
uniformize_dir_seg.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.
basic_simpl.
uniformize_dir_seg.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Fminus (Fmult (Fmult (Fplus F1 F1) (Fmult (Fdiv (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P Q) (DSeg P Q))) (Fmult (DSeg A Q) (DSeg A Q))) (Fplus (Fmult (DSeg P Q) (DSeg P Q)) (Fmult (Fopp (DSeg P Q)) (Fopp (DSeg P Q))))) (DSeg P Q))) (DSeg P Q)) (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P Q) (DSeg P Q))) (Fmult (DSeg A Q) (DSeg A Q)))) F0
+++++
basic_simpl.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
eq (Fminus (Fmult (Fmult (Fplus F1 F1) (Fmult (Fdiv (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P Q) (DSeg P Q))) (Fmult (DSeg A Q) (DSeg A Q))) (Fplus (Fmult (DSeg P Q) (DSeg P Q)) (Fmult (DSeg P Q) (DSeg P Q)))) (DSeg P Q))) (DSeg P Q)) (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P Q) (DSeg P Q))) (Fmult (DSeg A Q) (DSeg A Q)))) F0
+++++
field.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
field.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
not (eq (Fplus (Fmult (DSeg P Q) (DSeg P Q)) (Fmult (DSeg P Q) (DSeg P Q))) F0)
+++++
replace (P ** Q * P ** Q + P ** Q * P ** Q) with (2*P ** Q * P ** Q) by ring.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
field.
replace (P ** Q * P ** Q + P ** Q * P ** Q) with (2*P ** Q * P ** Q) by ring.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg P Q)) (DSeg P Q)) F0)
+++++
repeat apply nonzeromult.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
field.
replace (P ** Q * P ** Q + P ** Q * P ** Q) with (2*P ** Q * P ** Q) by ring.
repeat apply nonzeromult.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
field.
replace (P ** Q * P ** Q + P ** Q * P ** Q) with (2*P ** Q * P ** Q) by ring.
repeat apply nonzeromult.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
not (eq (DSeg P Q) F0)
+++++
auto with Geom.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.
idtac.
rewrite H1.
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
field.
replace (P ** Q * P ** Q + P ** Q * P ** Q) with (2*P ** Q * P ** Q) by ring.
repeat apply nonzeromult.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
not (eq (DSeg P Q) F0)
+++++
auto with Geom.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.
auto.
unfold perp.
unfold Py4.
rewrite col_pyth.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
Col Y P Q
+++++
assumption .
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
Col Y P Q
+++++
auto.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.

*****
H1 : eq (DSeg P Y) (Fmult (Fdiv (Py A P Q) (Py P Q P)) (DSeg P Q))
H0 : Col Y P Q
Y : Point
H : not (eq P Q)
A,P,Q : Point
*****
not (eq P Q)
+++++
auto.
-----
Lemma proj_ex : forall A P Q, P<>Q -> exists X, on_foot X A P Q.
Proof.
intros.
unfold on_foot.
assert (T:=on_line_dex P Q (Py A P Q/Py P Q P) H).
elim T.
clear T.
intros Y HY.
use HY.
exists Y.
repeat split.

*****

*****

+++++
Qed.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point,\n       on_perp A B C  -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).

*****

*****
forall (A B C : Point) (_ : on_perp A B C), on_perp_d A B C (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B))
+++++
Proof.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.

*****

*****
forall (A B C : Point) (_ : on_perp A B C), on_perp_d A B C (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B))
+++++
intros.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.

*****
H : on_perp A B C
A,B,C : Point
*****
on_perp_d A B C (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B))
+++++
unfold on_perp in *.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.

*****
H : and (not (eq B C)) (and (perp A B B C) (not (eq (S B C A) F0)))
A,B,C : Point
*****
on_perp_d A B C (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B))
+++++
unfold on_perp_d in *.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.

*****
H : and (not (eq B C)) (and (perp A B B C) (not (eq (S B C A) F0)))
A,B,C : Point
*****
and (not (eq B C)) (and (perp A B B C) (and (eq (Fmult (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) (Py B C B)) (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A))) (not (eq (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) F0))))
+++++
decompose [and] H.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
H : and (not (eq B C)) (and (perp A B B C) (not (eq (S B C A) F0)))
A,B,C : Point
*****
and (not (eq B C)) (and (perp A B B C) (and (eq (Fmult (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) (Py B C B)) (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A))) (not (eq (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) F0))))
+++++
clear H.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
and (not (eq B C)) (and (perp A B B C) (and (eq (Fmult (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) (Py B C B)) (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A))) (not (eq (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) F0))))
+++++
repeat split.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq B C)
+++++
try assumption.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
perp A B B C
+++++
try assumption.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) (Py B C B)) (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A))
+++++
try assumption.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) (Py B C B)) (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A))
+++++
field.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
field.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Py B C B) F0)
+++++
auto with Geom.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) F0)
+++++
try assumption.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Fdiv (Fmult (Fplus (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) F0)
+++++
replace (2+2) with (2*2) by ring.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Fdiv (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S B C A)) (Py B C B)) F0)
+++++
repeat apply nonzeromult.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (S B C A) F0)
+++++
auto with Geom.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Finv (Py B C B)) F0)
+++++
auto with Geom.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.

*****
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Finv (Py B C B)) F0)
+++++
intro.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.
intro.

*****
H : eq (Finv (Py B C B)) F0
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
False
+++++
assert ( Py B C B * / Py B C B = 0 * Py B C B).
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.
intro.
assert ( Py B C B * / Py B C B = 0 * Py B C B).

*****
H : eq (Finv (Py B C B)) F0
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Py B C B) (Finv (Py B C B))) (Fmult F0 (Py B C B))
+++++
rewrite H.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.
intro.
assert ( Py B C B * / Py B C B = 0 * Py B C B).
rewrite H.

*****
H : eq (Finv (Py B C B)) F0
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Py B C B) F0) (Fmult F0 (Py B C B))
+++++
ring.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.
intro.
assert ( Py B C B * / Py B C B = 0 * Py B C B).

*****
H1 : eq (Fmult (Py B C B) (Finv (Py B C B))) (Fmult F0 (Py B C B))
H : eq (Finv (Py B C B)) F0
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
False
+++++
replace (Py B C B * / Py B C B) with 1 in H1.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.
intro.
assert ( Py B C B * / Py B C B = 0 * Py B C B).
replace (Py B C B * / Py B C B) with 1 in H1.

*****
H1 : eq F1 (Fmult F0 (Py B C B))
H : eq (Finv (Py B C B)) F0
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
False
+++++
basic_simpl.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.
intro.
assert ( Py B C B * / Py B C B = 0 * Py B C B).
replace (Py B C B * / Py B C B) with 1 in H1.
basic_simpl.

*****
H1 : eq F1 F0
H : eq (Finv (Py B C B)) F0
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
False
+++++
intuition.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.
intro.
assert ( Py B C B * / Py B C B = 0 * Py B C B).
replace (Py B C B * / Py B C B) with 1 in H1.

*****
H1 : eq (Fmult (Py B C B) (Finv (Py B C B))) (Fmult F0 (Py B C B))
H : eq (Finv (Py B C B)) F0
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
eq F1 (Fmult (Py B C B) (Finv (Py B C B)))
+++++
field.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.
try assumption.
replace (2+2) with (2*2) by ring.
repeat apply nonzeromult.
auto with Geom.
intro.
assert ( Py B C B * / Py B C B = 0 * Py B C B).
replace (Py B C B * / Py B C B) with 1 in H1.
field.

*****
H1 : eq (Fmult (Py B C B) (Finv (Py B C B))) (Fmult F0 (Py B C B))
H : eq (Finv (Py B C B)) F0
H3 : not (eq (S B C A) F0)
H2 : perp A B B C
H0 : not (eq B C)
A,B,C : Point
*****
not (eq (Py B C B) F0)
+++++
auto with Geom.
-----
Lemma on_perp_to_on_perp_d : forall A B C : Point, on_perp A B C -> on_perp_d A B C ((2 + 2) * S B C A / Py B C B).
Proof.
intros.
unfold on_perp in *.
unfold on_perp_d in *.
decompose [and] H.
clear H.
repeat split.

*****

*****

+++++
Qed.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r,\n on_line_d A B C r <-> on_parallel_d A B C B (0-r).
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).

*****

*****
forall (A B C : Point) (r : F), iff (on_line_d A B C r) (on_parallel_d A B C B (Fminus F0 r))
+++++
Proof.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.

*****

*****
forall (A B C : Point) (r : F), iff (on_line_d A B C r) (on_parallel_d A B C B (Fminus F0 r))
+++++
intros.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.

*****
r : F
A,B,C : Point
*****
iff (on_line_d A B C r) (on_parallel_d A B C B (Fminus F0 r))
+++++
unfold on_line_d.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.

*****
r : F
A,B,C : Point
*****
iff (and (Col A B C) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))) (on_parallel_d A B C B (Fminus F0 r))
+++++
unfold on_parallel_d.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.

*****
r : F
A,B,C : Point
*****
iff (and (Col A B C) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))) (and (not (eq C B)) (and (parallel A B C B) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B)))))
+++++
unfold parallel.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.

*****
r : F
A,B,C : Point
*****
iff (and (Col A B C) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))) (and (not (eq C B)) (and (eq (S4 A C B B) F0) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B)))))
+++++
unfold S4.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.

*****
r : F
A,B,C : Point
*****
iff (and (Col A B C) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))) (and (not (eq C B)) (and (eq (Fplus (S A C B) (S A B B)) F0) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B)))))
+++++
unfold Col.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.

*****
r : F
A,B,C : Point
*****
iff (and (eq (S A B C) F0) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))) (and (not (eq C B)) (and (eq (Fplus (S A C B) (S A B B)) F0) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B)))))
+++++
split.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.

*****
r : F
A,B,C : Point
*****
forall _ : and (eq (S A B C) F0) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C)))), and (not (eq C B)) (and (eq (Fplus (S A C B) (S A B B)) F0) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))))
+++++
intros.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.

*****
H : and (eq (S A B C) F0)\n (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))
r : F
A,B,C : Point
*****
and (not (eq C B)) (and (eq (Fplus (S A C B) (S A B B)) F0) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))))
+++++
decompose [and] H.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.

*****
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
H : and (eq (S A B C) F0)\n (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))
r : F
A,B,C : Point
*****
and (not (eq C B)) (and (eq (Fplus (S A C B) (S A B B)) F0) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))))
+++++
clear H.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.

*****
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
r : F
A,B,C : Point
*****
and (not (eq C B)) (and (eq (Fplus (S A C B) (S A B B)) F0) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))))
+++++
repeat split.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.

*****
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
r : F
A,B,C : Point
*****
not (eq C B)
+++++
auto.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.

*****
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
r : F
A,B,C : Point
*****
eq (Fplus (S A C B) (S A B B)) F0
+++++
basic_simpl.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
basic_simpl.

*****
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
r : F
A,B,C : Point
*****
eq (S A C B) F0
+++++
uniformize_signed_areas.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
basic_simpl.
uniformize_signed_areas.

*****
H0 : eq (S A B C) F0
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
r : F
A,B,C : Point
*****
eq (Fopp (S A B C)) F0
+++++
rewrite H0.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
basic_simpl.
uniformize_signed_areas.
rewrite H0.

*****
H0 : eq (S A B C) F0
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
r : F
A,B,C : Point
*****
eq (Fopp F0) F0
+++++
ring.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.

*****
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
r : F
A,B,C : Point
*****
eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
+++++
auto.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
auto.

*****
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
r : F
A,B,C : Point
*****
eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
+++++
rewrite H3.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
auto.
rewrite H3.

*****
H3 : eq (DSeg B A) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
r : F
A,B,C : Point
*****
eq (Fmult r (DSeg B C)) (Fmult (Fminus F0 r) (DSeg C B))
+++++
uniformize_dir_seg.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
auto.
rewrite H3.
uniformize_dir_seg.

*****
H3 : eq (Fopp (DSeg A B)) (Fmult r (DSeg B C))
H2 : not (eq B C)
H0 : eq (S A B C) F0
r : F
A,B,C : Point
*****
eq (Fmult r (DSeg B C)) (Fmult (Fminus F0 r) (Fopp (DSeg B C)))
+++++
ring.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.

*****
r : F
A,B,C : Point
*****
forall _ : and (not (eq C B)) (and (eq (Fplus (S A C B) (S A B B)) F0) (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B)))), and (eq (S A B C) F0) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))
+++++
intros.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.

*****
H : and (not (eq C B))\n (and (eq (Fplus (S A C B) (S A B B)) F0)\n (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))))
r : F
A,B,C : Point
*****
and (eq (S A B C) F0) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))
+++++
decompose [and] H.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.

*****
H3 : eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
H2 : eq (Fplus (S A C B) (S A B B)) F0
H0 : not (eq C B)
H : and (not (eq C B))\n (and (eq (Fplus (S A C B) (S A B B)) F0)\n (eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))))
r : F
A,B,C : Point
*****
and (eq (S A B C) F0) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))
+++++
clear H.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.

*****
H3 : eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
H2 : eq (Fplus (S A C B) (S A B B)) F0
H0 : not (eq C B)
r : F
A,B,C : Point
*****
and (eq (S A B C) F0) (and (not (eq B C)) (eq (DSeg B A) (Fmult r (DSeg B C))))
+++++
repeat split.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.

*****
H3 : eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
H2 : eq (Fplus (S A C B) (S A B B)) F0
H0 : not (eq C B)
r : F
A,B,C : Point
*****
eq (S A B C) F0
+++++
basic_simpl.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
basic_simpl.

*****
H3 : eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
H2 : eq (S A C B) F0
H0 : not (eq C B)
r : F
A,B,C : Point
*****
eq (S A B C) F0
+++++
uniformize_signed_areas.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
basic_simpl.
uniformize_signed_areas.

*****
H2 : eq (S A C B) F0
H3 : eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
H0 : not (eq C B)
r : F
A,B,C : Point
*****
eq (Fopp (S A C B)) F0
+++++
rewrite H2.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
basic_simpl.
uniformize_signed_areas.
rewrite H2.

*****
H2 : eq (S A C B) F0
H3 : eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
H0 : not (eq C B)
r : F
A,B,C : Point
*****
eq (Fopp F0) F0
+++++
ring.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.

*****
H3 : eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
H2 : eq (Fplus (S A C B) (S A B B)) F0
H0 : not (eq C B)
r : F
A,B,C : Point
*****
not (eq B C)
+++++
auto.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.

*****
H3 : eq (DSeg B A) (Fmult (Fminus F0 r) (DSeg C B))
H2 : eq (Fplus (S A C B) (S A B B)) F0
H0 : not (eq C B)
r : F
A,B,C : Point
*****
eq (DSeg B A) (Fmult r (DSeg B C))
+++++
uniformize_dir_seg.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
uniformize_dir_seg.

*****
H3 : eq (Fopp (DSeg A B)) (Fmult (Fminus F0 r) (Fopp (DSeg B C)))
H2 : eq (Fplus (S A C B) (S A B B)) F0
H0 : not (eq C B)
r : F
A,B,C : Point
*****
eq (Fopp (DSeg A B)) (Fmult r (DSeg B C))
+++++
rewrite H3.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
repeat split.
uniformize_dir_seg.
rewrite H3.

*****
H3 : eq (Fopp (DSeg A B)) (Fmult (Fminus F0 r) (Fopp (DSeg B C)))
H2 : eq (Fplus (S A C B) (S A B B)) F0
H0 : not (eq C B)
r : F
A,B,C : Point
*****
eq (Fmult (Fminus F0 r) (Fopp (DSeg B C))) (Fmult r (DSeg B C))
+++++
ring.
-----
Lemma on_line_d_iff_on_parallel_d : forall A B C r, on_line_d A B C r <-> on_parallel_d A B C B (0-r).
Proof.
intros.
unfold on_line_d.
unfold on_parallel_d.
unfold parallel.
unfold S4.
unfold Col.
split.

*****

*****

+++++
Qed.
-----
Lemma on_line_iff_on_parallel : forall A B C,\n on_line A B C <-> on_parallel A B C B.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.

*****

*****
forall A B C : Point, iff (on_line A B C) (on_parallel A B C B)
+++++
Proof.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.

*****

*****
forall A B C : Point, iff (on_line A B C) (on_parallel A B C B)
+++++
intros.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.

*****
A,B,C : Point
*****
iff (on_line A B C) (on_parallel A B C B)
+++++
unfold on_line.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.

*****
A,B,C : Point
*****
iff (and (Col A B C) (not (eq B C))) (on_parallel A B C B)
+++++
unfold on_parallel.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.

*****
A,B,C : Point
*****
iff (and (Col A B C) (not (eq B C))) (and (not (eq C B)) (parallel B A C B))
+++++
unfold parallel.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.

*****
A,B,C : Point
*****
iff (and (Col A B C) (not (eq B C))) (and (not (eq C B)) (eq (S4 B C A B) F0))
+++++
unfold S4.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.

*****
A,B,C : Point
*****
iff (and (Col A B C) (not (eq B C))) (and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0))
+++++
unfold Col.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.

*****
A,B,C : Point
*****
iff (and (eq (S A B C) F0) (not (eq B C))) (and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0))
+++++
split.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.

*****
A,B,C : Point
*****
forall _ : and (eq (S A B C) F0) (not (eq B C)), and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0)
+++++
intros.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.

*****
H : and (eq (S A B C) F0) (not (eq B C))
A,B,C : Point
*****
and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0)
+++++
decompose [and] H.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.

*****
H1 : not (eq B C)
H0 : eq (S A B C) F0
H : and (eq (S A B C) F0) (not (eq B C))
A,B,C : Point
*****
and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0)
+++++
clear H.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.

*****
H1 : not (eq B C)
H0 : eq (S A B C) F0
A,B,C : Point
*****
and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0)
+++++
split.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
split.

*****
H1 : not (eq B C)
H0 : eq (S A B C) F0
A,B,C : Point
*****
not (eq C B)
+++++
auto.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
split.

*****
H1 : not (eq B C)
H0 : eq (S A B C) F0
A,B,C : Point
*****
eq (Fplus (S B C A) (S B A B)) F0
+++++
basic_simpl.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
split.
basic_simpl.

*****
H1 : not (eq B C)
H0 : eq (S A B C) F0
A,B,C : Point
*****
eq (S B C A) F0
+++++
uniformize_signed_areas.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
split.
basic_simpl.
uniformize_signed_areas.

*****
H0 : eq (S A B C) F0
H1 : not (eq B C)
A,B,C : Point
*****
eq (S A B C) F0
+++++
auto.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.

*****
A,B,C : Point
*****
forall _ : and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0), and (eq (S A B C) F0) (not (eq B C))
+++++
intros.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.

*****
H : and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0)
A,B,C : Point
*****
and (eq (S A B C) F0) (not (eq B C))
+++++
decompose [and] H.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.

*****
H1 : eq (Fplus (S B C A) (S B A B)) F0
H0 : not (eq C B)
H : and (not (eq C B)) (eq (Fplus (S B C A) (S B A B)) F0)
A,B,C : Point
*****
and (eq (S A B C) F0) (not (eq B C))
+++++
clear H.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.

*****
H1 : eq (Fplus (S B C A) (S B A B)) F0
H0 : not (eq C B)
A,B,C : Point
*****
and (eq (S A B C) F0) (not (eq B C))
+++++
split.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
split.

*****
H1 : eq (Fplus (S B C A) (S B A B)) F0
H0 : not (eq C B)
A,B,C : Point
*****
eq (S A B C) F0
+++++
basic_simpl.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
split.
basic_simpl.

*****
H1 : eq (S B C A) F0
H0 : not (eq C B)
A,B,C : Point
*****
eq (S A B C) F0
+++++
uniformize_signed_areas.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
split.
basic_simpl.
uniformize_signed_areas.

*****
H1 : eq (S B C A) F0
H0 : not (eq C B)
A,B,C : Point
*****
eq (S B C A) F0
+++++
auto.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.
intros.
decompose [and] H.
clear H.
split.

*****
H1 : eq (Fplus (S B C A) (S B A B)) F0
H0 : not (eq C B)
A,B,C : Point
*****
not (eq B C)
+++++
auto.
-----
Lemma on_line_iff_on_parallel : forall A B C, on_line A B C <-> on_parallel A B C B.
Proof.
intros.
unfold on_line.
unfold on_parallel.
unfold parallel.
unfold S4.
unfold Col.
split.

*****

*****

+++++
Qed.
-----
Definition eq_distance A B C D := Py A B A = Py C D C.
-----
Definition harmonic A B C D := A**C / C**B = D**A / D**B.
-----
Definition eq_product A B C D P Q R S := Py A B A * Py C D C = Py P Q P * Py R S R.
-----
Definition tangent O1 A O2 B :=\nPy O1 O2 O1 * Py O1 O2 O1 / (2+2) + \nPy O1 A O1   * Py O1 A O1 / (2+2) +  \nPy O1 B O1   * Py O1 B O1 / (2+2) -\nPy O1 O2 O1 * Py O1 A O1 / 2 -\nPy O1 O2 O1 * Py O1 B O1 / 2 -\n Py O1 A O1 * Py O1 B O1 / 2.
-----
Definition m_ratio Y U V r := 1+r<>0 /\ on_parallel_d Y U U V (r/(1+r)).
-----
Definition inversion P Q O A := Py O Q O <> 0 /\ on_line_d P O Q (Py O A O / Py O Q O).
-----
Definition eq_angle A B C D E F := \n  S A B C * Py D E F = S D E F  * Py A B C.
-----
Definition co_circle A B C D :=\n  S C A D * Py C B D = S C B D * Py C A D.
-----
Lemma check_co_circle : forall A B C D, \n co_circle A B C D <-> eq_angle C A D C B D.
-----
Lemma check_co_circle : forall A B C D, co_circle A B C D <-> eq_angle C A D C B D.

*****

*****
forall A B C D : Point, iff (co_circle A B C D) (eq_angle C A D C B D)
+++++
Proof.
-----
Lemma check_co_circle : forall A B C D, co_circle A B C D <-> eq_angle C A D C B D.
Proof.

*****

*****
forall A B C D : Point, iff (co_circle A B C D) (eq_angle C A D C B D)
+++++
intros.
-----
Lemma check_co_circle : forall A B C D, co_circle A B C D <-> eq_angle C A D C B D.
Proof.
intros.

*****
A,B,C,D : Point
*****
iff (co_circle A B C D) (eq_angle C A D C B D)
+++++
unfold co_circle.
-----
Lemma check_co_circle : forall A B C D, co_circle A B C D <-> eq_angle C A D C B D.
Proof.
intros.
unfold co_circle.

*****
A,B,C,D : Point
*****
iff (eq (Fmult (S C A D) (Py C B D)) (Fmult (S C B D) (Py C A D))) (eq_angle C A D C B D)
+++++
unfold eq_angle.
-----
Lemma check_co_circle : forall A B C D, co_circle A B C D <-> eq_angle C A D C B D.
Proof.
intros.
unfold co_circle.
unfold eq_angle.

*****
A,B,C,D : Point
*****
iff (eq (Fmult (S C A D) (Py C B D)) (Fmult (S C B D) (Py C A D))) (eq (Fmult (S C A D) (Py C B D)) (Fmult (S C B D) (Py C A D)))
+++++
intuition.
-----
Lemma check_co_circle : forall A B C D, co_circle A B C D <-> eq_angle C A D C B D.
Proof.
intros.
unfold co_circle.
unfold eq_angle.
intuition.

*****

*****

+++++
Qed.
-----
Definition inter_lc Y U V O N := on_foot N O U V /\ on_parallel_d Y N N U 1.
-----
Definition on_circle Y O P Q' N' :=  inter_lc Y P Q' O N'.
-----
