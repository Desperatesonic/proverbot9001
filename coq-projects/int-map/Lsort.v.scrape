From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
From Coq Require Import Arith.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Map.
-----
From Coq Require Import List.
-----
Require Import Mapiter.
-----
Section LSort.
-----
Variable A : Type.
-----
Fixpoint alist_sorted (l:alist A) : bool :=\n    match l with\n    | nil => true\n    | (a, _) :: l' =>\n        match l' with\n        | nil => true\n        | (a', y') :: l'' => andb (Nless a a') (alist_sorted l')\n        end\n    end.
-----
Fixpoint alist_nth_ad (n:nat) (l:alist A) {struct l} : ad :=\n    match l with\n    | nil => N0 \n    | (a, y) :: l' => match n with\n                      | O => a\n                      | S n' => alist_nth_ad n' l'\n                      end\n    end.
-----
Definition alist_sorted_1 (l:alist A) :=\n    forall n:nat,\n      S (S n) <= length l ->\n      Nless (alist_nth_ad n l) (alist_nth_ad (S n) l) = true.
-----
Lemma alist_sorted_imp_1 :\n   forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.

*****
A : Type
*****
forall (l : alist A) (_ : eq (alist_sorted l) true), alist_sorted_1 l
+++++
Proof.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.

*****
A : Type
*****
forall (l : alist A) (_ : eq (alist_sorted l) true), alist_sorted_1 l
+++++
unfold alist_sorted_1 in |- *.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.

*****
A : Type
*****
forall (l : alist A) (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
+++++
simple induction l.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.

*****
l : alist A
A : Type
*****
forall (_ : eq (alist_sorted nil) true) (n : nat) (_ : le (S (S n)) (length nil)), eq (Nless (alist_nth_ad n nil) (alist_nth_ad (S n) nil)) true
+++++
intros.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intros.

*****
H0 : le (S (S n)) (length nil)
n : nat
H : eq (alist_sorted nil) true
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad n nil) (alist_nth_ad (S n) nil)) true
+++++
elim (le_Sn_O (S n) H0).
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (_ : eq (alist_sorted (cons a l)) true) (n : nat) (_ : le (S (S n)) (length (cons a l))), eq (Nless (alist_nth_ad n (cons a l)) (alist_nth_ad (S n) (cons a l))) true
+++++
intro r.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (_ : eq (alist_sorted (cons r l)) true) (n : nat) (_ : le (S (S n)) (length (cons r l))), eq (Nless (alist_nth_ad n (cons r l)) (alist_nth_ad (S n) (cons r l))) true
+++++
elim r.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (_ : eq (alist_sorted (cons (pair a b) l)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a b) l))), eq (Nless (alist_nth_ad n (cons (pair a b) l)) (alist_nth_ad (S n) (cons (pair a b) l))) true
+++++
intros a y.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.

*****
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (_ : eq (alist_sorted (cons (pair a y) l)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad n (cons (pair a y) l)) (alist_nth_ad (S n) (cons (pair a y) l))) true
+++++
simple induction l0.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.

*****
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (_ : forall (_ : eq (alist_sorted nil) true) (n : nat) (_ : le (S (S n)) (length nil)), eq (Nless (alist_nth_ad n nil) (alist_nth_ad (S n) nil)) true) (_ : eq (alist_sorted (cons (pair a y) nil)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) nil))), eq (Nless (alist_nth_ad n (cons (pair a y) nil)) (alist_nth_ad (S n) (cons (pair a y) nil))) true
+++++
intros.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intros.

*****
H1 : le (S (S n)) (length (cons (pair a y) nil))
n : nat
H0 : eq (alist_sorted (cons (pair a y) nil)) true
H : forall (_ : eq (alist_sorted nil) true) (n : nat)\n (_ : le (S (S n)) (length nil)),\neq (Nless (alist_nth_ad n nil) (alist_nth_ad (S n) nil)) true
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad n (cons (pair a y) nil)) (alist_nth_ad (S n) (cons (pair a y) nil))) true
+++++
simpl in H1.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intros.
simpl in H1.

*****
H1 : le (S (S n)) (S O)
n : nat
H0 : eq (alist_sorted (cons (pair a y) nil)) true
H : forall (_ : eq (alist_sorted nil) true) (n : nat)\n (_ : le (S (S n)) (length nil)),\neq (Nless (alist_nth_ad n nil) (alist_nth_ad (S n) nil)) true
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad n (cons (pair a y) nil)) (alist_nth_ad (S n) (cons (pair a y) nil))) true
+++++
elim (le_Sn_O n (le_S_n (S n) 0 H1)).
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.

*****
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (a0 : prod ad A) (l : list (prod ad A)) (_ : forall (_ : forall (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (_ : eq (alist_sorted (cons (pair a y) l)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad n (cons (pair a y) l)) (alist_nth_ad (S n) (cons (pair a y) l))) true) (_ : forall (_ : eq (alist_sorted (cons a0 l)) true) (n : nat) (_ : le (S (S n)) (length (cons a0 l))), eq (Nless (alist_nth_ad n (cons a0 l)) (alist_nth_ad (S n) (cons a0 l))) true) (_ : eq (alist_sorted (cons (pair a y) (cons a0 l))) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) (cons a0 l)))), eq (Nless (alist_nth_ad n (cons (pair a y) (cons a0 l))) (alist_nth_ad (S n) (cons (pair a y) (cons a0 l)))) true
+++++
intro r0.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.

*****
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (_ : forall (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (_ : eq (alist_sorted (cons (pair a y) l)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad n (cons (pair a y) l)) (alist_nth_ad (S n) (cons (pair a y) l))) true) (_ : forall (_ : eq (alist_sorted (cons r0 l)) true) (n : nat) (_ : le (S (S n)) (length (cons r0 l))), eq (Nless (alist_nth_ad n (cons r0 l)) (alist_nth_ad (S n) (cons r0 l))) true) (_ : eq (alist_sorted (cons (pair a y) (cons r0 l))) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) (cons r0 l)))), eq (Nless (alist_nth_ad n (cons (pair a y) (cons r0 l))) (alist_nth_ad (S n) (cons (pair a y) (cons r0 l)))) true
+++++
elim r0.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.

*****
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (a0 : ad) (b : A) (l : list (prod ad A)) (_ : forall (_ : forall (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (_ : eq (alist_sorted (cons (pair a y) l)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad n (cons (pair a y) l)) (alist_nth_ad (S n) (cons (pair a y) l))) true) (_ : forall (_ : eq (alist_sorted (cons (pair a0 b) l)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a0 b) l))), eq (Nless (alist_nth_ad n (cons (pair a0 b) l)) (alist_nth_ad (S n) (cons (pair a0 b) l))) true) (_ : eq (alist_sorted (cons (pair a y) (cons (pair a0 b) l))) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) (cons (pair a0 b) l)))), eq (Nless (alist_nth_ad n (cons (pair a y) (cons (pair a0 b) l))) (alist_nth_ad (S n) (cons (pair a y) (cons (pair a0 b) l)))) true
+++++
intros a0 y0.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.

*****
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (_ : forall (_ : eq (alist_sorted l) true) (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (_ : eq (alist_sorted (cons (pair a y) l)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad n (cons (pair a y) l)) (alist_nth_ad (S n) (cons (pair a y) l))) true) (_ : forall (_ : eq (alist_sorted (cons (pair a0 y0) l)) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l))), eq (Nless (alist_nth_ad n (cons (pair a0 y0) l)) (alist_nth_ad (S n) (cons (pair a0 y0) l))) true) (_ : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l))) true) (n : nat) (_ : le (S (S n)) (length (cons (pair a y) (cons (pair a0 y0) l)))), eq (Nless (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l))) (alist_nth_ad (S n) (cons (pair a y) (cons (pair a0 y0) l)))) true
+++++
simple induction n.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.

*****
n : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : le (S (S O)) (length (cons (pair a y) (cons (pair a0 y0) l1))), eq (Nless (alist_nth_ad O (cons (pair a y) (cons (pair a0 y0) l1))) (alist_nth_ad (S O) (cons (pair a y) (cons (pair a0 y0) l1)))) true
+++++
intros.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.
intros.

*****
H2 : le (S (S O)) (length (cons (pair a y) (cons (pair a0 y0) l1)))
n : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad O (cons (pair a y) (cons (pair a0 y0) l1))) (alist_nth_ad (S O) (cons (pair a y) (cons (pair a0 y0) l1)))) true
+++++
simpl in |- *.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.
intros.
simpl in |- *.

*****
H2 : le (S (S O)) (length (cons (pair a y) (cons (pair a0 y0) l1)))
n : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless a a0) true
+++++
simpl in H1.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.
intros.
simpl in |- *.
simpl in H1.

*****
H2 : le (S (S O)) (length (cons (pair a y) (cons (pair a0 y0) l1)))
n : nat
H1 : eq\n (andb (Nless a a0)\n match l1 with\n | nil => true\n | cons (pair a' _) _ => andb (Nless a0 a') (alist_sorted l1)\n end) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless a a0) true
+++++
exact (proj1 (andb_prop _ _ H1)).
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.

*****
n : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (n : nat) (_ : forall _ : le (S (S n)) (length (cons (pair a y) (cons (pair a0 y0) l1))), eq (Nless (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1))) (alist_nth_ad (S n) (cons (pair a y) (cons (pair a0 y0) l1)))) true) (_ : le (S (S (S n))) (length (cons (pair a y) (cons (pair a0 y0) l1)))), eq (Nless (alist_nth_ad (S n) (cons (pair a y) (cons (pair a0 y0) l1))) (alist_nth_ad (S (S n)) (cons (pair a y) (cons (pair a0 y0) l1)))) true
+++++
intros.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.
intros.

*****
H3 : le (S (S (S n0))) (length (cons (pair a y) (cons (pair a0 y0) l1)))
H2 : forall\n _ : le (S (S n0)) (length (cons (pair a y) (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n0 (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad (S n0) (cons (pair a y) (cons (pair a0 y0) l1))))\n true
n,n0 : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad (S n0) (cons (pair a y) (cons (pair a0 y0) l1))) (alist_nth_ad (S (S n0)) (cons (pair a y) (cons (pair a0 y0) l1)))) true
+++++
change (Nless (alist_nth_ad n0 ((a0, y0) :: l1)) (alist_nth_ad (S n0) ((a0, y0) :: l1)) = true) in |- *.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.
intros.
change (Nless (alist_nth_ad n0 ((a0, y0) :: l1)) (alist_nth_ad (S n0) ((a0, y0) :: l1)) = true) in |- *.

*****
H3 : le (S (S (S n0))) (length (cons (pair a y) (cons (pair a0 y0) l1)))
H2 : forall\n _ : le (S (S n0)) (length (cons (pair a y) (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n0 (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad (S n0) (cons (pair a y) (cons (pair a0 y0) l1))))\n true
n,n0 : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad n0 (cons (pair a0 y0) l1)) (alist_nth_ad (S n0) (cons (pair a0 y0) l1))) true
+++++
apply H0.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.
intros.
change (Nless (alist_nth_ad n0 ((a0, y0) :: l1)) (alist_nth_ad (S n0) ((a0, y0) :: l1)) = true) in |- *.
apply H0.

*****
H3 : le (S (S (S n0))) (length (cons (pair a y) (cons (pair a0 y0) l1)))
H2 : forall\n _ : le (S (S n0)) (length (cons (pair a y) (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n0 (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad (S n0) (cons (pair a y) (cons (pair a0 y0) l1))))\n true
n,n0 : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_sorted (cons (pair a0 y0) l1)) true
+++++
exact (proj2 (andb_prop _ _ H1)).
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.
intros.
change (Nless (alist_nth_ad n0 ((a0, y0) :: l1)) (alist_nth_ad (S n0) ((a0, y0) :: l1)) = true) in |- *.
apply H0.

*****
H3 : le (S (S (S n0))) (length (cons (pair a y) (cons (pair a0 y0) l1)))
H2 : forall\n _ : le (S (S n0)) (length (cons (pair a y) (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n0 (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad (S n0) (cons (pair a y) (cons (pair a0 y0) l1))))\n true
n,n0 : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S n0)) (length (cons (pair a0 y0) l1))
+++++
apply le_S_n.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
simple induction n.
intros.
change (Nless (alist_nth_ad n0 ((a0, y0) :: l1)) (alist_nth_ad (S n0) ((a0, y0) :: l1)) = true) in |- *.
apply H0.
apply le_S_n.

*****
H3 : le (S (S (S n0))) (length (cons (pair a y) (cons (pair a0 y0) l1)))
H2 : forall\n _ : le (S (S n0)) (length (cons (pair a y) (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n0 (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad (S n0) (cons (pair a y) (cons (pair a0 y0) l1))))\n true
n,n0 : nat
H1 : eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
H0 : forall (_ : eq (alist_sorted (cons (pair a0 y0) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a0 y0) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a0 y0) l1))\n (alist_nth_ad (S n) (cons (pair a0 y0) l1))) true
H : forall\n (_ : forall (_ : eq (alist_sorted l1) true) (n : nat)\n (_ : le (S (S n)) (length l1)),\n eq (Nless (alist_nth_ad n l1) (alist_nth_ad (S n) l1)) true)\n (_ : eq (alist_sorted (cons (pair a y) l1)) true) \n (n : nat) (_ : le (S (S n)) (length (cons (pair a y) l1))),\neq\n (Nless (alist_nth_ad n (cons (pair a y) l1))\n (alist_nth_ad (S n) (cons (pair a y) l1))) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S (S n0))) (S (length (cons (pair a0 y0) l1)))
+++++
exact H3.
-----
Lemma alist_sorted_imp_1 : forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.
Proof.
unfold alist_sorted_1 in |- *.
simple induction l.

*****

*****

+++++
Qed.
-----
Definition alist_sorted_2 (l:alist A) :=\n    forall m n:nat,\n      m < n ->\n      S n <= length l -> Nless (alist_nth_ad m l) (alist_nth_ad n l) = true.
-----
Lemma alist_sorted_1_imp_2 :\n   forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.

*****
A : Type
*****
forall (l : alist A) (_ : alist_sorted_1 l), alist_sorted_2 l
+++++
Proof.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.

*****
A : Type
*****
forall (l : alist A) (_ : alist_sorted_1 l), alist_sorted_2 l
+++++
unfold alist_sorted_1 in |- *.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.

*****
A : Type
*****
forall (l : alist A) (_ : forall (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true), alist_sorted_2 l
+++++
unfold alist_sorted_2 in |- *.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.

*****
A : Type
*****
forall (l : alist A) (_ : forall (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (m n : nat) (_ : lt m n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
+++++
unfold lt in |- *.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.

*****
A : Type
*****
forall (l : alist A) (_ : forall (n : nat) (_ : le (S (S n)) (length l)), eq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true) (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
+++++
intros l H m n H0.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.

*****
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
forall _ : le (S n) (length l), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
+++++
elim H0.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.

*****
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
forall _ : le (S (S m)) (length l), eq (Nless (alist_nth_ad m l) (alist_nth_ad (S m) l)) true
+++++
exact (H m).
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.

*****
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
forall (m0 : nat) (_ : le (S m) m0) (_ : forall _ : le (S m0) (length l), eq (Nless (alist_nth_ad m l) (alist_nth_ad m0 l)) true) (_ : le (S (S m0)) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad (S m0) l)) true
+++++
intros.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.
intros.

*****
H3 : le (S (S m0)) (length l)
H2 : forall _ : le (S m0) (length l),\neq (Nless (alist_nth_ad m l) (alist_nth_ad m0 l)) true
H1 : le (S m) m0
m0 : nat
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad (S m0) l)) true
+++++
apply Nless_trans with (a' := alist_nth_ad m0 l).
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.
intros.
apply Nless_trans with (a' := alist_nth_ad m0 l).

*****
H3 : le (S (S m0)) (length l)
H2 : forall _ : le (S m0) (length l),\neq (Nless (alist_nth_ad m l) (alist_nth_ad m0 l)) true
H1 : le (S m) m0
m0 : nat
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad m0 l)) true
+++++
apply H2.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.
intros.
apply Nless_trans with (a' := alist_nth_ad m0 l).
apply H2.

*****
H3 : le (S (S m0)) (length l)
H2 : forall _ : le (S m0) (length l),\neq (Nless (alist_nth_ad m l) (alist_nth_ad m0 l)) true
H1 : le (S m) m0
m0 : nat
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
le (S m0) (length l)
+++++
apply le_Sn_le.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.
intros.
apply Nless_trans with (a' := alist_nth_ad m0 l).
apply H2.
apply le_Sn_le.

*****
H3 : le (S (S m0)) (length l)
H2 : forall _ : le (S m0) (length l),\neq (Nless (alist_nth_ad m l) (alist_nth_ad m0 l)) true
H1 : le (S m) m0
m0 : nat
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
le (S (S m0)) (length l)
+++++
assumption.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.
intros.
apply Nless_trans with (a' := alist_nth_ad m0 l).

*****
H3 : le (S (S m0)) (length l)
H2 : forall _ : le (S m0) (length l),\neq (Nless (alist_nth_ad m l) (alist_nth_ad m0 l)) true
H1 : le (S m) m0
m0 : nat
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad m0 l) (alist_nth_ad (S m0) l)) true
+++++
apply H.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.
intros.
apply Nless_trans with (a' := alist_nth_ad m0 l).
apply H.

*****
H3 : le (S (S m0)) (length l)
H2 : forall _ : le (S m0) (length l),\neq (Nless (alist_nth_ad m l) (alist_nth_ad m0 l)) true
H1 : le (S m) m0
m0 : nat
H0 : le (S m) n
m,n : nat
H : forall (n : nat) (_ : le (S (S n)) (length l)),\neq (Nless (alist_nth_ad n l) (alist_nth_ad (S n) l)) true
l : alist A
A : Type
*****
le (S (S m0)) (length l)
+++++
assumption.
-----
Lemma alist_sorted_1_imp_2 : forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.
Proof.
unfold alist_sorted_1 in |- *.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros l H m n H0.
elim H0.

*****

*****

+++++
Qed.
-----
Lemma alist_sorted_2_imp :\n   forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.

*****
A : Type
*****
forall (l : alist A) (_ : alist_sorted_2 l), eq (alist_sorted l) true
+++++
Proof.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.

*****
A : Type
*****
forall (l : alist A) (_ : alist_sorted_2 l), eq (alist_sorted l) true
+++++
unfold alist_sorted_2 in |- *.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.

*****
A : Type
*****
forall (l : alist A) (_ : forall (m n : nat) (_ : lt m n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true), eq (alist_sorted l) true
+++++
unfold lt in |- *.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.

*****
A : Type
*****
forall (l : alist A) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true), eq (alist_sorted l) true
+++++
simple induction l.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.

*****
l : alist A
A : Type
*****
forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length nil)), eq (Nless (alist_nth_ad m nil) (alist_nth_ad n nil)) true, eq (alist_sorted nil) true
+++++
trivial.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true, eq (alist_sorted l) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons a l))), eq (Nless (alist_nth_ad m (cons a l)) (alist_nth_ad n (cons a l))) true), eq (alist_sorted (cons a l)) true
+++++
intro r.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true, eq (alist_sorted l) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons r l))), eq (Nless (alist_nth_ad m (cons r l)) (alist_nth_ad n (cons r l))) true), eq (alist_sorted (cons r l)) true
+++++
elim r.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true, eq (alist_sorted l) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a b) l))), eq (Nless (alist_nth_ad m (cons (pair a b) l)) (alist_nth_ad n (cons (pair a b) l))) true), eq (alist_sorted (cons (pair a b) l)) true
+++++
intros a y.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.

*****
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true, eq (alist_sorted l) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad m (cons (pair a y) l)) (alist_nth_ad n (cons (pair a y) l))) true), eq (alist_sorted (cons (pair a y) l)) true
+++++
simple induction l0.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.

*****
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length nil)), eq (Nless (alist_nth_ad m nil) (alist_nth_ad n nil)) true, eq (alist_sorted nil) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) nil))), eq (Nless (alist_nth_ad m (cons (pair a y) nil)) (alist_nth_ad n (cons (pair a y) nil))) true), eq (alist_sorted (cons (pair a y) nil)) true
+++++
trivial.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.

*****
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (a0 : prod ad A) (l : list (prod ad A)) (_ : forall (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true, eq (alist_sorted l) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad m (cons (pair a y) l)) (alist_nth_ad n (cons (pair a y) l))) true), eq (alist_sorted (cons (pair a y) l)) true) (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons a0 l))), eq (Nless (alist_nth_ad m (cons a0 l)) (alist_nth_ad n (cons a0 l))) true, eq (alist_sorted (cons a0 l)) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) (cons a0 l)))), eq (Nless (alist_nth_ad m (cons (pair a y) (cons a0 l))) (alist_nth_ad n (cons (pair a y) (cons a0 l)))) true), eq (alist_sorted (cons (pair a y) (cons a0 l))) true
+++++
intro r0.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.

*****
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true, eq (alist_sorted l) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad m (cons (pair a y) l)) (alist_nth_ad n (cons (pair a y) l))) true), eq (alist_sorted (cons (pair a y) l)) true) (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons r0 l))), eq (Nless (alist_nth_ad m (cons r0 l)) (alist_nth_ad n (cons r0 l))) true, eq (alist_sorted (cons r0 l)) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) (cons r0 l)))), eq (Nless (alist_nth_ad m (cons (pair a y) (cons r0 l))) (alist_nth_ad n (cons (pair a y) (cons r0 l)))) true), eq (alist_sorted (cons (pair a y) (cons r0 l))) true
+++++
elim r0.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.

*****
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (a0 : ad) (b : A) (l : list (prod ad A)) (_ : forall (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true, eq (alist_sorted l) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad m (cons (pair a y) l)) (alist_nth_ad n (cons (pair a y) l))) true), eq (alist_sorted (cons (pair a y) l)) true) (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a0 b) l))), eq (Nless (alist_nth_ad m (cons (pair a0 b) l)) (alist_nth_ad n (cons (pair a0 b) l))) true, eq (alist_sorted (cons (pair a0 b) l)) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) (cons (pair a0 b) l)))), eq (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 b) l))) (alist_nth_ad n (cons (pair a y) (cons (pair a0 b) l)))) true), eq (alist_sorted (cons (pair a y) (cons (pair a0 b) l))) true
+++++
intros a0 y0.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.

*****
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true, eq (alist_sorted l) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad m (cons (pair a y) l)) (alist_nth_ad n (cons (pair a y) l))) true), eq (alist_sorted (cons (pair a y) l)) true) (_ : forall _ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a0 y0) l))), eq (Nless (alist_nth_ad m (cons (pair a0 y0) l)) (alist_nth_ad n (cons (pair a0 y0) l))) true, eq (alist_sorted (cons (pair a0 y0) l)) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l)))), eq (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l))) (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l)))) true), eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l))) true
+++++
intros.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_sorted (cons (pair a y) (cons (pair a0 y0) l1))) true
+++++
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (andb (Nless a a0) (alist_sorted (cons (pair a0 y0) l1))) true
+++++
apply andb_true_intro.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
and (eq (Nless a a0) true) (eq (alist_sorted (cons (pair a0 y0) l1)) true)
+++++
split.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless a a0) true
+++++
apply (H1 0 1).
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply (H1 0 1).

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S O) (S O)
+++++
apply le_n.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply (H1 0 1).

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S O)) (length (cons (pair a y) (cons (pair a0 y0) l1)))
+++++
simpl in |- *.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply (H1 0 1).
simpl in |- *.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S O)) (S (S (length l1)))
+++++
apply le_n_S.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply (H1 0 1).
simpl in |- *.
apply le_n_S.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S O) (S (length l1))
+++++
apply le_n_S.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply (H1 0 1).
simpl in |- *.
apply le_n_S.
apply le_n_S.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le O (length l1)
+++++
apply le_O_n.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_sorted (cons (pair a0 y0) l1)) true
+++++
apply H0.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply H0.

*****
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (cons (pair a0 y0) l1))), eq (Nless (alist_nth_ad m (cons (pair a0 y0) l1)) (alist_nth_ad n (cons (pair a0 y0) l1))) true
+++++
intros.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply H0.
intros.

*****
H3 : le (S n) (length (cons (pair a0 y0) l1))
H2 : le (S m) n
m,n : nat
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad m (cons (pair a0 y0) l1)) (alist_nth_ad n (cons (pair a0 y0) l1))) true
+++++
apply (H1 (S m) (S n)).
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply H0.
intros.
apply (H1 (S m) (S n)).

*****
H3 : le (S n) (length (cons (pair a0 y0) l1))
H2 : le (S m) n
m,n : nat
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S m)) (S n)
+++++
apply le_n_S.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply H0.
intros.
apply (H1 (S m) (S n)).
apply le_n_S.

*****
H3 : le (S n) (length (cons (pair a0 y0) l1))
H2 : le (S m) n
m,n : nat
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S m) n
+++++
assumption.
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.
intro r.
elim r.
intros a y.
simple induction l0.
intro r0.
elim r0.
intros a0 y0.
intros.
change (andb (Nless a a0) (alist_sorted ((a0, y0) :: l1)) = true) in |- *.
apply andb_true_intro.
split.
apply H0.
intros.
apply (H1 (S m) (S n)).

*****
H3 : le (S n) (length (cons (pair a0 y0) l1))
H2 : le (S m) n
m,n : nat
H1 : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) (cons (pair a0 y0) l1)))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) (cons (pair a0 y0) l1)))\n (alist_nth_ad n (cons (pair a y) (cons (pair a0 y0) l1)))) true
H0 : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a0 y0) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a0 y0) l1))\n (alist_nth_ad n (cons (pair a0 y0) l1))) true,\neq (alist_sorted (cons (pair a0 y0) l1)) true
H : forall\n (_ : forall\n _ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length l1)),\n eq (Nless (alist_nth_ad m l1) (alist_nth_ad n l1)) true,\n eq (alist_sorted l1) true)\n (_ : forall (m n : nat) (_ : le (S m) n)\n (_ : le (S n) (length (cons (pair a y) l1))),\n eq\n (Nless (alist_nth_ad m (cons (pair a y) l1))\n (alist_nth_ad n (cons (pair a y) l1))) true),\neq (alist_sorted (cons (pair a y) l1)) true
l1 : list (prod ad A)
y0 : A
a0 : ad
r0 : prod ad A
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S n)) (length (cons (pair a y) (cons (pair a0 y0) l1)))
+++++
exact (le_n_S _ _ H3).
-----
Lemma alist_sorted_2_imp : forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma app_length :\n   forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.
-----
Lemma app_length : forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.

*****
A : Type
*****
forall (C : Type) (l l' : list C), eq (length (app l l')) (Init.Nat.add (length l) (length l'))
+++++
Proof.
-----
Lemma app_length : forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.
Proof.

*****
A : Type
*****
forall (C : Type) (l l' : list C), eq (length (app l l')) (Init.Nat.add (length l) (length l'))
+++++
simple induction l.
-----
Lemma app_length : forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.
Proof.
simple induction l.

*****
l : list C
C : Type
A : Type
*****
forall l' : list C, eq (length (app nil l')) (Init.Nat.add (length nil) (length l'))
+++++
trivial.
-----
Lemma app_length : forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.
Proof.
simple induction l.

*****
l : list C
C : Type
A : Type
*****
forall (a : C) (l : list C) (_ : forall l' : list C, eq (length (app l l')) (Init.Nat.add (length l) (length l'))) (l' : list C), eq (length (app (cons a l) l')) (Init.Nat.add (length (cons a l)) (length l'))
+++++
intros.
-----
Lemma app_length : forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.
Proof.
simple induction l.
intros.

*****
l' : list C
H : forall l' : list C,\neq (length (app l0 l')) (Init.Nat.add (length l0) (length l'))
l0 : list C
a : C
l : list C
C : Type
A : Type
*****
eq (length (app (cons a l0) l')) (Init.Nat.add (length (cons a l0)) (length l'))
+++++
simpl in |- *.
-----
Lemma app_length : forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
l' : list C
H : forall l' : list C,\neq (length (app l0 l')) (Init.Nat.add (length l0) (length l'))
l0 : list C
a : C
l : list C
C : Type
A : Type
*****
eq (S (length (app l0 l'))) (S (Init.Nat.add (length l0) (length l')))
+++++
rewrite (H l').
-----
Lemma app_length : forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (H l').

*****
l' : list C
H : forall l' : list C,\neq (length (app l0 l')) (Init.Nat.add (length l0) (length l'))
l0 : list C
a : C
l : list C
C : Type
A : Type
*****
eq (S (Init.Nat.add (length l0) (length l'))) (S (Init.Nat.add (length l0) (length l')))
+++++
reflexivity.
-----
Lemma app_length : forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma aapp_length :\n   forall l l':alist A, length (aapp A l l') = length l + length l'.
-----
Lemma aapp_length : forall l l':alist A, length (aapp A l l') = length l + length l'.

*****
A : Type
*****
forall l l' : alist A, eq (length (aapp A l l')) (Init.Nat.add (length l) (length l'))
+++++
Proof.
-----
Lemma aapp_length : forall l l':alist A, length (aapp A l l') = length l + length l'.
Proof.

*****
A : Type
*****
forall l l' : alist A, eq (length (aapp A l l')) (Init.Nat.add (length l) (length l'))
+++++
exact (app_length (ad * A)).
-----
Lemma aapp_length : forall l l':alist A, length (aapp A l l') = length l + length l'.
Proof.
exact (app_length (ad * A)).

*****

*****

+++++
Qed.
-----
Lemma alist_nth_ad_aapp_1 :\n   forall (l l':alist A) (n:nat),\n     S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.

*****
A : Type
*****
forall (l l' : alist A) (n : nat) (_ : le (S n) (length l)), eq (alist_nth_ad n (aapp A l l')) (alist_nth_ad n l)
+++++
Proof.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.

*****
A : Type
*****
forall (l l' : alist A) (n : nat) (_ : le (S n) (length l)), eq (alist_nth_ad n (aapp A l l')) (alist_nth_ad n l)
+++++
simple induction l.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (l' : alist A) (n : nat) (_ : le (S n) (length nil)), eq (alist_nth_ad n (aapp A nil l')) (alist_nth_ad n nil)
+++++
intros.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intros.

*****
H : le (S n) (length nil)
n : nat
l,l' : alist A
A : Type
*****
eq (alist_nth_ad n (aapp A nil l')) (alist_nth_ad n nil)
+++++
elim (le_Sn_O n H).
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (l' : alist A) (n : nat) (_ : le (S n) (length l)), eq (alist_nth_ad n (aapp A l l')) (alist_nth_ad n l)) (l' : alist A) (n : nat) (_ : le (S n) (length (cons a l))), eq (alist_nth_ad n (aapp A (cons a l) l')) (alist_nth_ad n (cons a l))
+++++
intro r.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (l' : alist A) (n : nat) (_ : le (S n) (length l)), eq (alist_nth_ad n (aapp A l l')) (alist_nth_ad n l)) (l' : alist A) (n : nat) (_ : le (S n) (length (cons r l))), eq (alist_nth_ad n (aapp A (cons r l) l')) (alist_nth_ad n (cons r l))
+++++
elim r.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall (l' : alist A) (n : nat) (_ : le (S n) (length l)), eq (alist_nth_ad n (aapp A l l')) (alist_nth_ad n l)) (l' : alist A) (n : nat) (_ : le (S n) (length (cons (pair a b) l))), eq (alist_nth_ad n (aapp A (cons (pair a b) l) l')) (alist_nth_ad n (cons (pair a b) l))
+++++
intros a y l' H l''.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l''.

*****
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l')),\neq (alist_nth_ad n (aapp A l' l'0)) (alist_nth_ad n l')
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (n : nat) (_ : le (S n) (length (cons (pair a y) l'))), eq (alist_nth_ad n (aapp A (cons (pair a y) l') l'')) (alist_nth_ad n (cons (pair a y) l'))
+++++
simple induction n.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l''.
simple induction n.

*****
n : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l')),\neq (alist_nth_ad n (aapp A l' l'0)) (alist_nth_ad n l')
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : le (S O) (length (cons (pair a y) l')), eq (alist_nth_ad O (aapp A (cons (pair a y) l') l'')) (alist_nth_ad O (cons (pair a y) l'))
+++++
trivial.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l''.
simple induction n.

*****
n : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l')),\neq (alist_nth_ad n (aapp A l' l'0)) (alist_nth_ad n l')
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (n : nat) (_ : forall _ : le (S n) (length (cons (pair a y) l')), eq (alist_nth_ad n (aapp A (cons (pair a y) l') l'')) (alist_nth_ad n (cons (pair a y) l'))) (_ : le (S (S n)) (length (cons (pair a y) l'))), eq (alist_nth_ad (S n) (aapp A (cons (pair a y) l') l'')) (alist_nth_ad (S n) (cons (pair a y) l'))
+++++
intros.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l''.
simple induction n.
intros.

*****
H1 : le (S (S n0)) (length (cons (pair a y) l'))
H0 : forall _ : le (S n0) (length (cons (pair a y) l')),\neq (alist_nth_ad n0 (aapp A (cons (pair a y) l') l''))\n (alist_nth_ad n0 (cons (pair a y) l'))
n,n0 : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l')),\neq (alist_nth_ad n (aapp A l' l'0)) (alist_nth_ad n l')
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_nth_ad (S n0) (aapp A (cons (pair a y) l') l'')) (alist_nth_ad (S n0) (cons (pair a y) l'))
+++++
simpl in |- *.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l''.
simple induction n.
intros.
simpl in |- *.

*****
H1 : le (S (S n0)) (length (cons (pair a y) l'))
H0 : forall _ : le (S n0) (length (cons (pair a y) l')),\neq (alist_nth_ad n0 (aapp A (cons (pair a y) l') l''))\n (alist_nth_ad n0 (cons (pair a y) l'))
n,n0 : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l')),\neq (alist_nth_ad n (aapp A l' l'0)) (alist_nth_ad n l')
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_nth_ad n0 (aapp A l' l'')) (alist_nth_ad n0 l')
+++++
apply H.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l''.
simple induction n.
intros.
simpl in |- *.
apply H.

*****
H1 : le (S (S n0)) (length (cons (pair a y) l'))
H0 : forall _ : le (S n0) (length (cons (pair a y) l')),\neq (alist_nth_ad n0 (aapp A (cons (pair a y) l') l''))\n (alist_nth_ad n0 (cons (pair a y) l'))
n,n0 : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l')),\neq (alist_nth_ad n (aapp A l' l'0)) (alist_nth_ad n l')
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S n0) (length l')
+++++
apply le_S_n.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l''.
simple induction n.
intros.
simpl in |- *.
apply H.
apply le_S_n.

*****
H1 : le (S (S n0)) (length (cons (pair a y) l'))
H0 : forall _ : le (S n0) (length (cons (pair a y) l')),\neq (alist_nth_ad n0 (aapp A (cons (pair a y) l') l''))\n (alist_nth_ad n0 (cons (pair a y) l'))
n,n0 : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l')),\neq (alist_nth_ad n (aapp A l' l'0)) (alist_nth_ad n l')
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S n0)) (S (length l'))
+++++
exact H1.
-----
Lemma alist_nth_ad_aapp_1 : forall (l l':alist A) (n:nat), S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma alist_nth_ad_aapp_2 :\n   forall (l l':alist A) (n:nat),\n     S n <= length l' ->\n     alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.

*****
A : Type
*****
forall (l l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length l) n) (aapp A l l')) (alist_nth_ad n l')
+++++
Proof.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.

*****
A : Type
*****
forall (l l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length l) n) (aapp A l l')) (alist_nth_ad n l')
+++++
simple induction l.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length nil) n) (aapp A nil l')) (alist_nth_ad n l')
+++++
trivial.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length l) n) (aapp A l l')) (alist_nth_ad n l')) (l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length (cons a l)) n) (aapp A (cons a l) l')) (alist_nth_ad n l')
+++++
intro r.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length l) n) (aapp A l l')) (alist_nth_ad n l')) (l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length (cons r l)) n) (aapp A (cons r l) l')) (alist_nth_ad n l')
+++++
elim r.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall (l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length l) n) (aapp A l l')) (alist_nth_ad n l')) (l' : alist A) (n : nat) (_ : le (S n) (length l')), eq (alist_nth_ad (Init.Nat.add (length (cons (pair a b) l)) n) (aapp A (cons (pair a b) l) l')) (alist_nth_ad n l')
+++++
intros a y l' H l'' n H0.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l'' n H0.

*****
H0 : le (S n) (length l'')
n : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l'0)),\neq (alist_nth_ad (Init.Nat.add (length l') n) (aapp A l' l'0))\n (alist_nth_ad n l'0)
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_nth_ad (Init.Nat.add (length (cons (pair a y) l')) n) (aapp A (cons (pair a y) l') l'')) (alist_nth_ad n l'')
+++++
simpl in |- *.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l'' n H0.
simpl in |- *.

*****
H0 : le (S n) (length l'')
n : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l'0)),\neq (alist_nth_ad (Init.Nat.add (length l') n) (aapp A l' l'0))\n (alist_nth_ad n l'0)
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_nth_ad (Init.Nat.add (length l') n) (aapp A l' l'')) (alist_nth_ad n l'')
+++++
apply H.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.
simple induction l.
intro r.
elim r.
intros a y l' H l'' n H0.
simpl in |- *.
apply H.

*****
H0 : le (S n) (length l'')
n : nat
l'' : alist A
H : forall (l'0 : alist A) (n : nat) (_ : le (S n) (length l'0)),\neq (alist_nth_ad (Init.Nat.add (length l') n) (aapp A l' l'0))\n (alist_nth_ad n l'0)
l' : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S n) (length l'')
+++++
exact H0.
-----
Lemma alist_nth_ad_aapp_2 : forall (l l':alist A) (n:nat), S n <= length l' -> alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma interval_split :\n   forall p q n:nat,\n     S n <= p + q -> {n' : nat | S n' <= q /\ n = p + n'} + {S n <= p}.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.

*****
A : Type
*****
forall (p q n : nat) (_ : le (S n) (Init.Nat.add p q)), sumor (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p n')))) (le (S n) p)
+++++
Proof.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.

*****
A : Type
*****
forall (p q n : nat) (_ : le (S n) (Init.Nat.add p q)), sumor (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p n')))) (le (S n) p)
+++++
simple induction p.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.

*****
p : nat
A : Type
*****
forall (q n : nat) (_ : le (S n) (Init.Nat.add O q)), sumor (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add O n')))) (le (S n) O)
+++++
simpl in |- *.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
simpl in |- *.

*****
p : nat
A : Type
*****
forall (q n : nat) (_ : le (S n) q), sumor (sig (fun n' : nat => and (le (S n') q) (eq n n'))) (le (S n) O)
+++++
intros.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
simpl in |- *.
intros.

*****
H : le (S n) q
p,q,n : nat
A : Type
*****
sumor (sig (fun n' : nat => and (le (S n') q) (eq n n'))) (le (S n) O)
+++++
left.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
simpl in |- *.
intros.
left.

*****
H : le (S n) q
p,q,n : nat
A : Type
*****
sig (fun n' : nat => and (le (S n') q) (eq n n'))
+++++
split with n.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
simpl in |- *.
intros.
left.
split with n.

*****
H : le (S n) q
p,q,n : nat
A : Type
*****
and (le (S n) q) (eq n n)
+++++
split.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
simpl in |- *.
intros.
left.
split with n.
split.

*****
H : le (S n) q
p,q,n : nat
A : Type
*****
le (S n) q
+++++
assumption.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
simpl in |- *.
intros.
left.
split with n.
split.

*****
H : le (S n) q
p,q,n : nat
A : Type
*****
eq n n
+++++
reflexivity.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.

*****
p : nat
A : Type
*****
forall (n : nat) (_ : forall (q n0 : nat) (_ : le (S n0) (Init.Nat.add n q)), sumor (sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add n n')))) (le (S n0) n)) (q n0 : nat) (_ : le (S n0) (Init.Nat.add (S n) q)), sumor (sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add (S n) n')))) (le (S n0) (S n))
+++++
intros p' H q.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.

*****
q : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
forall (n : nat) (_ : le (S n) (Init.Nat.add (S p') q)), sumor (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add (S p') n')))) (le (S n) (S p'))
+++++
simple induction n.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.

*****
q,n : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
forall _ : le (S O) (Init.Nat.add (S p') q), sumor (sig (fun n' : nat => and (le (S n') q) (eq O (Init.Nat.add (S p') n')))) (le (S O) (S p'))
+++++
intros.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.

*****
H0 : le (S O) (Init.Nat.add (S p') q)
q,n : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
sumor (sig (fun n' : nat => and (le (S n') q) (eq O (Init.Nat.add (S p') n')))) (le (S O) (S p'))
+++++
right.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
right.

*****
H0 : le (S O) (Init.Nat.add (S p') q)
q,n : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
le (S O) (S p')
+++++
apply le_n_S.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
right.
apply le_n_S.

*****
H0 : le (S O) (Init.Nat.add (S p') q)
q,n : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
le O p'
+++++
apply le_O_n.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.

*****
q,n : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
forall (n : nat) (_ : forall _ : le (S n) (Init.Nat.add (S p') q), sumor (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add (S p') n')))) (le (S n) (S p'))) (_ : le (S (S n)) (Init.Nat.add (S p') q)), sumor (sig (fun n' : nat => and (le (S n') q) (eq (S n) (Init.Nat.add (S p') n')))) (le (S (S n)) (S p'))
+++++
intros.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.

*****
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
sumor (sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))) (le (S (S n0)) (S p'))
+++++
elim (H _ _ (le_S_n _ _ H1)).
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).

*****
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
forall _ : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n'))), sumor (sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))) (le (S (S n0)) (S p'))
+++++
intro H2.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.

*****
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
sumor (sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))) (le (S (S n0)) (S p'))
+++++
left.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.

*****
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))
+++++
elim H2.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.
elim H2.

*****
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
forall (x : nat) (_ : and (le (S x) q) (eq n0 (Init.Nat.add p' x))), sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))
+++++
intros n' H3.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.
elim H2.
intros n' H3.

*****
H3 : and (le (S n') q) (eq n0 (Init.Nat.add p' n'))
n' : nat
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))
+++++
elim H3.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.
elim H2.
intros n' H3.
elim H3.

*****
H3 : and (le (S n') q) (eq n0 (Init.Nat.add p' n'))
n' : nat
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
forall (_ : le (S n') q) (_ : eq n0 (Init.Nat.add p' n')), sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))
+++++
intros H4 H5.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.
elim H2.
intros n' H3.
elim H3.
intros H4 H5.

*****
H5 : eq n0 (Init.Nat.add p' n')
H4 : le (S n') q
H3 : and (le (S n') q) (eq n0 (Init.Nat.add p' n'))
n' : nat
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))
+++++
split with n'.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.
elim H2.
intros n' H3.
elim H3.
intros H4 H5.
split with n'.

*****
H5 : eq n0 (Init.Nat.add p' n')
H4 : le (S n') q
H3 : and (le (S n') q) (eq n0 (Init.Nat.add p' n'))
n' : nat
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n'))
+++++
split.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.
elim H2.
intros n' H3.
elim H3.
intros H4 H5.
split with n'.
split.

*****
H5 : eq n0 (Init.Nat.add p' n')
H4 : le (S n') q
H3 : and (le (S n') q) (eq n0 (Init.Nat.add p' n'))
n' : nat
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
le (S n') q
+++++
assumption.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.
elim H2.
intros n' H3.
elim H3.
intros H4 H5.
split with n'.
split.

*****
H5 : eq n0 (Init.Nat.add p' n')
H4 : le (S n') q
H3 : and (le (S n') q) (eq n0 (Init.Nat.add p' n'))
n' : nat
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
eq (S n0) (Init.Nat.add (S p') n')
+++++
rewrite H5.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
left.
elim H2.
intros n' H3.
elim H3.
intros H4 H5.
split with n'.
split.
rewrite H5.

*****
H5 : eq n0 (Init.Nat.add p' n')
H4 : le (S n') q
H3 : and (le (S n') q) (eq n0 (Init.Nat.add p' n'))
n' : nat
H2 : sig (fun n' : nat => and (le (S n') q) (eq n0 (Init.Nat.add p' n')))
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
eq (S (Init.Nat.add p' n')) (Init.Nat.add (S p') n')
+++++
reflexivity.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).

*****
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
forall _ : le (S n0) p', sumor (sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))) (le (S (S n0)) (S p'))
+++++
intro H2.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.

*****
H2 : le (S n0) p'
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
sumor (sig (fun n' : nat => and (le (S n') q) (eq (S n0) (Init.Nat.add (S p') n')))) (le (S (S n0)) (S p'))
+++++
right.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
right.

*****
H2 : le (S n0) p'
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
le (S (S n0)) (S p')
+++++
apply le_n_S.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.
intros p' H q.
simple induction n.
intros.
elim (H _ _ (le_S_n _ _ H1)).
intro H2.
right.
apply le_n_S.

*****
H2 : le (S n0) p'
H1 : le (S (S n0)) (Init.Nat.add (S p') q)
H0 : forall _ : le (S n0) (Init.Nat.add (S p') q),\nsumor\n (sig\n (fun n' : nat =>\n and (le (S n') q) (eq n0 (Init.Nat.add (S p') n'))))\n (le (S n0) (S p'))
q,n,n0 : nat
H : forall (q n : nat) (_ : le (S n) (Init.Nat.add p' q)),\nsumor\n (sig (fun n' : nat => and (le (S n') q) (eq n (Init.Nat.add p' n'))))\n (le (S n) p')
p,p' : nat
A : Type
*****
le (S n0) p'
+++++
assumption.
-----
Lemma interval_split : forall p q n:nat, S n <= p + q -> {n' : nat | S n' <= q /\\ n = p + n'} + {S n <= p}.
Proof.
simple induction p.

*****

*****

+++++
Qed.
-----
Lemma alist_conc_sorted :\n   forall l l':alist A,\n     alist_sorted_2 l ->\n     alist_sorted_2 l' ->\n     (forall n n':nat,\n        S n <= length l ->\n        S n' <= length l' ->\n        Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) ->\n     alist_sorted_2 (aapp A l l').
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').

*****
A : Type
*****
forall (l l' : alist A) (_ : alist_sorted_2 l) (_ : alist_sorted_2 l') (_ : forall (n n' : nat) (_ : le (S n) (length l)) (_ : le (S n') (length l')), eq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true), alist_sorted_2 (aapp A l l')
+++++
Proof.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.

*****
A : Type
*****
forall (l l' : alist A) (_ : alist_sorted_2 l) (_ : alist_sorted_2 l') (_ : forall (n n' : nat) (_ : le (S n) (length l)) (_ : le (S n') (length l')), eq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true), alist_sorted_2 (aapp A l l')
+++++
unfold alist_sorted_2 in |- *.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.

*****
A : Type
*****
forall (l l' : alist A) (_ : forall (m n : nat) (_ : lt m n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true) (_ : forall (m n : nat) (_ : lt m n) (_ : le (S n) (length l')), eq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true) (_ : forall (n n' : nat) (_ : le (S n) (length l)) (_ : le (S n') (length l')), eq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true) (m n : nat) (_ : lt m n) (_ : le (S n) (length (aapp A l l'))), eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
unfold lt in |- *.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.

*****
A : Type
*****
forall (l l' : alist A) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true) (_ : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')), eq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true) (_ : forall (n n' : nat) (_ : le (S n) (length l)) (_ : le (S n') (length l')), eq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true) (m n : nat) (_ : le (S m) n) (_ : le (S n) (length (aapp A l l'))), eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
intros.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.

*****
H3 : le (S n) (length (aapp A l l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
rewrite (aapp_length l l') in H3.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.

*****
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).

*****
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall _ : sig (fun n' : nat => and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n'))), eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
intro H4.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.

*****
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
elim H4.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.

*****
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall (x : nat) (_ : and (le (S x) (length l')) (eq m (Init.Nat.add (length l) x))), eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
intros m' H5.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.

*****
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
elim H5.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.

*****
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall (_ : le (S m') (length l')) (_ : eq m (Init.Nat.add (length l) m')), eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
intros.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.

*****
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
rewrite H7.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.

*****
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad (Init.Nat.add (length l) m') (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).

*****
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
elim (interval_split (length l) (length l') n H3).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).

*****
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall _ : sig (fun n' : nat => and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))), eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
intro H8.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.

*****
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
elim H8.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.

*****
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall (x : nat) (_ : and (le (S x) (length l')) (eq n (Init.Nat.add (length l) x))), eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
intros n' H9.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.

*****
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
elim H9.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.

*****
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall (_ : le (S n') (length l')) (_ : eq n (Init.Nat.add (length l) n')), eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
intros.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
rewrite H11.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.
rewrite H11.

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad (Init.Nat.add (length l) n') (aapp A l l'))) true
+++++
rewrite (alist_nth_ad_aapp_2 l l' n' H10).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.
rewrite H11.
rewrite (alist_nth_ad_aapp_2 l l' n' H10).

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad n' l')) true
+++++
apply H0.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.
rewrite H11.
rewrite (alist_nth_ad_aapp_2 l l' n' H10).
apply H0.

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S m') n'
+++++
rewrite H7 in H2.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.
rewrite H11.
rewrite (alist_nth_ad_aapp_2 l l' n' H10).
apply H0.
rewrite H7 in H2.

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S m') n'
+++++
rewrite H11 in H2.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.
rewrite H11.
rewrite (alist_nth_ad_aapp_2 l l' n' H10).
apply H0.
rewrite H7 in H2.
rewrite H11 in H2.

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) (Init.Nat.add (length l) n')
m,n,m',n' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S m') n'
+++++
change (S (length l) + m' <= length l + n') in H2.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.
rewrite H11.
rewrite (alist_nth_ad_aapp_2 l l' n' H10).
apply H0.
rewrite H7 in H2.
rewrite H11 in H2.
change (S (length l) + m' <= length l + n') in H2.

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (Init.Nat.add (S (length l)) m') (Init.Nat.add (length l) n')
m,n,m',n' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S m') n'
+++++
rewrite (plus_Snm_nSm (length l) m') in H2.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.
rewrite H11.
rewrite (alist_nth_ad_aapp_2 l l' n' H10).
apply H0.
rewrite H7 in H2.
rewrite H11 in H2.
change (S (length l) + m' <= length l + n') in H2.
rewrite (plus_Snm_nSm (length l) m') in H2.

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (Init.Nat.add (length l) (S m')) (Init.Nat.add (length l) n')
m,n,m',n' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S m') n'
+++++
exact ((fun p n m:nat => plus_le_reg_l n m p) (length l) (S m') n' H2).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
elim H8.
intros n' H9.
elim H9.
intros.
rewrite H11.
rewrite (alist_nth_ad_aapp_2 l l' n' H10).
apply H0.

*****
H11 : eq n (Init.Nat.add (length l) n')
H10 : le (S n') (length l')
H9 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H8 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S n') (length l')
+++++
exact H10.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).

*****
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall _ : le (S n) (length l), eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
intro H8.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
m' : nat
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
rewrite H7 in H2.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
cut (S (length l) <= length l).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall _ : le (S (length l)) (length l), eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
intros.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).
intros.

*****
H9 : le (S (length l)) (length l)
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m' l') (alist_nth_ad n (aapp A l l'))) true
+++++
elim (le_Sn_n _ H9).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S (length l)) (length l)
+++++
apply le_trans with (m := S n).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).
apply le_trans with (m := S n).

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S (length l)) (S n)
+++++
apply le_n_S.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).
apply le_trans with (m := S n).
apply le_n_S.

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (length l) n
+++++
apply le_trans with (m := S (length l + m')).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).
apply le_trans with (m := S n).
apply le_n_S.
apply le_trans with (m := S (length l + m')).

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (length l) (S (Init.Nat.add (length l) m'))
+++++
apply le_trans with (m := length l + m').
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).
apply le_trans with (m := S n).
apply le_n_S.
apply le_trans with (m := S (length l + m')).
apply le_trans with (m := length l + m').

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (length l) (Init.Nat.add (length l) m')
+++++
apply le_plus_l.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).
apply le_trans with (m := S n).
apply le_n_S.
apply le_trans with (m := S (length l + m')).
apply le_trans with (m := length l + m').

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (Init.Nat.add (length l) m') (S (Init.Nat.add (length l) m'))
+++++
apply le_n_Sn.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).
apply le_trans with (m := S n).
apply le_n_S.
apply le_trans with (m := S (length l + m')).

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S (Init.Nat.add (length l) m')) n
+++++
exact H2.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
elim H4.
intros m' H5.
elim H5.
intros.
rewrite H7.
rewrite (alist_nth_ad_aapp_2 l l' m' H6).
elim (interval_split (length l) (length l') n H3).
intro H8.
rewrite H7 in H2.
cut (S (length l) <= length l).
apply le_trans with (m := S n).

*****
H8 : le (S n) (length l)
H7 : eq m (Init.Nat.add (length l) m')
H6 : le (S m') (length l')
H5 : and (le (S m') (length l')) (eq m (Init.Nat.add (length l) m'))
H4 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq m (Init.Nat.add (length l) n')))
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S (Init.Nat.add (length l) m')) n
m,n,m' : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
le (S n) (length l)
+++++
exact H8.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).

*****
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall _ : le (S m) (length l), eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
intro H4.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.

*****
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m (aapp A l l')) (alist_nth_ad n (aapp A l l'))) true
+++++
rewrite (alist_nth_ad_aapp_1 l l' m H4).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).

*****
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
elim (interval_split (length l) (length l') n H3).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).

*****
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall _ : sig (fun n' : nat => and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))), eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
intro H5.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.

*****
H5 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
elim H5.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.
elim H5.

*****
H5 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall (x : nat) (_ : and (le (S x) (length l')) (eq n (Init.Nat.add (length l) x))), eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
intros n' H6.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.
elim H5.
intros n' H6.

*****
H6 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H5 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
elim H6.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.
elim H5.
intros n' H6.
elim H6.

*****
H6 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H5 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall (_ : le (S n') (length l')) (_ : eq n (Init.Nat.add (length l) n')), eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
intros.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.
elim H5.
intros n' H6.
elim H6.
intros.

*****
H8 : eq n (Init.Nat.add (length l) n')
H7 : le (S n') (length l')
H6 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H5 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
rewrite H8.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.
elim H5.
intros n' H6.
elim H6.
intros.
rewrite H8.

*****
H8 : eq n (Init.Nat.add (length l) n')
H7 : le (S n') (length l')
H6 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H5 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad (Init.Nat.add (length l) n') (aapp A l l'))) true
+++++
rewrite (alist_nth_ad_aapp_2 l l' n' H7).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.
elim H5.
intros n' H6.
elim H6.
intros.
rewrite H8.
rewrite (alist_nth_ad_aapp_2 l l' n' H7).

*****
H8 : eq n (Init.Nat.add (length l) n')
H7 : le (S n') (length l')
H6 : and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n'))
n' : nat
H5 : sig\n (fun n' : nat =>\n and (le (S n') (length l')) (eq n (Init.Nat.add (length l) n')))
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad n' l')) true
+++++
exact (H1 m n' H4 H7).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).

*****
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
forall _ : le (S n) (length l), eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
intro H5.
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.

*****
H5 : le (S n) (length l)
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad n (aapp A l l'))) true
+++++
rewrite (alist_nth_ad_aapp_1 l l' n H5).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).
intro H4.
rewrite (alist_nth_ad_aapp_1 l l' m H4).
elim (interval_split (length l) (length l') n H3).
intro H5.
rewrite (alist_nth_ad_aapp_1 l l' n H5).

*****
H5 : le (S n) (length l)
H4 : le (S m) (length l)
H3 : le (S n) (Init.Nat.add (length l) (length l'))
H2 : le (S m) n
m,n : nat
H1 : forall (n n' : nat) (_ : le (S n) (length l))\n (_ : le (S n') (length l')),\neq (Nless (alist_nth_ad n l) (alist_nth_ad n' l')) true
H0 : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l')),\neq (Nless (alist_nth_ad m l') (alist_nth_ad n l')) true
H : forall (m n : nat) (_ : le (S m) n) (_ : le (S n) (length l)),\neq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
l,l' : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
+++++
exact (H m n H2 H5).
-----
Lemma alist_conc_sorted : forall l l':alist A, alist_sorted_2 l -> alist_sorted_2 l' -> (forall n n':nat, S n <= length l -> S n' <= length l' -> Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) -> alist_sorted_2 (aapp A l l').
Proof.
unfold alist_sorted_2 in |- *.
unfold lt in |- *.
intros.
rewrite (aapp_length l l') in H3.
elim (interval_split (length l) (length l') m (le_trans _ _ _ (le_n_S _ _ (lt_le_weak m n H2)) H3)).

*****

*****

+++++
Qed.
-----
Lemma alist_nth_ad_semantics :\n   forall (l:alist A) (n:nat),\n     S n <= length l ->\n     {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.

*****
A : Type
*****
forall (l : alist A) (n : nat) (_ : le (S n) (length l)), sig (fun y : A => eq (alist_semantics A l (alist_nth_ad n l)) (Some y))
+++++
Proof.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.

*****
A : Type
*****
forall (l : alist A) (n : nat) (_ : le (S n) (length l)), sig (fun y : A => eq (alist_semantics A l (alist_nth_ad n l)) (Some y))
+++++
simple induction l.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (n : nat) (_ : le (S n) (length nil)), sig (fun y : A => eq (alist_semantics A nil (alist_nth_ad n nil)) (Some y))
+++++
intros.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intros.

*****
H : le (S n) (length nil)
n : nat
l : alist A
A : Type
*****
sig (fun y : A => eq (alist_semantics A nil (alist_nth_ad n nil)) (Some y))
+++++
elim (le_Sn_O _ H).
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (n : nat) (_ : le (S n) (length l)), sig (fun y : A => eq (alist_semantics A l (alist_nth_ad n l)) (Some y))) (n : nat) (_ : le (S n) (length (cons a l))), sig (fun y : A => eq (alist_semantics A (cons a l) (alist_nth_ad n (cons a l))) (Some y))
+++++
intro r.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (n : nat) (_ : le (S n) (length l)), sig (fun y : A => eq (alist_semantics A l (alist_nth_ad n l)) (Some y))) (n : nat) (_ : le (S n) (length (cons r l))), sig (fun y : A => eq (alist_semantics A (cons r l) (alist_nth_ad n (cons r l))) (Some y))
+++++
elim r.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall (n : nat) (_ : le (S n) (length l)), sig (fun y : A => eq (alist_semantics A l (alist_nth_ad n l)) (Some y))) (n : nat) (_ : le (S n) (length (cons (pair a b) l))), sig (fun y : A => eq (alist_semantics A (cons (pair a b) l) (alist_nth_ad n (cons (pair a b) l))) (Some y))
+++++
intros a y l0 H.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.

*****
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (n : nat) (_ : le (S n) (length (cons (pair a y) l0))), sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad n (cons (pair a y) l0))) (Some y0))
+++++
simple induction n.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.

*****
n : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : le (S O) (length (cons (pair a y) l0)), sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad O (cons (pair a y) l0))) (Some y0))
+++++
simpl in |- *.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
simpl in |- *.

*****
n : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : le (S O) (S (length l0)), sig (fun y0 : A => eq (if N.eqb a a then Some y else alist_semantics A l0 a) (Some y0))
+++++
intro.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
simpl in |- *.
intro.

*****
H0 : le (S O) (S (length l0))
n : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun y0 : A => eq (if N.eqb a a then Some y else alist_semantics A l0 a) (Some y0))
+++++
split with y.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
simpl in |- *.
intro.
split with y.

*****
H0 : le (S O) (S (length l0))
n : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb a a then Some y else alist_semantics A l0 a) (Some y)
+++++
rewrite (Neqb_correct a).
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
simpl in |- *.
intro.
split with y.
rewrite (Neqb_correct a).

*****
H0 : le (S O) (S (length l0))
n : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.

*****
n : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (n : nat) (_ : forall _ : le (S n) (length (cons (pair a y) l0)), sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad n (cons (pair a y) l0))) (Some y0))) (_ : le (S (S n)) (length (cons (pair a y) l0))), sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n) (cons (pair a y) l0))) (Some y0))
+++++
intros.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.

*****
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y0))
+++++
elim (H _ (le_S_n _ _ H0)).
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).

*****
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (x : A) (_ : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some x)), sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y0))
+++++
intros y0 H2.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.

*****
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y0))
+++++
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).

*****
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (N.eqb a (alist_nth_ad n0 l0)) true, sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y0))
+++++
intro H3.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) true
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y0))
+++++
split with y.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.
split with y.

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) true
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y)
+++++
rewrite (Neqb_complete _ _ H3).
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.
split with y.
rewrite (Neqb_complete _ _ H3).

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) true
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair (alist_nth_ad n0 l0) y) l0) (alist_nth_ad (S n0) (cons (pair (alist_nth_ad n0 l0) y) l0))) (Some y)
+++++
simpl in |- *.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.
split with y.
rewrite (Neqb_complete _ _ H3).
simpl in |- *.

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) true
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb (alist_nth_ad n0 l0) (alist_nth_ad n0 l0) then Some y else alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y)
+++++
rewrite (Neqb_correct (alist_nth_ad n0 l0)).
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.
split with y.
rewrite (Neqb_complete _ _ H3).
simpl in |- *.
rewrite (Neqb_correct (alist_nth_ad n0 l0)).

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) true
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Some y) (Some y)
+++++
reflexivity.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).

*****
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (N.eqb a (alist_nth_ad n0 l0)) false, sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y0))
+++++
intro H3.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) false
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun y0 : A => eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y0))
+++++
split with y0.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.
split with y0.

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) false
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a y) l0) (alist_nth_ad (S n0) (cons (pair a y) l0))) (Some y0)
+++++
simpl in |- *.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.
split with y0.
simpl in |- *.

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) false
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb a (alist_nth_ad n0 l0) then Some y else alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
+++++
rewrite H3.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction n.
intros.
elim (H _ (le_S_n _ _ H0)).
intros y0 H2.
elim (sumbool_of_bool (Neqb a (alist_nth_ad n0 l0))).
intro H3.
split with y0.
simpl in |- *.
rewrite H3.

*****
H3 : eq (N.eqb a (alist_nth_ad n0 l0)) false
H2 : eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
y0 : A
H0 : le (S (S n0)) (length (cons (pair a y) l0))
X : forall _ : le (S n0) (length (cons (pair a y) l0)),\nsig\n (fun y0 : A =>\n eq\n (alist_semantics A (cons (pair a y) l0)\n (alist_nth_ad n0 (cons (pair a y) l0))) (Some y0))
n,n0 : nat
H : forall (n : nat) (_ : le (S n) (length l0)),\nsig\n (fun y : A => eq (alist_semantics A l0 (alist_nth_ad n l0)) (Some y))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A l0 (alist_nth_ad n0 l0)) (Some y0)
+++++
assumption.
-----
Lemma alist_nth_ad_semantics : forall (l:alist A) (n:nat), S n <= length l -> {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_nth_ad :\n   forall (m:Map A) (pf:ad -> ad) (l:alist A),\n     l =\n     MapFold1 A (alist A) (anil A) (aapp A)\n       (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m ->\n     forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.
-----
Lemma alist_of_Map_nth_ad : forall (m:Map A) (pf:ad -> ad) (l:alist A), l = MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m -> forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.

*****
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (l : alist A) (_ : eq l (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) pf m)) (n : nat) (_ : le (S n) (length l)), sig (fun a' : ad => eq (alist_nth_ad n l) (pf a'))
+++++
Proof.
-----
Lemma alist_of_Map_nth_ad : forall (m:Map A) (pf:ad -> ad) (l:alist A), l = MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m -> forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.
Proof.

*****
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (l : alist A) (_ : eq l (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) pf m)) (n : nat) (_ : le (S n) (length l)), sig (fun a' : ad => eq (alist_nth_ad n l) (pf a'))
+++++
intros.
-----
Lemma alist_of_Map_nth_ad : forall (m:Map A) (pf:ad -> ad) (l:alist A), l = MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m -> forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.
Proof.
intros.

*****
H0 : le (S n) (length l)
n : nat
H : eq l\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) pf m)
l : alist A
pf : forall _ : ad, ad
m : Map A
A : Type
*****
sig (fun a' : ad => eq (alist_nth_ad n l) (pf a'))
+++++
elim (alist_nth_ad_semantics l n H0).
-----
Lemma alist_of_Map_nth_ad : forall (m:Map A) (pf:ad -> ad) (l:alist A), l = MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m -> forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.
Proof.
intros.
elim (alist_nth_ad_semantics l n H0).

*****
H0 : le (S n) (length l)
n : nat
H : eq l\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) pf m)
l : alist A
pf : forall _ : ad, ad
m : Map A
A : Type
*****
forall (x : A) (_ : eq (alist_semantics A l (alist_nth_ad n l)) (Some x)), sig (fun a' : ad => eq (alist_nth_ad n l) (pf a'))
+++++
intros y H1.
-----
Lemma alist_of_Map_nth_ad : forall (m:Map A) (pf:ad -> ad) (l:alist A), l = MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m -> forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.
Proof.
intros.
elim (alist_nth_ad_semantics l n H0).
intros y H1.

*****
H1 : eq (alist_semantics A l (alist_nth_ad n l)) (Some y)
y : A
H0 : le (S n) (length l)
n : nat
H : eq l\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) pf m)
l : alist A
pf : forall _ : ad, ad
m : Map A
A : Type
*****
sig (fun a' : ad => eq (alist_nth_ad n l) (pf a'))
+++++
apply (alist_of_Map_semantics_1_1 A m pf (alist_nth_ad n l) y).
-----
Lemma alist_of_Map_nth_ad : forall (m:Map A) (pf:ad -> ad) (l:alist A), l = MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m -> forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.
Proof.
intros.
elim (alist_nth_ad_semantics l n H0).
intros y H1.
apply (alist_of_Map_semantics_1_1 A m pf (alist_nth_ad n l) y).

*****
H1 : eq (alist_semantics A l (alist_nth_ad n l)) (Some y)
y : A
H0 : le (S n) (length l)
n : nat
H : eq l\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) pf m)
l : alist A
pf : forall _ : ad, ad
m : Map A
A : Type
*****
eq (alist_semantics A (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) pf m) (alist_nth_ad n l)) (Some y)
+++++
rewrite <- H.
-----
Lemma alist_of_Map_nth_ad : forall (m:Map A) (pf:ad -> ad) (l:alist A), l = MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m -> forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.
Proof.
intros.
elim (alist_nth_ad_semantics l n H0).
intros y H1.
apply (alist_of_Map_semantics_1_1 A m pf (alist_nth_ad n l) y).
rewrite <- H.

*****
H1 : eq (alist_semantics A l (alist_nth_ad n l)) (Some y)
y : A
H0 : le (S n) (length l)
n : nat
H : eq l\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) pf m)
l : alist A
pf : forall _ : ad, ad
m : Map A
A : Type
*****
eq (alist_semantics A l (alist_nth_ad n l)) (Some y)
+++++
assumption.
-----
Lemma alist_of_Map_nth_ad : forall (m:Map A) (pf:ad -> ad) (l:alist A), l = MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m -> forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.
Proof.
intros.
elim (alist_nth_ad_semantics l n H0).
intros y H1.
apply (alist_of_Map_semantics_1_1 A m pf (alist_nth_ad n l) y).
rewrite <- H.
assumption.

*****

*****

+++++
Qed.
-----
Definition ad_monotonic (pf:ad -> ad) :=\n    forall a a':ad, Nless a a' = true -> Nless (pf a) (pf a') = true.
-----
Lemma Ndouble_monotonic : ad_monotonic Ndouble.
-----
Lemma Ndouble_monotonic : ad_monotonic Ndouble.

*****
A : Type
*****
ad_monotonic N.double
+++++
Proof.
-----
Lemma Ndouble_monotonic : ad_monotonic Ndouble.
Proof.

*****
A : Type
*****
ad_monotonic N.double
+++++
unfold ad_monotonic in |- *.
-----
Lemma Ndouble_monotonic : ad_monotonic Ndouble.
Proof.
unfold ad_monotonic in |- *.

*****
A : Type
*****
forall (a a' : ad) (_ : eq (Nless a a') true), eq (Nless (N.double a) (N.double a')) true
+++++
intros.
-----
Lemma Ndouble_monotonic : ad_monotonic Ndouble.
Proof.
unfold ad_monotonic in |- *.
intros.

*****
H : eq (Nless a a') true
a,a' : ad
A : Type
*****
eq (Nless (N.double a) (N.double a')) true
+++++
rewrite Nless_def_1.
-----
Lemma Ndouble_monotonic : ad_monotonic Ndouble.
Proof.
unfold ad_monotonic in |- *.
intros.
rewrite Nless_def_1.

*****
H : eq (Nless a a') true
a,a' : ad
A : Type
*****
eq (Nless a a') true
+++++
assumption.
-----
Lemma Ndouble_monotonic : ad_monotonic Ndouble.
Proof.
unfold ad_monotonic in |- *.
intros.
rewrite Nless_def_1.
assumption.

*****

*****

+++++
Qed.
-----
Lemma Ndouble_plus_one_monotonic : ad_monotonic Ndouble_plus_one.
-----
Lemma Ndouble_plus_one_monotonic : ad_monotonic Ndouble_plus_one.

*****
A : Type
*****
ad_monotonic N.succ_double
+++++
Proof.
-----
Lemma Ndouble_plus_one_monotonic : ad_monotonic Ndouble_plus_one.
Proof.

*****
A : Type
*****
ad_monotonic N.succ_double
+++++
unfold ad_monotonic in |- *.
-----
Lemma Ndouble_plus_one_monotonic : ad_monotonic Ndouble_plus_one.
Proof.
unfold ad_monotonic in |- *.

*****
A : Type
*****
forall (a a' : ad) (_ : eq (Nless a a') true), eq (Nless (N.succ_double a) (N.succ_double a')) true
+++++
intros.
-----
Lemma Ndouble_plus_one_monotonic : ad_monotonic Ndouble_plus_one.
Proof.
unfold ad_monotonic in |- *.
intros.

*****
H : eq (Nless a a') true
a,a' : ad
A : Type
*****
eq (Nless (N.succ_double a) (N.succ_double a')) true
+++++
rewrite Nless_def_2.
-----
Lemma Ndouble_plus_one_monotonic : ad_monotonic Ndouble_plus_one.
Proof.
unfold ad_monotonic in |- *.
intros.
rewrite Nless_def_2.

*****
H : eq (Nless a a') true
a,a' : ad
A : Type
*****
eq (Nless a a') true
+++++
assumption.
-----
Lemma Ndouble_plus_one_monotonic : ad_monotonic Ndouble_plus_one.
Proof.
unfold ad_monotonic in |- *.
intros.
rewrite Nless_def_2.
assumption.

*****

*****

+++++
Qed.
-----
Lemma ad_comp_monotonic :\n   forall pf pf':ad -> ad,\n     ad_monotonic pf ->\n     ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).
-----
Lemma ad_comp_monotonic : forall pf pf':ad -> ad, ad_monotonic pf -> ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).

*****
A : Type
*****
forall (pf pf' : forall _ : ad, ad) (_ : ad_monotonic pf) (_ : ad_monotonic pf'), ad_monotonic (fun a0 : ad => pf (pf' a0))
+++++
Proof.
-----
Lemma ad_comp_monotonic : forall pf pf':ad -> ad, ad_monotonic pf -> ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).
Proof.

*****
A : Type
*****
forall (pf pf' : forall _ : ad, ad) (_ : ad_monotonic pf) (_ : ad_monotonic pf'), ad_monotonic (fun a0 : ad => pf (pf' a0))
+++++
unfold ad_monotonic in |- *.
-----
Lemma ad_comp_monotonic : forall pf pf':ad -> ad, ad_monotonic pf -> ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).
Proof.
unfold ad_monotonic in |- *.

*****
A : Type
*****
forall (pf pf' : forall _ : ad, ad) (_ : forall (a a' : ad) (_ : eq (Nless a a') true), eq (Nless (pf a) (pf a')) true) (_ : forall (a a' : ad) (_ : eq (Nless a a') true), eq (Nless (pf' a) (pf' a')) true) (a a' : ad) (_ : eq (Nless a a') true), eq (Nless (pf (pf' a)) (pf (pf' a'))) true
+++++
intros.
-----
Lemma ad_comp_monotonic : forall pf pf':ad -> ad, ad_monotonic pf -> ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).
Proof.
unfold ad_monotonic in |- *.
intros.

*****
H1 : eq (Nless a a') true
a,a' : ad
H0 : forall (a a' : ad) (_ : eq (Nless a a') true),\neq (Nless (pf' a) (pf' a')) true
H : forall (a a' : ad) (_ : eq (Nless a a') true),\neq (Nless (pf a) (pf a')) true
pf,pf' : forall _ : ad, ad
A : Type
*****
eq (Nless (pf (pf' a)) (pf (pf' a'))) true
+++++
apply H.
-----
Lemma ad_comp_monotonic : forall pf pf':ad -> ad, ad_monotonic pf -> ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).
Proof.
unfold ad_monotonic in |- *.
intros.
apply H.

*****
H1 : eq (Nless a a') true
a,a' : ad
H0 : forall (a a' : ad) (_ : eq (Nless a a') true),\neq (Nless (pf' a) (pf' a')) true
H : forall (a a' : ad) (_ : eq (Nless a a') true),\neq (Nless (pf a) (pf a')) true
pf,pf' : forall _ : ad, ad
A : Type
*****
eq (Nless (pf' a) (pf' a')) true
+++++
apply H0.
-----
Lemma ad_comp_monotonic : forall pf pf':ad -> ad, ad_monotonic pf -> ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).
Proof.
unfold ad_monotonic in |- *.
intros.
apply H.
apply H0.

*****
H1 : eq (Nless a a') true
a,a' : ad
H0 : forall (a a' : ad) (_ : eq (Nless a a') true),\neq (Nless (pf' a) (pf' a')) true
H : forall (a a' : ad) (_ : eq (Nless a a') true),\neq (Nless (pf a) (pf a')) true
pf,pf' : forall _ : ad, ad
A : Type
*****
eq (Nless a a') true
+++++
exact H1.
-----
Lemma ad_comp_monotonic : forall pf pf':ad -> ad, ad_monotonic pf -> ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).
Proof.
unfold ad_monotonic in |- *.
intros.
apply H.
apply H0.
exact H1.

*****

*****

+++++
Qed.
-----
Lemma ad_comp_double_monotonic :\n   forall pf:ad -> ad,\n     ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble a0)).
-----
Lemma ad_comp_double_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble a0)).

*****
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf), ad_monotonic (fun a0 : ad => pf (N.double a0))
+++++
Proof.
-----
Lemma ad_comp_double_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble a0)).
Proof.

*****
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf), ad_monotonic (fun a0 : ad => pf (N.double a0))
+++++
intros.
-----
Lemma ad_comp_double_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble a0)).
Proof.
intros.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
A : Type
*****
ad_monotonic (fun a0 : ad => pf (N.double a0))
+++++
apply ad_comp_monotonic.
-----
Lemma ad_comp_double_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble a0)).
Proof.
intros.
apply ad_comp_monotonic.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
A : Type
*****
ad_monotonic pf
+++++
assumption.
-----
Lemma ad_comp_double_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble a0)).
Proof.
intros.
apply ad_comp_monotonic.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
A : Type
*****
ad_monotonic N.double
+++++
exact Ndouble_monotonic.
-----
Lemma ad_comp_double_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble a0)).
Proof.
intros.
apply ad_comp_monotonic.

*****

*****

+++++
Qed.
-----
Lemma ad_comp_double_plus_un_monotonic :\n   forall pf:ad -> ad,\n     ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble_plus_one a0)).
-----
Lemma ad_comp_double_plus_un_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble_plus_one a0)).

*****
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf), ad_monotonic (fun a0 : ad => pf (N.succ_double a0))
+++++
Proof.
-----
Lemma ad_comp_double_plus_un_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.

*****
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf), ad_monotonic (fun a0 : ad => pf (N.succ_double a0))
+++++
intros.
-----
Lemma ad_comp_double_plus_un_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.
intros.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
A : Type
*****
ad_monotonic (fun a0 : ad => pf (N.succ_double a0))
+++++
apply ad_comp_monotonic.
-----
Lemma ad_comp_double_plus_un_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.
intros.
apply ad_comp_monotonic.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
A : Type
*****
ad_monotonic pf
+++++
assumption.
-----
Lemma ad_comp_double_plus_un_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.
intros.
apply ad_comp_monotonic.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
A : Type
*****
ad_monotonic N.succ_double
+++++
exact Ndouble_plus_one_monotonic.
-----
Lemma ad_comp_double_plus_un_monotonic : forall pf:ad -> ad, ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble_plus_one a0)).
Proof.
intros.
apply ad_comp_monotonic.

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_sorts_1 :\n   forall (m:Map A) (pf:ad -> ad),\n     ad_monotonic pf ->\n     alist_sorted_2\n       (MapFold1 A (alist A) (anil A) (aapp A)\n          (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).

*****
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (_ : ad_monotonic pf), alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m)
+++++
Proof.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.

*****
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad) (_ : ad_monotonic pf), alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m)
+++++
simple induction m.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf), alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf (M0 A))
+++++
simpl in |- *.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf), alist_sorted_2 (anil A)
+++++
intros.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
simpl in |- *.
intros.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
m : Map A
A : Type
*****
alist_sorted_2 (anil A)
+++++
apply alist_sorted_1_imp_2.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
simpl in |- *.
intros.
apply alist_sorted_1_imp_2.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
m : Map A
A : Type
*****
alist_sorted_1 (anil A)
+++++
apply alist_sorted_imp_1.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
simpl in |- *.
intros.
apply alist_sorted_1_imp_2.
apply alist_sorted_imp_1.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
m : Map A
A : Type
*****
eq (alist_sorted (anil A)) true
+++++
reflexivity.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (_ : ad_monotonic pf), alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a1 : ad) (y : A) => acons A (pair a1 y) (anil A)) pf (M1 A a a0))
+++++
intros.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
A : Type
*****
alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf (M1 A a a0))
+++++
simpl in |- *.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
A : Type
*****
alist_sorted_2 (acons A (pair (pf a) a0) (anil A))
+++++
apply alist_sorted_1_imp_2.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_sorted_1_imp_2.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
A : Type
*****
alist_sorted_1 (acons A (pair (pf a) a0) (anil A))
+++++
apply alist_sorted_imp_1.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_sorted_1_imp_2.
apply alist_sorted_imp_1.

*****
H : ad_monotonic pf
pf : forall _ : ad, ad
a0 : A
a : ad
m : Map A
A : Type
*****
eq (alist_sorted (acons A (pair (pf a) a0) (anil A))) true
+++++
reflexivity.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf), alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m)) (m0 : Map A) (_ : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf), alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)) (pf : forall _ : ad, ad) (_ : ad_monotonic pf), alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf (M2 A m m0))
+++++
intros.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.

*****
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
alist_sorted_2 (aapp A (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
apply alist_conc_sorted.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.

*****
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.double a0)) m0)
+++++
exact (H (fun a0:ad => pf (Ndouble a0)) (ad_comp_double_monotonic pf H1)).
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.

*****
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1)
+++++
exact (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) (ad_comp_double_plus_un_monotonic pf H1)).
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.

*****
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
forall (n n' : nat) (_ : le (S n) (length (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.double a0)) m0))) (_ : le (S n') (length (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))), eq (Nless (alist_nth_ad n (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.double a0)) m0)) (alist_nth_ad n' (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))) true
+++++
intros.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.

*****
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
eq (Nless (alist_nth_ad n (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.double a0)) m0)) (alist_nth_ad n' (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))) true
+++++
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).

*****
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
forall (x : ad) (_ : eq (alist_nth_ad n (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) (fun a0 : ad => pf (N.double a0)) m0)) (pf (N.double x))), eq (Nless (alist_nth_ad n (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.double a0)) m0)) (alist_nth_ad n' (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))) true
+++++
intros a H4.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).
intros a H4.

*****
H4 : eq\n (alist_nth_ad n\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0)) (pf (N.double a))
a : ad
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
eq (Nless (alist_nth_ad n (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.double a0)) m0)) (alist_nth_ad n' (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))) true
+++++
rewrite H4.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).
intros a H4.
rewrite H4.

*****
H4 : eq\n (alist_nth_ad n\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0)) (pf (N.double a))
a : ad
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
eq (Nless (pf (N.double a)) (alist_nth_ad n' (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))) true
+++++
elim (alist_of_Map_nth_ad m1 (fun a0:ad => pf (Ndouble_plus_one a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) ( refl_equal _) n' H3).
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).
intros a H4.
rewrite H4.
elim (alist_of_Map_nth_ad m1 (fun a0:ad => pf (Ndouble_plus_one a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) ( refl_equal _) n' H3).

*****
H4 : eq\n (alist_nth_ad n\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0)) (pf (N.double a))
a : ad
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
forall (x : ad) (_ : eq (alist_nth_ad n' (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1)) (pf (N.succ_double x))), eq (Nless (pf (N.double a)) (alist_nth_ad n' (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))) true
+++++
intros a' H5.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).
intros a H4.
rewrite H4.
elim (alist_of_Map_nth_ad m1 (fun a0:ad => pf (Ndouble_plus_one a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) ( refl_equal _) n' H3).
intros a' H5.

*****
H5 : eq\n (alist_nth_ad n'\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))\n (pf (N.succ_double a'))
a' : ad
H4 : eq\n (alist_nth_ad n\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0)) (pf (N.double a))
a : ad
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
eq (Nless (pf (N.double a)) (alist_nth_ad n' (MapFold1 A (alist A) (anil A) (aapp A) (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) (fun a0 : ad => pf (N.succ_double a0)) m1))) true
+++++
rewrite H5.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).
intros a H4.
rewrite H4.
elim (alist_of_Map_nth_ad m1 (fun a0:ad => pf (Ndouble_plus_one a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) ( refl_equal _) n' H3).
intros a' H5.
rewrite H5.

*****
H5 : eq\n (alist_nth_ad n'\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))\n (pf (N.succ_double a'))
a' : ad
H4 : eq\n (alist_nth_ad n\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0)) (pf (N.double a))
a : ad
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : ad_monotonic pf
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
eq (Nless (pf (N.double a)) (pf (N.succ_double a'))) true
+++++
unfold ad_monotonic in H1.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).
intros a H4.
rewrite H4.
elim (alist_of_Map_nth_ad m1 (fun a0:ad => pf (Ndouble_plus_one a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) ( refl_equal _) n' H3).
intros a' H5.
rewrite H5.
unfold ad_monotonic in H1.

*****
H5 : eq\n (alist_nth_ad n'\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))\n (pf (N.succ_double a'))
a' : ad
H4 : eq\n (alist_nth_ad n\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0)) (pf (N.double a))
a : ad
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : forall (a a' : ad) (_ : eq (Nless a a') true),\neq (Nless (pf a) (pf a')) true
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
eq (Nless (pf (N.double a)) (pf (N.succ_double a'))) true
+++++
apply H1.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
apply alist_conc_sorted.
intros.
elim (alist_of_Map_nth_ad m0 (fun a0:ad => pf (Ndouble a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble a0)) m0) (refl_equal _) n H2).
intros a H4.
rewrite H4.
elim (alist_of_Map_nth_ad m1 (fun a0:ad => pf (Ndouble_plus_one a0)) (MapFold1 A (alist A) (anil A) (aapp A) (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) (fun a0:ad => pf (Ndouble_plus_one a0)) m1) ( refl_equal _) n' H3).
intros a' H5.
rewrite H5.
unfold ad_monotonic in H1.
apply H1.

*****
H5 : eq\n (alist_nth_ad n'\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))\n (pf (N.succ_double a'))
a' : ad
H4 : eq\n (alist_nth_ad n\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a0 : ad) (y : A) => acons A (pair a0 y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0)) (pf (N.double a))
a : ad
H3 : le (S n')\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.succ_double a0)) m1))
H2 : le (S n)\n (length\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A))\n (fun a0 : ad => pf (N.double a0)) m0))
n,n' : nat
H1 : forall (a a' : ad) (_ : eq (Nless a a') true),\neq (Nless (pf a) (pf a')) true
pf : forall _ : ad, ad
H0 : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m1)
m1 : Map A
H : forall (pf : forall _ : ad, ad) (_ : ad_monotonic pf),\nalist_sorted_2\n (MapFold1 A (alist A) (anil A) (aapp A)\n (fun (a : ad) (y : A) => acons A (pair a y) (anil A)) pf m0)
m,m0 : Map A
A : Type
*****
eq (Nless (N.double a) (N.succ_double a')) true
+++++
apply Nless_def_3.
-----
Lemma alist_of_Map_sorts_1 : forall (m:Map A) (pf:ad -> ad), ad_monotonic pf -> alist_sorted_2 (MapFold1 A (alist A) (anil A) (aapp A) (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_sorts :\n   forall m:Map A, alist_sorted (alist_of_Map A m) = true.
-----
Lemma alist_of_Map_sorts : forall m:Map A, alist_sorted (alist_of_Map A m) = true.

*****
A : Type
*****
forall m : Map A, eq (alist_sorted (alist_of_Map A m)) true
+++++
Proof.
-----
Lemma alist_of_Map_sorts : forall m:Map A, alist_sorted (alist_of_Map A m) = true.
Proof.

*****
A : Type
*****
forall m : Map A, eq (alist_sorted (alist_of_Map A m)) true
+++++
intro.
-----
Lemma alist_of_Map_sorts : forall m:Map A, alist_sorted (alist_of_Map A m) = true.
Proof.
intro.

*****
m : Map A
A : Type
*****
eq (alist_sorted (alist_of_Map A m)) true
+++++
apply alist_sorted_2_imp.
-----
Lemma alist_of_Map_sorts : forall m:Map A, alist_sorted (alist_of_Map A m) = true.
Proof.
intro.
apply alist_sorted_2_imp.

*****
m : Map A
A : Type
*****
alist_sorted_2 (alist_of_Map A m)
+++++
exact (alist_of_Map_sorts_1 m (fun a0:ad => a0) (fun (a a':ad) (p:Nless a a' = true) => p)).
-----
Lemma alist_of_Map_sorts : forall m:Map A, alist_sorted (alist_of_Map A m) = true.
Proof.
intro.
apply alist_sorted_2_imp.
exact (alist_of_Map_sorts_1 m (fun a0:ad => a0) (fun (a a':ad) (p:Nless a a' = true) => p)).

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_sorts1 :\n   forall m:Map A, alist_sorted_1 (alist_of_Map A m).
-----
Lemma alist_of_Map_sorts1 : forall m:Map A, alist_sorted_1 (alist_of_Map A m).

*****
A : Type
*****
forall m : Map A, alist_sorted_1 (alist_of_Map A m)
+++++
Proof.
-----
Lemma alist_of_Map_sorts1 : forall m:Map A, alist_sorted_1 (alist_of_Map A m).
Proof.

*****
A : Type
*****
forall m : Map A, alist_sorted_1 (alist_of_Map A m)
+++++
intro.
-----
Lemma alist_of_Map_sorts1 : forall m:Map A, alist_sorted_1 (alist_of_Map A m).
Proof.
intro.

*****
m : Map A
A : Type
*****
alist_sorted_1 (alist_of_Map A m)
+++++
apply alist_sorted_imp_1.
-----
Lemma alist_of_Map_sorts1 : forall m:Map A, alist_sorted_1 (alist_of_Map A m).
Proof.
intro.
apply alist_sorted_imp_1.

*****
m : Map A
A : Type
*****
eq (alist_sorted (alist_of_Map A m)) true
+++++
apply alist_of_Map_sorts.
-----
Lemma alist_of_Map_sorts1 : forall m:Map A, alist_sorted_1 (alist_of_Map A m).
Proof.
intro.
apply alist_sorted_imp_1.
apply alist_of_Map_sorts.

*****

*****

+++++
Qed.
-----
Lemma alist_of_Map_sorts2 :\n   forall m:Map A, alist_sorted_2 (alist_of_Map A m).
-----
Lemma alist_of_Map_sorts2 : forall m:Map A, alist_sorted_2 (alist_of_Map A m).

*****
A : Type
*****
forall m : Map A, alist_sorted_2 (alist_of_Map A m)
+++++
Proof.
-----
Lemma alist_of_Map_sorts2 : forall m:Map A, alist_sorted_2 (alist_of_Map A m).
Proof.

*****
A : Type
*****
forall m : Map A, alist_sorted_2 (alist_of_Map A m)
+++++
intro.
-----
Lemma alist_of_Map_sorts2 : forall m:Map A, alist_sorted_2 (alist_of_Map A m).
Proof.
intro.

*****
m : Map A
A : Type
*****
alist_sorted_2 (alist_of_Map A m)
+++++
apply alist_sorted_1_imp_2.
-----
Lemma alist_of_Map_sorts2 : forall m:Map A, alist_sorted_2 (alist_of_Map A m).
Proof.
intro.
apply alist_sorted_1_imp_2.

*****
m : Map A
A : Type
*****
alist_sorted_1 (alist_of_Map A m)
+++++
apply alist_of_Map_sorts1.
-----
Lemma alist_of_Map_sorts2 : forall m:Map A, alist_sorted_2 (alist_of_Map A m).
Proof.
intro.
apply alist_sorted_1_imp_2.
apply alist_of_Map_sorts1.

*****

*****

+++++
Qed.
-----
Lemma alist_too_low :\n   forall (l:alist A) (a a':ad) (y:A),\n     Nless a a' = true ->\n     alist_sorted_2 ((a', y) :: l) ->\n     alist_semantics A ((a', y) :: l) a = None.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.

*****
A : Type
*****
forall (l : alist A) (a a' : ad) (y : A) (_ : eq (Nless a a') true) (_ : alist_sorted_2 (cons (pair a' y) l)), eq (alist_semantics A (cons (pair a' y) l) a) None
+++++
Proof.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.

*****
A : Type
*****
forall (l : alist A) (a a' : ad) (y : A) (_ : eq (Nless a a') true) (_ : alist_sorted_2 (cons (pair a' y) l)), eq (alist_semantics A (cons (pair a' y) l) a) None
+++++
simple induction l.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a a' : ad) (y : A) (_ : eq (Nless a a') true) (_ : alist_sorted_2 (cons (pair a' y) nil)), eq (alist_semantics A (cons (pair a' y) nil) a) None
+++++
intros.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.

*****
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq (Nless a a') true
y : A
a,a' : ad
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a' y) nil) a) None
+++++
simpl in |- *.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq (Nless a a') true
y : A
a,a' : ad
l : alist A
A : Type
*****
eq (if N.eqb a' a then Some y else None) None
+++++
elim (sumbool_of_bool (Neqb a' a)).
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a' a)).

*****
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq (Nless a a') true
y : A
a,a' : ad
l : alist A
A : Type
*****
forall _ : eq (N.eqb a' a) true, eq (if N.eqb a' a then Some y else None) None
+++++
intro H1.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a' a)).
intro H1.

*****
H1 : eq (N.eqb a' a) true
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq (Nless a a') true
y : A
a,a' : ad
l : alist A
A : Type
*****
eq (if N.eqb a' a then Some y else None) None
+++++
rewrite (Neqb_complete _ _ H1) in H.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a' a)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.

*****
H1 : eq (N.eqb a' a) true
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq (Nless a a) true
y : A
a,a' : ad
l : alist A
A : Type
*****
eq (if N.eqb a' a then Some y else None) None
+++++
rewrite (Nless_not_refl a) in H.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a' a)).
intro H1.
rewrite (Neqb_complete _ _ H1) in H.
rewrite (Nless_not_refl a) in H.

*****
H1 : eq (N.eqb a' a) true
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq false true
y : A
a,a' : ad
l : alist A
A : Type
*****
eq (if N.eqb a' a then Some y else None) None
+++++
discriminate H.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a' a)).

*****
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq (Nless a a') true
y : A
a,a' : ad
l : alist A
A : Type
*****
forall _ : eq (N.eqb a' a) false, eq (if N.eqb a' a then Some y else None) None
+++++
intro H1.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a' a)).
intro H1.

*****
H1 : eq (N.eqb a' a) false
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq (Nless a a') true
y : A
a,a' : ad
l : alist A
A : Type
*****
eq (if N.eqb a' a then Some y else None) None
+++++
rewrite H1.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intros.
simpl in |- *.
elim (sumbool_of_bool (Neqb a' a)).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a' a) false
H0 : alist_sorted_2 (cons (pair a' y) nil)
H : eq (Nless a a') true
y : A
a,a' : ad
l : alist A
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (a0 a' : ad) (y : A) (_ : eq (Nless a0 a') true) (_ : alist_sorted_2 (cons (pair a' y) l)), eq (alist_semantics A (cons (pair a' y) l) a0) None) (a0 a' : ad) (y : A) (_ : eq (Nless a0 a') true) (_ : alist_sorted_2 (cons (pair a' y) (cons a l))), eq (alist_semantics A (cons (pair a' y) (cons a l)) a0) None
+++++
intro r.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true) (_ : alist_sorted_2 (cons (pair a' y) l)), eq (alist_semantics A (cons (pair a' y) l) a) None) (a a' : ad) (y : A) (_ : eq (Nless a a') true) (_ : alist_sorted_2 (cons (pair a' y) (cons r l))), eq (alist_semantics A (cons (pair a' y) (cons r l)) a) None
+++++
elim r.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall (a0 a' : ad) (y : A) (_ : eq (Nless a0 a') true) (_ : alist_sorted_2 (cons (pair a' y) l)), eq (alist_semantics A (cons (pair a' y) l) a0) None) (a0 a' : ad) (y : A) (_ : eq (Nless a0 a') true) (_ : alist_sorted_2 (cons (pair a' y) (cons (pair a b) l))), eq (alist_semantics A (cons (pair a' y) (cons (pair a b) l)) a0) None
+++++
intros a y l0 H a0 a1 y0 H0 H1.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.

*****
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a1 y0) (cons (pair a y) l0)) a0) None
+++++
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.

*****
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb a1 a0 then Some y0 else alist_semantics A (cons (pair a y) l0) a0) None
+++++
elim (sumbool_of_bool (Neqb a1 a0)).
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).

*****
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (N.eqb a1 a0) true, eq (if N.eqb a1 a0 then Some y0 else alist_semantics A (cons (pair a y) l0) a0) None
+++++
intro H2.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.

*****
H2 : eq (N.eqb a1 a0) true
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb a1 a0 then Some y0 else alist_semantics A (cons (pair a y) l0) a0) None
+++++
rewrite (Neqb_complete _ _ H2) in H0.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.

*****
H2 : eq (N.eqb a1 a0) true
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a0) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb a1 a0 then Some y0 else alist_semantics A (cons (pair a y) l0) a0) None
+++++
rewrite (Nless_not_refl a0) in H0.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H0.
rewrite (Nless_not_refl a0) in H0.

*****
H2 : eq (N.eqb a1 a0) true
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq false true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb a1 a0 then Some y0 else alist_semantics A (cons (pair a y) l0) a0) None
+++++
discriminate H0.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).

*****
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (N.eqb a1 a0) false, eq (if N.eqb a1 a0 then Some y0 else alist_semantics A (cons (pair a y) l0) a0) None
+++++
intro H2.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb a1 a0 then Some y0 else alist_semantics A (cons (pair a y) l0) a0) None
+++++
rewrite H2.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a y) l0) a0) None
+++++
apply H.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless a0 a) true
+++++
apply Nless_trans with (a' := a1).
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply Nless_trans with (a' := a1).

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless a0 a1) true
+++++
assumption.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply Nless_trans with (a' := a1).

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless a1 a) true
+++++
unfold alist_sorted_2 in H1.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply Nless_trans with (a' := a1).
unfold alist_sorted_2 in H1.

*****
H2 : eq (N.eqb a1 a0) false
H1 : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a1 y0) (cons (pair a y) l0)))),\neq\n (Nless (alist_nth_ad m (cons (pair a1 y0) (cons (pair a y) l0)))\n (alist_nth_ad n (cons (pair a1 y0) (cons (pair a y) l0)))) true
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (Nless a1 a) true
+++++
apply (H1 0 1).
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply Nless_trans with (a' := a1).
unfold alist_sorted_2 in H1.
apply (H1 0 1).

*****
H2 : eq (N.eqb a1 a0) false
H1 : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a1 y0) (cons (pair a y) l0)))),\neq\n (Nless (alist_nth_ad m (cons (pair a1 y0) (cons (pair a y) l0)))\n (alist_nth_ad n (cons (pair a1 y0) (cons (pair a y) l0)))) true
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
lt O (S O)
+++++
apply lt_n_Sn.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply Nless_trans with (a' := a1).
unfold alist_sorted_2 in H1.
apply (H1 0 1).

*****
H2 : eq (N.eqb a1 a0) false
H1 : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a1 y0) (cons (pair a y) l0)))),\neq\n (Nless (alist_nth_ad m (cons (pair a1 y0) (cons (pair a y) l0)))\n (alist_nth_ad n (cons (pair a1 y0) (cons (pair a y) l0)))) true
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S O)) (length (cons (pair a1 y0) (cons (pair a y) l0)))
+++++
simpl in |- *.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply Nless_trans with (a' := a1).
unfold alist_sorted_2 in H1.
apply (H1 0 1).
simpl in |- *.

*****
H2 : eq (N.eqb a1 a0) false
H1 : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a1 y0) (cons (pair a y) l0)))),\neq\n (Nless (alist_nth_ad m (cons (pair a1 y0) (cons (pair a y) l0)))\n (alist_nth_ad n (cons (pair a1 y0) (cons (pair a y) l0)))) true
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S O)) (S (S (length l0)))
+++++
apply le_n_S.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply Nless_trans with (a' := a1).
unfold alist_sorted_2 in H1.
apply (H1 0 1).
simpl in |- *.
apply le_n_S.

*****
H2 : eq (N.eqb a1 a0) false
H1 : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a1 y0) (cons (pair a y) l0)))),\neq\n (Nless (alist_nth_ad m (cons (pair a1 y0) (cons (pair a y) l0)))\n (alist_nth_ad n (cons (pair a1 y0) (cons (pair a y) l0)))) true
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S O) (S (length l0))
+++++
apply le_n_S.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply Nless_trans with (a' := a1).
unfold alist_sorted_2 in H1.
apply (H1 0 1).
simpl in |- *.
apply le_n_S.
apply le_n_S.

*****
H2 : eq (N.eqb a1 a0) false
H1 : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a1 y0) (cons (pair a y) l0)))),\neq\n (Nless (alist_nth_ad m (cons (pair a1 y0) (cons (pair a y) l0)))\n (alist_nth_ad n (cons (pair a1 y0) (cons (pair a y) l0)))) true
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le O (length l0)
+++++
apply le_O_n.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
alist_sorted_2 (cons (pair a y) l0)
+++++
apply alist_sorted_1_imp_2.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply alist_sorted_1_imp_2.

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
alist_sorted_1 (cons (pair a y) l0)
+++++
apply alist_sorted_imp_1.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply alist_sorted_1_imp_2.
apply alist_sorted_imp_1.

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_sorted (cons (pair a y) l0)) true
+++++
cut (alist_sorted ((a1, y0) :: (a, y) :: l0) = true).
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply alist_sorted_1_imp_2.
apply alist_sorted_imp_1.
cut (alist_sorted ((a1, y0) :: (a, y) :: l0) = true).

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (alist_sorted (cons (pair a1 y0) (cons (pair a y) l0))) true, eq (alist_sorted (cons (pair a y) l0)) true
+++++
intro H3.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply alist_sorted_1_imp_2.
apply alist_sorted_imp_1.
cut (alist_sorted ((a1, y0) :: (a, y) :: l0) = true).
intro H3.

*****
H3 : eq (alist_sorted (cons (pair a1 y0) (cons (pair a y) l0))) true
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_sorted (cons (pair a y) l0)) true
+++++
exact (proj2 (andb_prop _ _ H3)).
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply alist_sorted_1_imp_2.
apply alist_sorted_imp_1.
cut (alist_sorted ((a1, y0) :: (a, y) :: l0) = true).

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_sorted (cons (pair a1 y0) (cons (pair a y) l0))) true
+++++
apply alist_sorted_2_imp.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 a1 y0 H0 H1.
change (match Neqb a1 a0 with | true => Some y0 | false => alist_semantics A ((a, y) :: l0) a0 end = None) in |- *.
elim (sumbool_of_bool (Neqb a1 a0)).
intro H2.
rewrite H2.
apply H.
apply alist_sorted_1_imp_2.
apply alist_sorted_imp_1.
cut (alist_sorted ((a1, y0) :: (a, y) :: l0) = true).
apply alist_sorted_2_imp.

*****
H2 : eq (N.eqb a1 a0) false
H1 : alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
H0 : eq (Nless a0 a1) true
y0 : A
a0,a1 : ad
H : forall (a a' : ad) (y : A) (_ : eq (Nless a a') true)\n (_ : alist_sorted_2 (cons (pair a' y) l0)),\neq (alist_semantics A (cons (pair a' y) l0) a) None
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
alist_sorted_2 (cons (pair a1 y0) (cons (pair a y) l0))
+++++
assumption.
-----
Lemma alist_too_low : forall (l:alist A) (a a':ad) (y:A), Nless a a' = true -> alist_sorted_2 ((a', y) :: l) -> alist_semantics A ((a', y) :: l) a = None.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma alist_semantics_nth_ad :\n   forall (l:alist A) (a:ad) (y:A),\n     alist_semantics A l a = Some y ->\n     {n : nat | S n <= length l /\ alist_nth_ad n l = a}.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.

*****
A : Type
*****
forall (l : alist A) (a : ad) (y : A) (_ : eq (alist_semantics A l a) (Some y)), sig (fun n : nat => and (le (S n) (length l)) (eq (alist_nth_ad n l) a))
+++++
Proof.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.

*****
A : Type
*****
forall (l : alist A) (a : ad) (y : A) (_ : eq (alist_semantics A l a) (Some y)), sig (fun n : nat => and (le (S n) (length l)) (eq (alist_nth_ad n l) a))
+++++
simple induction l.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : ad) (y : A) (_ : eq (alist_semantics A nil a) (Some y)), sig (fun n : nat => and (le (S n) (length nil)) (eq (alist_nth_ad n nil) a))
+++++
intros.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intros.

*****
H : eq (alist_semantics A nil a) (Some y)
y : A
a : ad
l : alist A
A : Type
*****
sig (fun n : nat => and (le (S n) (length nil)) (eq (alist_nth_ad n nil) a))
+++++
discriminate H.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (a0 : ad) (y : A) (_ : eq (alist_semantics A l a0) (Some y)), sig (fun n : nat => and (le (S n) (length l)) (eq (alist_nth_ad n l) a0))) (a0 : ad) (y : A) (_ : eq (alist_semantics A (cons a l) a0) (Some y)), sig (fun n : nat => and (le (S n) (length (cons a l))) (eq (alist_nth_ad n (cons a l)) a0))
+++++
intro r.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (a : ad) (y : A) (_ : eq (alist_semantics A l a) (Some y)), sig (fun n : nat => and (le (S n) (length l)) (eq (alist_nth_ad n l) a))) (a : ad) (y : A) (_ : eq (alist_semantics A (cons r l) a) (Some y)), sig (fun n : nat => and (le (S n) (length (cons r l))) (eq (alist_nth_ad n (cons r l)) a))
+++++
elim r.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall (a0 : ad) (y : A) (_ : eq (alist_semantics A l a0) (Some y)), sig (fun n : nat => and (le (S n) (length l)) (eq (alist_nth_ad n l) a0))) (a0 : ad) (y : A) (_ : eq (alist_semantics A (cons (pair a b) l) a0) (Some y)), sig (fun n : nat => and (le (S n) (length (cons (pair a b) l))) (eq (alist_nth_ad n (cons (pair a b) l)) a0))
+++++
intros a y l0 H a0 y0 H0.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.

*****
H0 : eq (alist_semantics A (cons (pair a y) l0) a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
simpl in H0.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.

*****
H0 : eq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).

*****
H0 : eq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (N.eqb a a0) true, sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
intro H1.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
rewrite H1 in H0.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (Some y) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
split with 0.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
split with 0.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (Some y) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
and (le (S O) (length (cons (pair a y) l0))) (eq (alist_nth_ad O (cons (pair a y) l0)) a0)
+++++
split.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
split with 0.
split.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (Some y) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S O) (length (cons (pair a y) l0))
+++++
simpl in |- *.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
split with 0.
split.
simpl in |- *.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (Some y) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S O) (S (length l0))
+++++
apply le_n_S.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
split with 0.
split.
simpl in |- *.
apply le_n_S.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (Some y) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le O (length l0)
+++++
apply le_O_n.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
split with 0.
split.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (Some y) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_nth_ad O (cons (pair a y) l0)) a0
+++++
simpl in |- *.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
split with 0.
split.
simpl in |- *.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (Some y) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq a a0
+++++
exact (Neqb_complete _ _ H1).
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).

*****
H0 : eq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (N.eqb a a0) false, sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
intro H1.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
rewrite H1 in H0.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.

*****
H1 : eq (N.eqb a a0) false
H0 : eq (alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
elim (H a0 y0 H0).
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
elim (H a0 y0 H0).

*****
H1 : eq (N.eqb a a0) false
H0 : eq (alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (x : nat) (_ : and (le (S x) (length l0)) (eq (alist_nth_ad x l0) a0)), sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
intros n' H2.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
elim (H a0 y0 H0).
intros n' H2.

*****
H2 : and (le (S n') (length l0)) (eq (alist_nth_ad n' l0) a0)
n' : nat
H1 : eq (N.eqb a a0) false
H0 : eq (alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
sig (fun n : nat => and (le (S n) (length (cons (pair a y) l0))) (eq (alist_nth_ad n (cons (pair a y) l0)) a0))
+++++
split with (S n').
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
elim (H a0 y0 H0).
intros n' H2.
split with (S n').

*****
H2 : and (le (S n') (length l0)) (eq (alist_nth_ad n' l0) a0)
n' : nat
H1 : eq (N.eqb a a0) false
H0 : eq (alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
and (le (S (S n')) (length (cons (pair a y) l0))) (eq (alist_nth_ad (S n') (cons (pair a y) l0)) a0)
+++++
split.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
elim (H a0 y0 H0).
intros n' H2.
split with (S n').
split.

*****
H2 : and (le (S n') (length l0)) (eq (alist_nth_ad n' l0) a0)
n' : nat
H1 : eq (N.eqb a a0) false
H0 : eq (alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S n')) (length (cons (pair a y) l0))
+++++
simpl in |- *.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
elim (H a0 y0 H0).
intros n' H2.
split with (S n').
split.
simpl in |- *.

*****
H2 : and (le (S n') (length l0)) (eq (alist_nth_ad n' l0) a0)
n' : nat
H1 : eq (N.eqb a a0) false
H0 : eq (alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S (S n')) (S (length l0))
+++++
apply le_n_S.
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
elim (H a0 y0 H0).
intros n' H2.
split with (S n').
split.
simpl in |- *.
apply le_n_S.

*****
H2 : and (le (S n') (length l0)) (eq (alist_nth_ad n' l0) a0)
n' : nat
H1 : eq (N.eqb a a0) false
H0 : eq (alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
le (S n') (length l0)
+++++
exact (proj1 H2).
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.
intro r.
elim r.
intros a y l0 H a0 y0 H0.
simpl in H0.
elim (sumbool_of_bool (Neqb a a0)).
intro H1.
rewrite H1 in H0.
elim (H a0 y0 H0).
intros n' H2.
split with (S n').
split.

*****
H2 : and (le (S n') (length l0)) (eq (alist_nth_ad n' l0) a0)
n' : nat
H1 : eq (N.eqb a a0) false
H0 : eq (alist_semantics A l0 a0) (Some y0)
y0 : A
a0 : ad
H : forall (a : ad) (y : A) (_ : eq (alist_semantics A l0 a) (Some y)),\nsig\n (fun n : nat => and (le (S n) (length l0)) (eq (alist_nth_ad n l0) a))
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_nth_ad (S n') (cons (pair a y) l0)) a0
+++++
exact (proj2 H2).
-----
Lemma alist_semantics_nth_ad : forall (l:alist A) (a:ad) (y:A), alist_semantics A l a = Some y -> {n : nat | S n <= length l /\\ alist_nth_ad n l = a}.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma alist_semantics_tail :\n   forall (l:alist A) (a:ad) (y:A),\n     alist_sorted_2 ((a, y) :: l) ->\n     eqm A (alist_semantics A l)\n       (fun a0:ad =>\n          if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).

*****
A : Type
*****
forall (l : alist A) (a : ad) (y : A) (_ : alist_sorted_2 (cons (pair a y) l)), eqm A (alist_semantics A l) (fun a0 : ad => if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0)
+++++
Proof.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.

*****
A : Type
*****
forall (l : alist A) (a : ad) (y : A) (_ : alist_sorted_2 (cons (pair a y) l)), eqm A (alist_semantics A l) (fun a0 : ad => if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0)
+++++
unfold eqm in |- *.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (l : alist A) (a : ad) (y : A) (_ : alist_sorted_2 (cons (pair a y) l)) (a0 : ad), eq (alist_semantics A l a0) (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0)
+++++
intros.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.

*****
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a0) (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0)
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq (alist_semantics A l a0) (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0)
+++++
intro H0.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a0) (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0)
+++++
rewrite H0.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a0) None
+++++
rewrite <- (Neqb_complete _ _ H0).
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
unfold alist_sorted_2 in H.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
elim (option_sum A (alist_semantics A l a)).
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
forall _ : sig (fun y : A => eq (alist_semantics A l a) (Some y)), eq (alist_semantics A l a) None
+++++
intro H1.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.

*****
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
elim H1.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.

*****
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
forall (x : A) (_ : eq (alist_semantics A l a) (Some x)), eq (alist_semantics A l a) None
+++++
intros y0 H2.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.

*****
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
elim (alist_semantics_nth_ad l a y0 H2).
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).

*****
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
forall (x : nat) (_ : and (le (S x) (length l)) (eq (alist_nth_ad x l) a)), eq (alist_semantics A l a) None
+++++
intros n H3.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.

*****
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
elim H3.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.

*****
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
forall (_ : le (S n) (length l)) (_ : eq (alist_nth_ad n l) a), eq (alist_semantics A l a) None
+++++
intros.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.

*****
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).

*****
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
forall _ : eq (Nless (alist_nth_ad O (cons (pair a y) l)) (alist_nth_ad (S n) (cons (pair a y) l))) true, eq (alist_semantics A l a) None
+++++
intro.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
intro.

*****
H6 : eq\n (Nless (alist_nth_ad O (cons (pair a y) l))\n (alist_nth_ad (S n) (cons (pair a y) l))) true
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
simpl in H6.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
intro.
simpl in H6.

*****
H6 : eq (Nless a (alist_nth_ad n l)) true
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
rewrite H5 in H6.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
intro.
simpl in H6.
rewrite H5 in H6.

*****
H6 : eq (Nless a a) true
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
rewrite (Nless_not_refl a) in H6.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
intro.
simpl in H6.
rewrite H5 in H6.
rewrite (Nless_not_refl a) in H6.

*****
H6 : eq false true
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a) None
+++++
discriminate H6.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).

*****
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad O (cons (pair a y) l)) (alist_nth_ad (S n) (cons (pair a y) l))) true
+++++
apply H.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
apply H.

*****
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
lt O (S n)
+++++
apply lt_O_Sn.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
apply H.

*****
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
le (S (S n)) (length (cons (pair a y) l))
+++++
simpl in |- *.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
apply H.
simpl in |- *.

*****
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
le (S (S n)) (S (length l))
+++++
apply le_n_S.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).
intro H1.
elim H1.
intros y0 H2.
elim (alist_semantics_nth_ad l a y0 H2).
intros n H3.
elim H3.
intros.
cut (Nless (alist_nth_ad 0 ((a, y) :: l)) (alist_nth_ad (S n) ((a, y) :: l)) = true).
apply H.
simpl in |- *.
apply le_n_S.

*****
H5 : eq (alist_nth_ad n l) a
H4 : le (S n) (length l)
H3 : and (le (S n) (length l)) (eq (alist_nth_ad n l) a)
n : nat
H2 : eq (alist_semantics A l a) (Some y0)
y0 : A
H1 : sig (fun y : A => eq (alist_semantics A l a) (Some y))
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
le (S n) (length l)
+++++
assumption.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
rewrite H0.
rewrite <- (Neqb_complete _ _ H0).
unfold alist_sorted_2 in H.
elim (option_sum A (alist_semantics A l a)).

*****
H0 : eq (N.eqb a a0) true
a0 : ad
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
forall _ : eq (alist_semantics A l a) None, eq (alist_semantics A l a) None
+++++
trivial.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
forall _ : eq (N.eqb a a0) false, eq (alist_semantics A l a0) (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0)
+++++
intro H0.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a0) (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0)
+++++
simpl in |- *.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
simpl in |- *.

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a0) (if N.eqb a a0 then None else if N.eqb a a0 then Some y else alist_semantics A l a0)
+++++
rewrite H0.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H0.
simpl in |- *.
rewrite H0.

*****
H0 : eq (N.eqb a a0) false
a0 : ad
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l : alist A
A : Type
*****
eq (alist_semantics A l a0) (alist_semantics A l a0)
+++++
reflexivity.
-----
Lemma alist_semantics_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> eqm A (alist_semantics A l) (fun a0:ad => if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).
Proof.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****

*****

+++++
Qed.
-----
Lemma alist_semantics_same_tail :\n   forall (l l':alist A) (a:ad) (y:A),\n     alist_sorted_2 ((a, y) :: l) ->\n     alist_sorted_2 ((a, y) :: l') ->\n     eqm A (alist_semantics A ((a, y) :: l))\n       (alist_semantics A ((a, y) :: l')) ->\n     eqm A (alist_semantics A l) (alist_semantics A l').
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').

*****
A : Type
*****
forall (l l' : alist A) (a : ad) (y : A) (_ : alist_sorted_2 (cons (pair a y) l)) (_ : alist_sorted_2 (cons (pair a y) l')) (_ : eqm A (alist_semantics A (cons (pair a y) l)) (alist_semantics A (cons (pair a y) l'))), eqm A (alist_semantics A l) (alist_semantics A l')
+++++
Proof.
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').
Proof.

*****
A : Type
*****
forall (l l' : alist A) (a : ad) (y : A) (_ : alist_sorted_2 (cons (pair a y) l)) (_ : alist_sorted_2 (cons (pair a y) l')) (_ : eqm A (alist_semantics A (cons (pair a y) l)) (alist_semantics A (cons (pair a y) l'))), eqm A (alist_semantics A l) (alist_semantics A l')
+++++
unfold eqm in |- *.
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (l l' : alist A) (a : ad) (y : A) (_ : alist_sorted_2 (cons (pair a y) l)) (_ : alist_sorted_2 (cons (pair a y) l')) (_ : forall a0 : ad, eq (alist_semantics A (cons (pair a y) l) a0) (alist_semantics A (cons (pair a y) l') a0)) (a0 : ad), eq (alist_semantics A l a0) (alist_semantics A l' a0)
+++++
intros.
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').
Proof.
unfold eqm in |- *.
intros.

*****
a0 : ad
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l) a0)\n (alist_semantics A (cons (pair a y) l') a0)
H0 : alist_sorted_2 (cons (pair a y) l')
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l,l' : alist A
A : Type
*****
eq (alist_semantics A l a0) (alist_semantics A l' a0)
+++++
rewrite (alist_semantics_tail _ _ _ H a0).
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_tail _ _ _ H a0).

*****
a0 : ad
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l) a0)\n (alist_semantics A (cons (pair a y) l') a0)
H0 : alist_sorted_2 (cons (pair a y) l')
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l,l' : alist A
A : Type
*****
eq (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0) (alist_semantics A l' a0)
+++++
rewrite (alist_semantics_tail _ _ _ H0 a0).
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_tail _ _ _ H a0).
rewrite (alist_semantics_tail _ _ _ H0 a0).

*****
a0 : ad
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l) a0)\n (alist_semantics A (cons (pair a y) l') a0)
H0 : alist_sorted_2 (cons (pair a y) l')
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l,l' : alist A
A : Type
*****
eq (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l) a0) (if N.eqb a a0 then None else alist_semantics A (cons (pair a y) l') a0)
+++++
case (Neqb a a0).
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_tail _ _ _ H a0).
rewrite (alist_semantics_tail _ _ _ H0 a0).
case (Neqb a a0).

*****
a0 : ad
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l) a0)\n (alist_semantics A (cons (pair a y) l') a0)
H0 : alist_sorted_2 (cons (pair a y) l')
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l,l' : alist A
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_tail _ _ _ H a0).
rewrite (alist_semantics_tail _ _ _ H0 a0).
case (Neqb a a0).

*****
a0 : ad
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l) a0)\n (alist_semantics A (cons (pair a y) l') a0)
H0 : alist_sorted_2 (cons (pair a y) l')
H : alist_sorted_2 (cons (pair a y) l)
y : A
a : ad
l,l' : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a y) l) a0) (alist_semantics A (cons (pair a y) l') a0)
+++++
exact (H1 a0).
-----
Lemma alist_semantics_same_tail : forall (l l':alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 ((a, y) :: l') -> eqm A (alist_semantics A ((a, y) :: l)) (alist_semantics A ((a, y) :: l')) -> eqm A (alist_semantics A l) (alist_semantics A l').
Proof.
unfold eqm in |- *.
intros.
rewrite (alist_semantics_tail _ _ _ H a0).
rewrite (alist_semantics_tail _ _ _ H0 a0).
case (Neqb a a0).

*****

*****

+++++
Qed.
-----
Lemma alist_sorted_tail :\n   forall (l:alist A) (a:ad) (y:A),\n     alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.

*****
A : Type
*****
forall (l : alist A) (a : ad) (y : A) (_ : alist_sorted_2 (cons (pair a y) l)), alist_sorted_2 l
+++++
Proof.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.

*****
A : Type
*****
forall (l : alist A) (a : ad) (y : A) (_ : alist_sorted_2 (cons (pair a y) l)), alist_sorted_2 l
+++++
unfold alist_sorted_2 in |- *.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.
unfold alist_sorted_2 in |- *.

*****
A : Type
*****
forall (l : alist A) (a : ad) (y : A) (_ : forall (m n : nat) (_ : lt m n) (_ : le (S n) (length (cons (pair a y) l))), eq (Nless (alist_nth_ad m (cons (pair a y) l)) (alist_nth_ad n (cons (pair a y) l))) true) (m n : nat) (_ : lt m n) (_ : le (S n) (length l)), eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
+++++
intros.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.
unfold alist_sorted_2 in |- *.
intros.

*****
H1 : le (S n) (length l)
H0 : lt m n
m,n : nat
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
eq (Nless (alist_nth_ad m l) (alist_nth_ad n l)) true
+++++
apply (H (S m) (S n)).
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.
unfold alist_sorted_2 in |- *.
intros.
apply (H (S m) (S n)).

*****
H1 : le (S n) (length l)
H0 : lt m n
m,n : nat
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
lt (S m) (S n)
+++++
apply lt_n_S.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.
unfold alist_sorted_2 in |- *.
intros.
apply (H (S m) (S n)).
apply lt_n_S.

*****
H1 : le (S n) (length l)
H0 : lt m n
m,n : nat
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
lt m n
+++++
assumption.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.
unfold alist_sorted_2 in |- *.
intros.
apply (H (S m) (S n)).

*****
H1 : le (S n) (length l)
H0 : lt m n
m,n : nat
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
le (S (S n)) (length (cons (pair a y) l))
+++++
simpl in |- *.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.
unfold alist_sorted_2 in |- *.
intros.
apply (H (S m) (S n)).
simpl in |- *.

*****
H1 : le (S n) (length l)
H0 : lt m n
m,n : nat
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
le (S (S n)) (S (length l))
+++++
apply le_n_S.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.
unfold alist_sorted_2 in |- *.
intros.
apply (H (S m) (S n)).
simpl in |- *.
apply le_n_S.

*****
H1 : le (S n) (length l)
H0 : lt m n
m,n : nat
H : forall (m n : nat) (_ : lt m n)\n (_ : le (S n) (length (cons (pair a y) l))),\neq\n (Nless (alist_nth_ad m (cons (pair a y) l))\n (alist_nth_ad n (cons (pair a y) l))) true
y : A
a : ad
l : alist A
A : Type
*****
le (S n) (length l)
+++++
assumption.
-----
Lemma alist_sorted_tail : forall (l:alist A) (a:ad) (y:A), alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.
Proof.
unfold alist_sorted_2 in |- *.
intros.
apply (H (S m) (S n)).

*****

*****

+++++
Qed.
-----
Lemma alist_canonical :\n   forall l l':alist A,\n     eqm A (alist_semantics A l) (alist_semantics A l') ->\n     alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.

*****
A : Type
*****
forall (l l' : alist A) (_ : eqm A (alist_semantics A l) (alist_semantics A l')) (_ : alist_sorted_2 l) (_ : alist_sorted_2 l'), eq l l'
+++++
Proof.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.

*****
A : Type
*****
forall (l l' : alist A) (_ : eqm A (alist_semantics A l) (alist_semantics A l')) (_ : alist_sorted_2 l) (_ : alist_sorted_2 l'), eq l l'
+++++
unfold eqm in |- *.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.

*****
A : Type
*****
forall (l l' : alist A) (_ : forall a : ad, eq (alist_semantics A l a) (alist_semantics A l' a)) (_ : alist_sorted_2 l) (_ : alist_sorted_2 l'), eq l l'
+++++
simple induction l.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.

*****
l : alist A
A : Type
*****
forall (l' : alist A) (_ : forall a : ad, eq (alist_semantics A nil a) (alist_semantics A l' a)) (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l'), eq nil l'
+++++
simple induction l'.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.

*****
l,l' : alist A
A : Type
*****
forall (_ : forall a : ad, eq (alist_semantics A nil a) (alist_semantics A nil a)) (_ : alist_sorted_2 nil) (_ : alist_sorted_2 nil), eq nil nil
+++++
trivial.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.

*****
l,l' : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (_ : forall a0 : ad, eq (alist_semantics A nil a0) (alist_semantics A l a0)) (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l), eq nil l) (_ : forall a0 : ad, eq (alist_semantics A nil a0) (alist_semantics A (cons a l) a0)) (_ : alist_sorted_2 nil) (_ : alist_sorted_2 (cons a l)), eq nil (cons a l)
+++++
intro r.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.
intro r.

*****
r : prod ad A
l,l' : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (_ : forall a : ad, eq (alist_semantics A nil a) (alist_semantics A l a)) (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l), eq nil l) (_ : forall a : ad, eq (alist_semantics A nil a) (alist_semantics A (cons r l) a)) (_ : alist_sorted_2 nil) (_ : alist_sorted_2 (cons r l)), eq nil (cons r l)
+++++
elim r.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.
intro r.
elim r.

*****
r : prod ad A
l,l' : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall (_ : forall a0 : ad, eq (alist_semantics A nil a0) (alist_semantics A l a0)) (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l), eq nil l) (_ : forall a0 : ad, eq (alist_semantics A nil a0) (alist_semantics A (cons (pair a b) l) a0)) (_ : alist_sorted_2 nil) (_ : alist_sorted_2 (cons (pair a b) l)), eq nil (cons (pair a b) l)
+++++
intros a y l0 H H0 H1 H2.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.
intro r.
elim r.
intros a y l0 H H0 H1 H2.

*****
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : alist_sorted_2 nil
H0 : forall a0 : ad,\neq (alist_semantics A nil a0)\n (alist_semantics A (cons (pair a y) l0) a0)
H : forall\n (_ : forall a : ad,\n eq (alist_semantics A nil a) (alist_semantics A l0 a))\n (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l0), \neq nil l0
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l,l' : alist A
A : Type
*****
eq nil (cons (pair a y) l0)
+++++
simpl in H0.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.
intro r.
elim r.
intros a y l0 H H0 H1 H2.
simpl in H0.

*****
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : alist_sorted_2 nil
H0 : forall a0 : ad,\neq None (if N.eqb a a0 then Some y else alist_semantics A l0 a0)
H : forall\n (_ : forall a : ad,\n eq (alist_semantics A nil a) (alist_semantics A l0 a))\n (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l0), \neq nil l0
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l,l' : alist A
A : Type
*****
eq nil (cons (pair a y) l0)
+++++
cut (None = match Neqb a a with | true => Some y | false => alist_semantics A l0 a end).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.
intro r.
elim r.
intros a y l0 H H0 H1 H2.
simpl in H0.
cut (None = match Neqb a a with | true => Some y | false => alist_semantics A l0 a end).

*****
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : alist_sorted_2 nil
H0 : forall a0 : ad,\neq None (if N.eqb a a0 then Some y else alist_semantics A l0 a0)
H : forall\n (_ : forall a : ad,\n eq (alist_semantics A nil a) (alist_semantics A l0 a))\n (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l0), \neq nil l0
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l,l' : alist A
A : Type
*****
forall _ : eq None (if N.eqb a a then Some y else alist_semantics A l0 a), eq nil (cons (pair a y) l0)
+++++
rewrite (Neqb_correct a).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.
intro r.
elim r.
intros a y l0 H H0 H1 H2.
simpl in H0.
cut (None = match Neqb a a with | true => Some y | false => alist_semantics A l0 a end).
rewrite (Neqb_correct a).

*****
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : alist_sorted_2 nil
H0 : forall a0 : ad,\neq None (if N.eqb a a0 then Some y else alist_semantics A l0 a0)
H : forall\n (_ : forall a : ad,\n eq (alist_semantics A nil a) (alist_semantics A l0 a))\n (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l0), \neq nil l0
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l,l' : alist A
A : Type
*****
forall _ : eq None (Some y), eq nil (cons (pair a y) l0)
+++++
intro.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.
intro r.
elim r.
intros a y l0 H H0 H1 H2.
simpl in H0.
cut (None = match Neqb a a with | true => Some y | false => alist_semantics A l0 a end).
rewrite (Neqb_correct a).
intro.

*****
H3 : eq None (Some y)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : alist_sorted_2 nil
H0 : forall a0 : ad,\neq None (if N.eqb a a0 then Some y else alist_semantics A l0 a0)
H : forall\n (_ : forall a : ad,\n eq (alist_semantics A nil a) (alist_semantics A l0 a))\n (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l0), \neq nil l0
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l,l' : alist A
A : Type
*****
eq nil (cons (pair a y) l0)
+++++
discriminate H3.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
simple induction l'.
intro r.
elim r.
intros a y l0 H H0 H1 H2.
simpl in H0.
cut (None = match Neqb a a with | true => Some y | false => alist_semantics A l0 a end).

*****
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : alist_sorted_2 nil
H0 : forall a0 : ad,\neq None (if N.eqb a a0 then Some y else alist_semantics A l0 a0)
H : forall\n (_ : forall a : ad,\n eq (alist_semantics A nil a) (alist_semantics A l0 a))\n (_ : alist_sorted_2 nil) (_ : alist_sorted_2 l0), \neq nil l0
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l,l' : alist A
A : Type
*****
eq None (if N.eqb a a then Some y else alist_semantics A l0 a)
+++++
exact (H0 a).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.

*****
l : alist A
A : Type
*****
forall (a : prod ad A) (l : list (prod ad A)) (_ : forall (l' : alist A) (_ : forall a0 : ad, eq (alist_semantics A l a0) (alist_semantics A l' a0)) (_ : alist_sorted_2 l) (_ : alist_sorted_2 l'), eq l l') (l' : alist A) (_ : forall a0 : ad, eq (alist_semantics A (cons a l) a0) (alist_semantics A l' a0)) (_ : alist_sorted_2 (cons a l)) (_ : alist_sorted_2 l'), eq (cons a l) l'
+++++
intro r.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (l' : alist A) (_ : forall a : ad, eq (alist_semantics A l a) (alist_semantics A l' a)) (_ : alist_sorted_2 l) (_ : alist_sorted_2 l'), eq l l') (l' : alist A) (_ : forall a : ad, eq (alist_semantics A (cons r l) a) (alist_semantics A l' a)) (_ : alist_sorted_2 (cons r l)) (_ : alist_sorted_2 l'), eq (cons r l) l'
+++++
elim r.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.

*****
r : prod ad A
l : alist A
A : Type
*****
forall (a : ad) (b : A) (l : list (prod ad A)) (_ : forall (l' : alist A) (_ : forall a0 : ad, eq (alist_semantics A l a0) (alist_semantics A l' a0)) (_ : alist_sorted_2 l) (_ : alist_sorted_2 l'), eq l l') (l' : alist A) (_ : forall a0 : ad, eq (alist_semantics A (cons (pair a b) l) a0) (alist_semantics A l' a0)) (_ : alist_sorted_2 (cons (pair a b) l)) (_ : alist_sorted_2 l'), eq (cons (pair a b) l) l'
+++++
intros a y l0 H.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.

*****
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (l' : alist A) (_ : forall a0 : ad, eq (alist_semantics A (cons (pair a y) l0) a0) (alist_semantics A l' a0)) (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'), eq (cons (pair a y) l0) l'
+++++
simple induction l'.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.

*****
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (_ : forall a0 : ad, eq (alist_semantics A (cons (pair a y) l0) a0) (alist_semantics A nil a0)) (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 nil), eq (cons (pair a y) l0) nil
+++++
intros.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intros.

*****
H2 : alist_sorted_2 nil
H1 : alist_sorted_2 (cons (pair a y) l0)
H0 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A nil a0)
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) nil
+++++
simpl in H0.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intros.
simpl in H0.

*****
H2 : alist_sorted_2 nil
H1 : alist_sorted_2 (cons (pair a y) l0)
H0 : forall a0 : ad,\neq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) None
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) nil
+++++
cut (match Neqb a a with | true => Some y | false => alist_semantics A l0 a end = None).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intros.
simpl in H0.
cut (match Neqb a a with | true => Some y | false => alist_semantics A l0 a end = None).

*****
H2 : alist_sorted_2 nil
H1 : alist_sorted_2 (cons (pair a y) l0)
H0 : forall a0 : ad,\neq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) None
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (if N.eqb a a then Some y else alist_semantics A l0 a) None, eq (cons (pair a y) l0) nil
+++++
rewrite (Neqb_correct a).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intros.
simpl in H0.
cut (match Neqb a a with | true => Some y | false => alist_semantics A l0 a end = None).
rewrite (Neqb_correct a).

*****
H2 : alist_sorted_2 nil
H1 : alist_sorted_2 (cons (pair a y) l0)
H0 : forall a0 : ad,\neq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) None
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (Some y) None, eq (cons (pair a y) l0) nil
+++++
intro.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intros.
simpl in H0.
cut (match Neqb a a with | true => Some y | false => alist_semantics A l0 a end = None).
rewrite (Neqb_correct a).
intro.

*****
H3 : eq (Some y) None
H2 : alist_sorted_2 nil
H1 : alist_sorted_2 (cons (pair a y) l0)
H0 : forall a0 : ad,\neq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) None
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) nil
+++++
discriminate H3.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intros.
simpl in H0.
cut (match Neqb a a with | true => Some y | false => alist_semantics A l0 a end = None).

*****
H2 : alist_sorted_2 nil
H1 : alist_sorted_2 (cons (pair a y) l0)
H0 : forall a0 : ad,\neq (if N.eqb a a0 then Some y else alist_semantics A l0 a0) None
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (if N.eqb a a then Some y else alist_semantics A l0 a) None
+++++
exact (H0 a).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.

*****
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (a0 : prod ad A) (l : list (prod ad A)) (_ : forall (_ : forall a1 : ad, eq (alist_semantics A (cons (pair a y) l0) a1) (alist_semantics A l a1)) (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l), eq (cons (pair a y) l0) l) (_ : forall a1 : ad, eq (alist_semantics A (cons (pair a y) l0) a1) (alist_semantics A (cons a0 l) a1)) (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 (cons a0 l)), eq (cons (pair a y) l0) (cons a0 l)
+++++
intro r'.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.

*****
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (l : list (prod ad A)) (_ : forall (_ : forall a0 : ad, eq (alist_semantics A (cons (pair a y) l0) a0) (alist_semantics A l a0)) (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l), eq (cons (pair a y) l0) l) (_ : forall a0 : ad, eq (alist_semantics A (cons (pair a y) l0) a0) (alist_semantics A (cons r' l) a0)) (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 (cons r' l)), eq (cons (pair a y) l0) (cons r' l)
+++++
elim r'.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.

*****
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall (a0 : ad) (b : A) (l : list (prod ad A)) (_ : forall (_ : forall a1 : ad, eq (alist_semantics A (cons (pair a y) l0) a1) (alist_semantics A l a1)) (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l), eq (cons (pair a y) l0) l) (_ : forall a1 : ad, eq (alist_semantics A (cons (pair a y) l0) a1) (alist_semantics A (cons (pair a0 b) l) a1)) (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 (cons (pair a0 b) l)), eq (cons (pair a y) l0) (cons (pair a0 b) l)
+++++
intros a' y' l'0 H0 H1 H2 H3.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.

*****
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
elim (Nless_total a a').
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').

*****
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : sumbool (eq (Nless a a') true) (eq (Nless a' a) true), eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
intro H4.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.

*****
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
elim H4.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.

*****
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (Nless a a') true, eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
intro H5.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.

*****
H5 : eq (Nless a a') true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).

*****
H5 : eq (Nless a a') true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (alist_semantics A (cons (pair a y) l0) a) (alist_semantics A (cons (pair a' y') l'0) a), eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
intro.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.

*****
H6 : eq (alist_semantics A (cons (pair a y) l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H5 : eq (Nless a a') true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
rewrite (alist_too_low l'0 a a' y' H5 H3) in H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
rewrite (alist_too_low l'0 a a' y' H5 H3) in H6.

*****
H6 : eq (alist_semantics A (cons (pair a y) l0) a) None
H5 : eq (Nless a a') true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
simpl in H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
rewrite (alist_too_low l'0 a a' y' H5 H3) in H6.
simpl in H6.

*****
H6 : eq (if N.eqb a a then Some y else alist_semantics A l0 a) None
H5 : eq (Nless a a') true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
rewrite (Neqb_correct a) in H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
rewrite (alist_too_low l'0 a a' y' H5 H3) in H6.
simpl in H6.
rewrite (Neqb_correct a) in H6.

*****
H6 : eq (Some y) None
H5 : eq (Nless a a') true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
discriminate H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).

*****
H5 : eq (Nless a a') true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a y) l0) a) (alist_semantics A (cons (pair a' y') l'0) a)
+++++
exact (H1 a).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.

*****
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (Nless a' a) true, eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
intro H5.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.

*****
H5 : eq (Nless a' a) true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
cut (alist_semantics A ((a, y) :: l0) a' = alist_semantics A ((a', y') :: l'0) a').
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a' = alist_semantics A ((a', y') :: l'0) a').

*****
H5 : eq (Nless a' a) true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (alist_semantics A (cons (pair a y) l0) a') (alist_semantics A (cons (pair a' y') l'0) a'), eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
intro.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a' = alist_semantics A ((a', y') :: l'0) a').
intro.

*****
H6 : eq (alist_semantics A (cons (pair a y) l0) a')\n (alist_semantics A (cons (pair a' y') l'0) a')
H5 : eq (Nless a' a) true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
rewrite (alist_too_low l0 a' a y H5 H2) in H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a' = alist_semantics A ((a', y') :: l'0) a').
intro.
rewrite (alist_too_low l0 a' a y H5 H2) in H6.

*****
H6 : eq None (alist_semantics A (cons (pair a' y') l'0) a')
H5 : eq (Nless a' a) true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
simpl in H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a' = alist_semantics A ((a', y') :: l'0) a').
intro.
rewrite (alist_too_low l0 a' a y H5 H2) in H6.
simpl in H6.

*****
H6 : eq None (if N.eqb a' a' then Some y' else alist_semantics A l'0 a')
H5 : eq (Nless a' a) true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
rewrite (Neqb_correct a') in H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a' = alist_semantics A ((a', y') :: l'0) a').
intro.
rewrite (alist_too_low l0 a' a y H5 H2) in H6.
simpl in H6.
rewrite (Neqb_correct a') in H6.

*****
H6 : eq None (Some y')
H5 : eq (Nless a' a) true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
discriminate H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
elim H4.
intro H5.
cut (alist_semantics A ((a, y) :: l0) a' = alist_semantics A ((a', y') :: l'0) a').

*****
H5 : eq (Nless a' a) true
H4 : sumbool (eq (Nless a a') true) (eq (Nless a' a) true)
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a y) l0) a') (alist_semantics A (cons (pair a' y') l'0) a')
+++++
exact (H1 a').
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').

*****
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq a a', eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
intro H4.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.

*****
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a y) l0) (cons (pair a' y') l'0)
+++++
rewrite H4.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.

*****
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y) l0) (cons (pair a' y') l'0)
+++++
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).

*****
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq (alist_semantics A (cons (pair a y) l0) a) (alist_semantics A (cons (pair a' y') l'0) a), eq (cons (pair a' y) l0) (cons (pair a' y') l'0)
+++++
intro.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.

*****
H5 : eq (alist_semantics A (cons (pair a y) l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y) l0) (cons (pair a' y') l'0)
+++++
simpl in H5.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.

*****
H5 : eq (if N.eqb a a then Some y else alist_semantics A l0 a)\n (if N.eqb a' a then Some y' else alist_semantics A l'0 a)
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y) l0) (cons (pair a' y') l'0)
+++++
rewrite H4 in H5.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.

*****
H5 : eq (if N.eqb a' a' then Some y else alist_semantics A l0 a')\n (if N.eqb a' a' then Some y' else alist_semantics A l'0 a')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y) l0) (cons (pair a' y') l'0)
+++++
rewrite (Neqb_correct a') in H5.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.

*****
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y) l0) (cons (pair a' y') l'0)
+++++
inversion H5.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y') l0) (cons (pair a' y') l'0)
+++++
rewrite H4 in H1.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y) l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y') l0) (cons (pair a' y') l'0)
+++++
rewrite H7 in H1.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y') l0) (cons (pair a' y') l'0)
+++++
cut (l0 = l'0).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall _ : eq l0 l'0, eq (cons (pair a' y') l0) (cons (pair a' y') l'0)
+++++
intro.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).
intro.

*****
H6 : eq l0 l'0
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y') l0) (cons (pair a' y') l'0)
+++++
rewrite H6.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).
intro.
rewrite H6.

*****
H6 : eq l0 l'0
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (cons (pair a' y') l'0) (cons (pair a' y') l'0)
+++++
reflexivity.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq l0 l'0
+++++
apply H.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).
apply H.

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall a : ad, eq (alist_semantics A l0 a) (alist_semantics A l'0 a)
+++++
rewrite H4 in H2.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).
apply H.
rewrite H4 in H2.

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a' y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall a : ad, eq (alist_semantics A l0 a) (alist_semantics A l'0 a)
+++++
rewrite H7 in H2.
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).
apply H.
rewrite H4 in H2.
rewrite H7 in H2.

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a' y') l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
forall a : ad, eq (alist_semantics A l0 a) (alist_semantics A l'0 a)
+++++
exact (alist_semantics_same_tail l0 l'0 a' y' H2 H3 H1).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).
apply H.

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
alist_sorted_2 l0
+++++
exact (alist_sorted_tail _ _ _ H2).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).
intro.
simpl in H5.
rewrite H4 in H5.
rewrite (Neqb_correct a') in H5.
inversion H5.
rewrite H4 in H1.
rewrite H7 in H1.
cut (l0 = l'0).
apply H.

*****
H7 : eq y y'
H5 : eq (Some y) (Some y')
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a : ad,\neq (alist_semantics A (cons (pair a' y') l0) a)\n (alist_semantics A (cons (pair a' y') l'0) a)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
alist_sorted_2 l'0
+++++
exact (alist_sorted_tail _ _ _ H3).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.
intro r.
elim r.
intros a y l0 H.
simple induction l'.
intro r'.
elim r'.
intros a' y' l'0 H0 H1 H2 H3.
elim (Nless_total a a').
intro H4.
rewrite H4.
cut (alist_semantics A ((a, y) :: l0) a = alist_semantics A ((a', y') :: l'0) a).

*****
H4 : eq a a'
H3 : alist_sorted_2 (cons (pair a' y') l'0)
H2 : alist_sorted_2 (cons (pair a y) l0)
H1 : forall a0 : ad,\neq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A (cons (pair a' y') l'0) a0)
H0 : forall\n (_ : forall a0 : ad,\n eq (alist_semantics A (cons (pair a y) l0) a0)\n (alist_semantics A l'0 a0))\n (_ : alist_sorted_2 (cons (pair a y) l0)) (_ : alist_sorted_2 l'0),\neq (cons (pair a y) l0) l'0
l'0 : list (prod ad A)
y' : A
a' : ad
r' : prod ad A
l' : alist A
H : forall (l' : alist A)\n (_ : forall a : ad,\n eq (alist_semantics A l0 a) (alist_semantics A l' a))\n (_ : alist_sorted_2 l0) (_ : alist_sorted_2 l'), \neq l0 l'
l0 : list (prod ad A)
y : A
a : ad
r : prod ad A
l : alist A
A : Type
*****
eq (alist_semantics A (cons (pair a y) l0) a) (alist_semantics A (cons (pair a' y') l'0) a)
+++++
exact (H1 a).
-----
Lemma alist_canonical : forall l l':alist A, eqm A (alist_semantics A l) (alist_semantics A l') -> alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.
Proof.
unfold eqm in |- *.
simple induction l.

*****

*****

+++++
Qed.
-----
End LSort.
-----
