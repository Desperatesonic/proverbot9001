Require Export GeoCoq.Axioms.continuity_axioms.
-----
Require Export GeoCoq.Tarski_dev.Annexes.circles.
-----
Require Export GeoCoq.Tarski_dev.Annexes.sums.
-----
Require Import GeoCoq.Utils.all_equiv.
-----
Section Elementary_Continuity_Props.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff segment_circle one_point_line_circle
+++++
Proof.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff segment_circle one_point_line_circle
+++++
unfold segment_circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))) one_point_line_circle
+++++
unfold one_point_line_circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))) (forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B)))
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))) (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
intros Hsc A B U V P HCol HUV HBet.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.

*****
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (eq_dec_points A B).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).

*****
H : eq A B
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
unfold InCircle in *.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
unfold InCircle in *.

*****
H : eq A B
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : Le A P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
unfold OnCircle in *.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
unfold InCircle in *.
unfold OnCircle in *.

*****
H : eq A B
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : Le A P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (Cong A Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (Cong A Z A B))
+++++
treat_equalities.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
unfold InCircle in *.
unfold OnCircle in *.
treat_equalities.

*****
HUV : not (eq U V)
HCol : Col U V A
A,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : Le A P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (Cong A Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (Cong A Z A A))
+++++
exists A.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
unfold InCircle in *.
unfold OnCircle in *.
treat_equalities.
exists A.

*****
HUV : not (eq U V)
HCol : Col U V A
A,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : Le A P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (Cong A Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V A) (Cong A A A A)
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).

*****
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
assert (HPIn : InCircle P A B).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).

*****
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
apply bet__le1213.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
apply bet__le1213.

*****
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P B
+++++
assumption.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).

*****
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
idtac.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.

*****
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].

*****
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V P
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].

*****
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.

*****
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (eq_dec_points A P).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).

*****
H0 : eq A P
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
subst P.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.

*****
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].

*****
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].

*****
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle A A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].

*****
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].
trivial.

*****
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q A B
+++++
apply cong__le.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].
trivial.
apply cong__le.

*****
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A Q
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].

*****
HZ2 : OnCircle Z A B
HZ1 : Bet A Z Q
Z : Tpoint
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].
trivial.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet A Z Q
Z : Tpoint
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
exists Z.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].
trivial.
exists Z.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet A Z Q
Z : Tpoint
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V Z) (OnCircle Z A B)
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].
trivial.
exists Z.
split.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet A Z Q
Z : Tpoint
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].
trivial.
exists Z.
split.
trivial.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet A Z Q
Z : Tpoint
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
ColR.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
subst P.
destruct (segment_construction W A A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B A Q) as [Z [HZ1 HZ2]].
trivial.
exists Z.
split.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet A Z Q
Z : Tpoint
HQ2 : Cong A Q A B
HQ1 : Bet W A Q
Q : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle A A B
H : not (eq A B)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).

*****
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].

*****
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q A B
+++++
apply (l5_6 Q Q0 Q A).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le Q Q0 Q A
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).
Cong.

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le Q Q0 Q A
+++++
apply (triangle_reverse_inequality P).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).
Cong.
apply (triangle_reverse_inequality P).

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out P Q Q0
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).
Cong.
apply (triangle_reverse_inequality P).
Cong.

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out P Q Q0
+++++
assert_diffs.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).
Cong.
apply (triangle_reverse_inequality P).
Cong.
assert_diffs.

*****
H4 : not (eq P Q0)
H3 : not (eq P Q)
H2 : not (eq Q0 Q)
H1 : not (eq W Q0)
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out P Q Q0
+++++
apply l6_6, bet_out.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).
Cong.
apply (triangle_reverse_inequality P).
Cong.
assert_diffs.
apply l6_6, bet_out.

*****
H4 : not (eq P Q0)
H3 : not (eq P Q)
H2 : not (eq Q0 Q)
H1 : not (eq W Q0)
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q0 P)
+++++
auto.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).
Cong.
apply (triangle_reverse_inequality P).
Cong.
assert_diffs.
apply l6_6, bet_out.

*****
H4 : not (eq P Q0)
H3 : not (eq P Q)
H2 : not (eq Q0 Q)
H1 : not (eq W Q0)
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Q0 Q
+++++
auto.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).
Cong.
apply (triangle_reverse_inequality P).

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong P A P Q0
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong Q Q0 A B
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
apply (l5_6 Q Q0 Q A).

*****
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong Q A A Q
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].

*****
HZ2 : OnCircle Z A B
HZ1 : Bet P Z Q
Z : Tpoint
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet P Z Q
Z : Tpoint
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
exists Z.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
exists Z.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet P Z Q
Z : Tpoint
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V Z) (OnCircle Z A B)
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
exists Z.
split.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet P Z Q
Z : Tpoint
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
exists Z.
split.
trivial.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet P Z Q
Z : Tpoint
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
ColR.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hsc A B U V P HCol HUV HBet.
destruct (eq_dec_points A B).
assert (HPIn : InCircle P A B).
idtac.
destruct (diff_col_ex3 U V P) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (eq_dec_points A P).
destruct (segment_construction W P P A) as [Q0 [HQ01 HQ02]].
destruct (segment_construction P Q0 A B) as [Q [HQ1 HQ2]].
destruct (Hsc A B P Q) as [Z [HZ1 HZ2]].
trivial.
exists Z.
split.

*****
HZ2 : OnCircle Z A B
HZ1 : Bet P Z Q
Z : Tpoint
HQ2 : Cong Q0 Q A B
HQ1 : Bet P Q0 Q
Q : Tpoint
HQ02 : Cong P Q0 P A
HQ01 : Bet W P Q0
Q0 : Tpoint
H0 : not (eq A P)
HCol2 : Col U V W
HPW : not (eq P W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HPIn : InCircle P A B
H : not (eq A B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hsc : forall (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))) (A B P Q : Tpoint) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
intros Hoplc A B P Q HPIn HQOut.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.

*****
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
destruct (eq_dec_points A B).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).

*****
H : eq A B
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
unfold InCircle in HPIn.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
unfold InCircle in HPIn.

*****
H : eq A B
HQOut : OutCircle Q A B
HPIn : Le A P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
treat_equalities.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
unfold InCircle in HPIn.
treat_equalities.

*****
HQOut : OutCircle Q A A
A,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet A Z Q) (OnCircle Z A A))
+++++
exists A.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
unfold InCircle in HPIn.
treat_equalities.
exists A.

*****
HQOut : OutCircle Q A A
A,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A A Q) (OnCircle A A A)
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
unfold InCircle in HPIn.
treat_equalities.
exists A.
split.

*****
HQOut : OutCircle Q A A
A,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A A Q
+++++
Between.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
unfold InCircle in HPIn.
treat_equalities.
exists A.
split.

*****
HQOut : OutCircle Q A A
A,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle A A A
+++++
Between.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
unfold InCircle in HPIn.
treat_equalities.
exists A.
split.
Between.

*****
HQOut : OutCircle Q A A
A,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle A A A
+++++
Circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).

*****
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
destruct (eq_dec_points P Q).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).

*****
H0 : eq P Q
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
subst Q.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
subst Q.

*****
H : not (eq A B)
HQOut : OutCircle P A B
HPIn : InCircle P A B
A,B,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z P) (OnCircle Z A B))
+++++
exists P.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
subst Q.
exists P.

*****
H : not (eq A B)
HQOut : OutCircle P A B
HPIn : InCircle P A B
A,B,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet P P P) (OnCircle P A B)
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
subst Q.
exists P.
split.

*****
H : not (eq A B)
HQOut : OutCircle P A B
HPIn : InCircle P A B
A,B,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P P P
+++++
Between.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
subst Q.
exists P.
split.

*****
H : not (eq A B)
HQOut : OutCircle P A B
HPIn : InCircle P A B
A,B,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P A B
+++++
Between.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
subst Q.
exists P.
split.
Between.

*****
H : not (eq A B)
HQOut : OutCircle P A B
HPIn : InCircle P A B
A,B,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P A B
+++++
Circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).

*****
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
destruct (cong_dec A B A Q) as [HCong|HNCong].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].

*****
HCong : Cong A B A Q
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
exists Q.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
exists Q.

*****
HCong : Cong A B A Q
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet P Q Q) (OnCircle Q A B)
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
exists Q.
split.

*****
HCong : Cong A B A Q
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Q Q
+++++
Between.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
exists Q.
split.

*****
HCong : Cong A B A Q
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Q A B
+++++
Between.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
exists Q.
split.
Between.

*****
HCong : Cong A B A Q
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Q A B
+++++
Circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].

*****
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
assert (HB' : exists B', Cong A B A B' /\ Bet A P B').
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').

*****
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (Cong A B A B') (Bet A P B'))
+++++
destruct (eq_dec_points A P).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).

*****
H1 : eq A P
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (Cong A B A B') (Bet A P B'))
+++++
subst.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
subst.

*****
HNCong : not (Cong P B P Q)
H0 : not (eq P Q)
HPIn : InCircle P P B
HQOut : OutCircle Q P B
H : not (eq P B)
B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (Cong P B P B') (Bet P P B'))
+++++
exists B.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
subst.
exists B.

*****
HNCong : not (Cong P B P Q)
H0 : not (eq P Q)
HPIn : InCircle P P B
HQOut : OutCircle Q P B
H : not (eq P B)
B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Cong P B P B) (Bet P P B)
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
subst.
exists B.
split.

*****
HNCong : not (Cong P B P Q)
H0 : not (eq P Q)
HPIn : InCircle P P B
HQOut : OutCircle Q P B
H : not (eq P B)
B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong P B P B
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
subst.
exists B.
split.

*****
HNCong : not (Cong P B P Q)
H0 : not (eq P Q)
HPIn : InCircle P P B
HQOut : OutCircle Q P B
H : not (eq P B)
B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P P B
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
subst.
exists B.
split.
Cong.

*****
HNCong : not (Cong P B P Q)
H0 : not (eq P Q)
HPIn : InCircle P P B
HQOut : OutCircle Q P B
H : not (eq P B)
B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P P B
+++++
Between.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).

*****
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (Cong A B A B') (Bet A P B'))
+++++
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].

*****
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P A)
+++++
auto.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].

*****
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A B)
+++++
auto.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (Cong A B A B') (Bet A P B'))
+++++
auto.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun B' : Tpoint => and (Cong A B A B') (Bet A P B'))
+++++
exists B'.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Cong A B A B') (Bet A P B')
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.
split.

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A B'
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.
split.

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P B'
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.
split.
Cong.

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P B'
+++++
apply l6_13_1.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.
split.
Cong.
apply l6_13_1.

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A P B'
+++++
apply l6_6, HOut.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.
split.
Cong.
apply l6_13_1.

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A P A B'
+++++
apply (l5_6 A P A B).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.
split.
Cong.
apply l6_13_1.
apply (l5_6 A P A B).

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A P A B
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.
split.
Cong.
apply l6_13_1.
apply (l5_6 A P A B).

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A P A P
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct (eq_dec_points A P).
destruct (l6_11_existence A A B P) as [B' [HOut HCong]].
auto.
exists B'.
split.
Cong.
apply l6_13_1.
apply (l5_6 A P A B).

*****
HCong : Cong A B' A B
HOut : Out A B' P
B' : Tpoint
H1 : not (eq A P)
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A B'
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').

*****
HB' : ex (fun B' : Tpoint => and (Cong A B A B') (Bet A P B'))
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
destruct HB' as [B' [HCong HBet]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].

*****
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].

*****
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Q P
+++++
Col.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].

*****
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Q)
+++++
Col.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].

*****
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P B'
+++++
Col.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].

*****
HZ1 : OnCircle Z1 A B'
HCol1 : Col P Q Z1
Z1 : Tpoint
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
Col.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.

*****
HZ1 : OnCircle Z1 A B'
HCol1 : Col P Q Z1
Z1 : Tpoint
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
assert (HZ1On: OnCircle Z1 A B).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).

*****
HZ1 : OnCircle Z1 A B'
HCol1 : Col P Q Z1
Z1 : Tpoint
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z1 A B
+++++
apply cong_transitivity with A B'.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
apply cong_transitivity with A B'.

*****
HZ1 : OnCircle Z1 A B'
HCol1 : Col P Q Z1
Z1 : Tpoint
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z1 A B'
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
apply cong_transitivity with A B'.

*****
HZ1 : OnCircle Z1 A B'
HCol1 : Col P Q Z1
Z1 : Tpoint
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B' A B
+++++
Cong.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).

*****
HZ1On : OnCircle Z1 A B
HZ1 : OnCircle Z1 A B'
HCol1 : Col P Q Z1
Z1 : Tpoint
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
idtac.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.

*****
HZ1On : OnCircle Z1 A B
HZ1 : OnCircle Z1 A B'
HCol1 : Col P Q Z1
Z1 : Tpoint
HBet : Bet A P B'
HCong : Cong A B A B'
B' : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
clear dependent B'.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.

*****
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].

*****
HBet : Bet P Z1 Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
exists Z1.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
exists Z1.

*****
HBet : Bet P Z1 Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet P Z1 Q) (OnCircle Z1 A B)
+++++
auto.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].

*****
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
idtac.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.

*****
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].

*****
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z1 A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].

*****
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].

*****
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.

*****
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
exists Z2.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.

*****
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet P Z2 Q) (OnCircle Z2 A B)
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.

*****
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Z2 Q
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.

*****
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Z2 Q
+++++
assert_diffs.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Z2 Q
+++++
assert (HBet2 : Bet Z1 Z2 Q).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet Z1 Z2 Q
+++++
apply out2__bet.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Z1 Z2 Q
+++++
apply l6_7 with P.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply l6_7 with P.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Z1 Z2 P
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply l6_7 with P.
trivial.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Z1 Z2 P
+++++
apply l6_6, bet_out.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply l6_7 with P.
trivial.
apply l6_6, bet_out.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P Z1)
+++++
auto.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply l6_7 with P.
trivial.
apply l6_6, bet_out.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet Z1 P Z2
+++++
auto.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply l6_7 with P.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Z1 P Q
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Q Z1 Z2
+++++
apply (col_inc2_outcs__out A B).
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply (col_inc2_outcs__out A B).

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle Z1 A B
+++++
Circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply (col_inc2_outcs__out A B).

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle Z2 A B
+++++
Circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply (col_inc2_outcs__out A B).

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Z1 Z2 Q
+++++
Circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply (col_inc2_outcs__out A B).
Circle.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Z1 Z2 Q
+++++
ColR.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply (col_inc2_outcs__out A B).

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircleS Q A B
+++++
Circle.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply (col_inc2_outcs__out A B).
Circle.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircleS Q A B
+++++
split.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply (col_inc2_outcs__out A B).
Circle.
split.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A Q
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).
apply out2__bet.
apply (col_inc2_outcs__out A B).
Circle.
split.

*****
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong A B A Q)
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.
trivial.
assert_diffs.
assert (HBet2 : Bet Z1 Z2 Q).

*****
HBet2 : Bet Z1 Z2 Q
H1 : not (eq Z1 Z2)
H3 : not (eq Q Z1)
H2 : not (eq P Z1)
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P Z2 Q
+++++
eBetween.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HBet]].
trivial.
exists Z2.
split.

*****
HBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HOut : Out Z1 P Q
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z2 A B
+++++
trivial.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].

*****
HNCol : not (Col P Z1 Q)
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Bet P Z Q) (OnCircle Z A B))
+++++
exfalso.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
exfalso.

*****
HNCol : not (Col P Z1 Q)
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.
intros Hoplc A B P Q HPIn HQOut.
destruct (eq_dec_points A B).
destruct (eq_dec_points P Q).
destruct (cong_dec A B A Q) as [HCong|HNCong].
assert (HB' : exists B', Cong A B A B' /\\ Bet A P B').
destruct HB' as [B' [HCong HBet]].
destruct (Hoplc A B' P Q P) as [Z1 [HCol1 HZ1]].
Col.
assert (HZ1On: OnCircle Z1 A B).
idtac.
clear dependent B'.
destruct (or_bet_out P Z1 Q) as [HBet|[HOut|HNCol]].
exfalso.
apply HNCol.

*****
HNCol : not (Col P Z1 Q)
HZ1On : OnCircle Z1 A B
HCol1 : Col P Q Z1
Z1 : Tpoint
HNCong : not (Cong A B A Q)
H0 : not (eq P Q)
H : not (eq A B)
HQOut : OutCircle Q A B
HPIn : InCircle P A B
A,B,P,Q : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col P Z1 Q
+++++
Col.
-----
Lemma segment_circle__one_point_line_circle : segment_circle <-> one_point_line_circle.
Proof.
unfold segment_circle.
unfold one_point_line_circle.
split.

*****

*****

+++++
Qed.
-----
Lemma one_point_line_circle__two_points_line_circle :\n  one_point_line_circle <-> two_points_line_circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff one_point_line_circle two_points_line_circle
+++++
Proof.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff one_point_line_circle two_points_line_circle
+++++
unfold one_point_line_circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))) two_points_line_circle
+++++
unfold two_points_line_circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))) (forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2)))))))))
+++++
split.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))) (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2))))))))
+++++
intros Hoplc A B U V P HCol HUV HBet.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.

*****
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2))))))))
+++++
destruct (eq_dec_points P B) as [Heq|HPB].
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].

*****
Heq : eq P B
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2))))))))
+++++
subst P.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 B Z2) (forall _ : not (eq B B), not (eq Z1 Z2))))))))
+++++
exists B, B.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.
exists B, B.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V B) (and (OnCircle B A B) (and (Col U V B) (and (OnCircle B A B) (and (Bet B B B) (forall _ : not (eq B B), not (eq B B))))))
+++++
repeat split.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.
exists B, B.
repeat split.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V B
+++++
Circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.
exists B, B.
repeat split.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle B A B
+++++
Circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.
exists B, B.
repeat split.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V B
+++++
Circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.
exists B, B.
repeat split.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle B A B
+++++
Circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.
exists B, B.
repeat split.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B B B
+++++
Circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.
exists B, B.
repeat split.
Circle.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B B B
+++++
Between.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
subst P.
exists B, B.
repeat split.

*****
HBet : Bet A B B
HUV : not (eq U V)
HCol : Col U V B
A,B,U,V : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : not (eq B B), not (eq B B)
+++++
Circle.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].

*****
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2))))))))
+++++
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].

*****
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2))))))))
+++++
exists Z1.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.

*****
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2)))))))
+++++
assert (HPIn : InCircle P A B).
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).

*****
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
apply bet__le1213, HBet.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).

*****
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2)))))))
+++++
idtac.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.

*****
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2)))))))
+++++
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].

*****
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z1 A B
+++++
trivial.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].

*****
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
trivial.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].

*****
HPBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2)))))))
+++++
trivial.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.

*****
HPBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2)))))))
+++++
assert (Z1 <> P).
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).

*****
HPBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Z1 P)
+++++
intro.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).
intro.

*****
H : eq Z1 P
HPBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).
intro.
treat_equalities.

*****
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle Z1 A B
HZ1On : OnCircle Z1 A B
HBet : Bet A Z1 B
HPB : not (eq Z1 B)
HUV : not (eq U V)
HCol : Col U V Z1
A,B,U,V,Z1 : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HPB, between_cong with A.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).
intro.
treat_equalities.
apply HPB, between_cong with A.

*****
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle Z1 A B
HZ1On : OnCircle Z1 A B
HBet : Bet A Z1 B
HPB : not (eq Z1 B)
HUV : not (eq U V)
HCol : Col U V Z1
A,B,U,V,Z1 : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A Z1 B
+++++
trivial.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).
intro.
treat_equalities.
apply HPB, between_cong with A.

*****
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle Z1 A B
HZ1On : OnCircle Z1 A B
HBet : Bet A Z1 B
HPB : not (eq Z1 B)
HUV : not (eq U V)
HCol : Col U V Z1
A,B,U,V,Z1 : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z1 A B
+++++
trivial.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).

*****
H : not (eq Z1 P)
HPBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2)))))))
+++++
assert_diffs.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).
assert_diffs.

*****
H1 : not (eq A B)
H0 : not (eq Z1 Z2)
H : not (eq Z1 P)
HPBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2)))))))
+++++
exists Z2.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).
assert_diffs.
exists Z2.

*****
H1 : not (eq A B)
H0 : not (eq Z1 Z2)
H : not (eq Z1 P)
HPBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2))))))
+++++
repeat (split; trivial).
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Hoplc A B U V P HCol HUV HBet.
destruct (eq_dec_points P B) as [Heq|HPB].
destruct (Hoplc A B U V P HCol HUV HBet) as [Z1 [HZ1Col HZ1On]].
exists Z1.
assert (HPIn : InCircle P A B).
idtac.
destruct (chord_completion A B Z1 P) as [Z2 [HZ2On HPBet]].
trivial.
assert (Z1 <> P).
assert_diffs.
exists Z2.
repeat (split; trivial).

*****
H1 : not (eq A B)
H0 : not (eq Z1 Z2)
H : not (eq Z1 P)
HPBet : Bet Z1 P Z2
HZ2On : OnCircle Z2 A B
Z2 : Tpoint
HPIn : InCircle P A B
HZ1On : OnCircle Z1 A B
HZ1Col : Col U V Z1
Z1 : Tpoint
HPB : not (eq P B)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hoplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z2
+++++
ColR.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (Col U V Z1) (and (OnCircle Z1 A B) (and (Col U V Z2) (and (OnCircle Z2 A B) (and (Bet Z1 P Z2) (forall _ : not (eq P B), not (eq Z1 Z2))))))))) (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
intros Htplc A B U V P HCol HUV HBet.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Htplc A B U V P HCol HUV HBet.

*****
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Htplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (eq P B), not (eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (Htplc A B U V P HCol HUV HBet) as [Z [_ [HZ1 [HZ2 _]]]].
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Htplc A B U V P HCol HUV HBet.
destruct (Htplc A B U V P HCol HUV HBet) as [Z [_ [HZ1 [HZ2 _]]]].

*****
HZ2 : OnCircle Z A B
HZ1 : Col U V Z
Z : Tpoint
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Htplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (eq P B), not (eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
exists Z.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.
intros Htplc A B U V P HCol HUV HBet.
destruct (Htplc A B U V P HCol HUV HBet) as [Z [_ [HZ1 [HZ2 _]]]].
exists Z.

*****
HZ2 : OnCircle Z A B
HZ1 : Col U V Z
Z : Tpoint
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Htplc : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (Col U V Z1)\n (and (OnCircle Z1 A B)\n (and (Col U V Z2)\n (and (OnCircle Z2 A B)\n (and (Bet Z1 P Z2)\n (forall _ : not (eq P B), not (eq Z1 Z2))))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V Z) (OnCircle Z A B)
+++++
auto.
-----
Lemma one_point_line_circle__two_points_line_circle : one_point_line_circle <-> two_points_line_circle.
Proof.
unfold one_point_line_circle.
unfold two_points_line_circle.
split.

*****

*****

+++++
Qed.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff circle_circle_bis circle_circle_axiom
+++++
Proof.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff circle_circle_bis circle_circle_axiom
+++++
split.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_bis, circle_circle_axiom
+++++
intro cc.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.

*****
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
circle_circle_axiom
+++++
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Cong A Z A B) (Cong C Z C D))
+++++
apply cc with D' B'.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
apply cc with D' B'.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle D' C D
+++++
try apply bet__le1213.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
apply cc with D' B'.
try apply bet__le1213.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle D' C D
+++++
trivial.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
apply cc with D' B'.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle D' A B
+++++
try apply bet__le1213.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
apply cc with D' B'.
try apply bet__le1213.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A D' B
+++++
trivial.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
apply cc with D' B'.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle B' A B
+++++
try apply bet__le1213.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
apply cc with D' B'.
try apply bet__le1213.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle B' A B
+++++
trivial.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
apply cc with D' B'.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle B' C D
+++++
try apply bet__le1213.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D B' D' HCong1 HCong2 HBet1 HBet2.
apply cc with D' B'.
try apply bet__le1213.

*****
HBet2 : Bet C B' D
HBet1 : Bet A D' B
HCong2 : Cong C D' C D
HCong1 : Cong A B' A B
A,B,C,D,B',D' : Tpoint
cc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C B' D
+++++
trivial.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_axiom, circle_circle_bis
+++++
intro cc.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.

*****
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
circle_circle_bis
+++++
intros A B C D P Q HPOn HPIn HQOn HQIn.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.

*****
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HQ' : Le A P A Q).
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).

*****
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A P A Q
+++++
apply le_transitivity with A B.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
apply le_transitivity with A B.

*****
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A P A B
+++++
Le.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
apply le_transitivity with A B.

*****
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A Q
+++++
Le.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).

*****
HQ' : Le A P A Q
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
idtac.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.

*****
HQ' : Le A P A Q
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
apply l5_5_1 in HQ'.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.

*****
HQ' : ex (fun x : Tpoint => and (Bet A P x) (Cong A x A Q))
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct HQ' as [Q' [HBet1 HCong1]].
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].

*****
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HP' : Le C Q C P).
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).

*****
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C Q C P
+++++
apply le_transitivity with C D.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
apply le_transitivity with C D.

*****
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C Q C D
+++++
Le.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
apply le_transitivity with C D.

*****
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D C P
+++++
Le.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).

*****
HP' : Le C Q C P
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
idtac.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.

*****
HP' : Le C Q C P
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
apply l5_5_1 in HP'.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.

*****
HP' : ex (fun x : Tpoint => and (Bet C Q x) (Cong C x C P))
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct HP' as [P' [HBet2 HCong2]].
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].

*****
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (cc A Q' C P' Q P) as [Z []].
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].

*****
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Q A Q'
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].

*****
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P C P'
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].

*****
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P Q'
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].

*****
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Q P'
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
exists Z.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z A B) (OnCircle Z C D)
+++++
split.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z A B
+++++
apply cong_transitivity with A Q.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with A Q.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z A Q
+++++
apply cong_transitivity with A Q'.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with A Q.
apply cong_transitivity with A Q'.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z A Q'
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with A Q.
apply cong_transitivity with A Q'.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Q' A Q
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with A Q.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Q A B
+++++
idtac.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with A Q.
idtac.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Q A B
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z C D
+++++
apply cong_transitivity with C P.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with C P.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Z C P
+++++
apply cong_transitivity with C P'.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with C P.
apply cong_transitivity with C P'.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Z C P'
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with C P.
apply cong_transitivity with C P'.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P' C P
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with C P.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P C D
+++++
idtac.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.
intro cc.
intros A B C D P Q HPOn HPIn HQOn HQIn.
assert (HQ' : Le A P A Q).
idtac.
apply l5_5_1 in HQ'.
destruct HQ' as [Q' [HBet1 HCong1]].
assert (HP' : Le C Q C P).
idtac.
apply l5_5_1 in HP'.
destruct HP' as [P' [HBet2 HCong2]].
destruct (cc A Q' C P' Q P) as [Z []].
Cong.
exists Z.
split.
apply cong_transitivity with C P.
idtac.

*****
H0 : Cong C Z C P'
H : Cong A Z A Q'
Z : Tpoint
HCong2 : Cong C P' C P
HBet2 : Bet C Q P'
P' : Tpoint
HCong1 : Cong A Q' A Q
HBet1 : Bet A P Q'
Q' : Tpoint
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
cc : circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P C D
+++++
Cong.
-----
Lemma circle_circle_bis__circle_circle_axiom : circle_circle_bis <-> circle_circle_axiom.
Proof.
split.

*****

*****

+++++
Qed.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle, circle_circle_bis
+++++
Proof.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle, circle_circle_bis
+++++
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.

*****
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (eq_dec_points P Q).
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).

*****
H : eq P Q
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
subst Q.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
subst Q.

*****
HQOn : OnCircle P A B
HQIn : InCircle P C D
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
exists P.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
subst Q.
exists P.

*****
HQOn : OnCircle P A B
HQIn : InCircle P C D
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle P A B) (OnCircle P C D)
+++++
split.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
subst Q.
exists P.
split.

*****
HQOn : OnCircle P A B
HQIn : InCircle P C D
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P A B
+++++
assumption.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
subst Q.
exists P.
split.

*****
HQOn : OnCircle P A B
HQIn : InCircle P C D
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P C D
+++++
assumption.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).

*****
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].

*****
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].

*****
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle Q C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].

*****
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.

*****
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].

*****
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Q A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].

*****
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].

*****
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.

*****
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
apply (Hcc A B C D P P').
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').

*****
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').

*****
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P' C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').

*****
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').

*****
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle P' A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.

*****
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle P' A B
+++++
destruct (le_cases A P' A B).
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).

*****
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle P' A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.

*****
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle P' A B
+++++
assert (P' = Q).
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).

*****
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq P' Q
+++++
apply between_equality with Q'.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.

*****
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P' Q Q'
+++++
eBetween.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.

*****
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet Q P' Q'
+++++
assert_diffs.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.
assert_diffs.

*****
H2 : not (eq Q Q')
H1 : not (eq P P')
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet Q P' Q'
+++++
apply (col_inc_onc2__bet A B).
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.
assert_diffs.
apply (col_inc_onc2__bet A B).

*****
H2 : not (eq Q Q')
H1 : not (eq P P')
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q Q')
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.
assert_diffs.
apply (col_inc_onc2__bet A B).

*****
H2 : not (eq Q Q')
H1 : not (eq P P')
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Q A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.
assert_diffs.
apply (col_inc_onc2__bet A B).

*****
H2 : not (eq Q Q')
H1 : not (eq P P')
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Q' A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.
assert_diffs.
apply (col_inc_onc2__bet A B).

*****
H2 : not (eq Q Q')
H1 : not (eq P P')
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Q Q' P'
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.
assert_diffs.
apply (col_inc_onc2__bet A B).
trivial.

*****
H2 : not (eq Q Q')
H1 : not (eq P P')
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col Q Q' P'
+++++
ColR.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
apply between_equality with Q'.
assert_diffs.
apply (col_inc_onc2__bet A B).

*****
H2 : not (eq Q Q')
H1 : not (eq P P')
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P' A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).

*****
H1 : eq P' Q
H0 : Le A P' A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle P' A B
+++++
subst.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
subst.

*****
H0 : Le A Q A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HP'On : OnCircle Q C D
HBetQ : Bet P Q Q
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q A B
+++++
apply cong__le.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).
trivial.
assert (P' = Q).
subst.
apply cong__le.

*****
H0 : Le A Q A B
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HP'On : OnCircle Q C D
HBetQ : Bet P Q Q
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A Q
+++++
Cong.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).
destruct (chord_completion C D P Q) as [P' [HP'On HBetQ]].
trivial.
destruct (chord_completion A B Q P) as [Q' [HQ'On HBetP]].
trivial.
apply (Hcc A B C D P P').
trivial.
destruct (le_cases A P' A B).

*****
H0 : Le A B A P'
HBetP : Bet Q P Q'
HQ'On : OnCircle Q' A B
Q' : Tpoint
HBetQ : Bet P Q P'
HP'On : OnCircle P' C D
P' : Tpoint
H : not (eq P Q)
HQIn : InCircle Q C D
HQOn : OnCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : circle_circle
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle P' A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_bis : circle_circle -> circle_circle_bis.
Proof.
intros Hcc A B C D P Q HPOn HPIn HQOn HQIn.
destruct (eq_dec_points P Q).

*****

*****

+++++
Qed.
-----
Lemma circle_circle_bis__one_point_line_circle :\n  circle_circle_bis -> one_point_line_circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_bis, one_point_line_circle
+++++
Proof.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_bis, one_point_line_circle
+++++
unfold circle_circle_bis.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D)), one_point_line_circle
+++++
unfold one_point_line_circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))) (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
intro Hcc.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.

*****
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\ OnCircle Z A B).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).

*****
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B) (_ : not (Per A U V)), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
intros A B U V P HCol HUV HBet HNPer.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.

*****
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (col_dec U V B) as [|HNCol].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].

*****
H : Col U V B
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
exists B.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
exists B.

*****
H : Col U V B
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V B) (OnCircle B A B)
+++++
split.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
exists B.
split.

*****
H : Col U V B
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V B
+++++
Circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
exists B.
split.

*****
H : Col U V B
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle B A B
+++++
Circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].

*****
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (eq_dec_points A P).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).

*****
H : eq A P
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
subst P.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.

*****
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].

*****
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V A
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].

*****
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].
trivial.

*****
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (segment_construction W A A B) as [Z [HZ1 HZ2]].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (segment_construction W A A B) as [Z [HZ1 HZ2]].

*****
HZ2 : Cong A Z A B
HZ1 : Bet W A Z
Z : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
exists Z.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (segment_construction W A A B) as [Z [HZ1 HZ2]].
exists Z.

*****
HZ2 : Cong A Z A B
HZ1 : Bet W A Z
Z : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V Z) (OnCircle Z A B)
+++++
split.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (segment_construction W A A B) as [Z [HZ1 HZ2]].
exists Z.
split.

*****
HZ2 : Cong A Z A B
HZ1 : Bet W A Z
Z : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (segment_construction W A A B) as [Z [HZ1 HZ2]].
exists Z.
split.
trivial.

*****
HZ2 : Cong A Z A B
HZ1 : Bet W A Z
Z : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
ColR.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
subst P.
destruct (diff_col_ex3 U V A) as [W [HUW [HVW [HPW HCol2]]]].
trivial.
destruct (segment_construction W A A B) as [Z [HZ1 HZ2]].
exists Z.
split.

*****
HZ2 : Cong A Z A B
HZ1 : Bet W A Z
Z : Tpoint
HCol2 : Col U V W
HPW : not (eq A W)
HVW : not (eq V W)
HUW : not (eq U W)
W : Tpoint
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A A B
HUV : not (eq U V)
HCol : Col U V A
A,B,U,V : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z A B
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).

*****
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (l10_6_existence U V A) as [C HC].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].

*****
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (l10_6_existence U V B) as [D HD].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
assert (HBet' : Bet C P D).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C P D
+++++
apply image_gen_preserves_bet with A P B U V.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect A C U V
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect P P U V
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.
trivial.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect P P U V
+++++
left.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.
trivial.
left.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (not (eq U V)) (ReflectL P P U V)
+++++
split.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.
trivial.
left.
split.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq U V)
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.
trivial.
left.
split.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ReflectL P P U V
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.
trivial.
left.
split.
trivial.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ReflectL P P U V
+++++
apply col__image_spec, HCol.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect B D U V
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
apply image_gen_preserves_bet with A P B U V.

*****
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P B
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).

*****
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
assert (HCong : Cong B P D P).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).

*****
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B P D P
+++++
apply (is_image_col_cong U V).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
apply (is_image_col_cong U V).

*****
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq U V)
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
apply (is_image_col_cong U V).

*****
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect B D U V
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
apply (is_image_col_cong U V).

*****
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V P
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).

*****
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
idtac.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.

*****
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
assert (HDIn : InCircle D A B).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).

*****
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle D A B
+++++
apply triangle_inequality with P.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
apply triangle_inequality with P.

*****
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P B
+++++
Cong.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
apply triangle_inequality with P.

*****
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong P D P B
+++++
Cong.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).

*****
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
assert (HBIn : InCircle B C D).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).

*****
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle B C D
+++++
apply triangle_inequality with P.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
apply triangle_inequality with P.

*****
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C P D
+++++
Cong.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
apply triangle_inequality with P.

*****
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong P B P D
+++++
Cong.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).

*****
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (Hcc A B C D D B) as [Z0 []].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].

*****
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle D C D
+++++
Circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].

*****
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle D A B
+++++
Circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].

*****
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle B A B
+++++
Circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].

*****
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle B C D
+++++
Circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].

*****
H1 : OnCircle Z0 C D
H0 : OnCircle Z0 A B
Z0 : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
Circle.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.

*****
H1 : OnCircle Z0 C D
H0 : OnCircle Z0 A B
Z0 : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].

*****
H1 : OnCircle Z0 C D
H0 : OnCircle Z0 A B
Z0 : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z0 A B
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].

*****
H1 : OnCircle Z0 C D
H0 : OnCircle Z0 A B
Z0 : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z0 C D
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
H1 : OnCircle Z0 C D
H0 : OnCircle Z0 A B
Z0 : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
H1 : OnCircle Z0 C D
H0 : OnCircle Z0 A B
Z0 : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
clear dependent Z0.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
exists Z.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V Z) (OnCircle Z A B)
+++++
split.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
apply cong_cop_image__col with A C.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intro.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
intro.

*****
H0 : eq A C
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
treat_equalities.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
intro.
treat_equalities.

*****
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Col A U V).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
intro.
treat_equalities.
assert (Col A U V).

*****
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A U V
+++++
apply l10_8, HC.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
intro.
treat_equalities.
assert (Col A U V).

*****
H0 : Col A U V
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
intro.
treat_equalities.
assert (Col A U V).
idtac.

*****
H0 : Col A U V
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
intro.
treat_equalities.
assert (Col A U V).
idtac.
apply HNCol.

*****
H0 : Col A U V
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V B
+++++
ColR.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect A C U V
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z C Z
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z C Z
+++++
apply cong_transitivity with A B.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply cong_transitivity with A B.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z A B
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply cong_transitivity with A B.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B C Z
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply cong_transitivity with A B.
trivial.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B C Z
+++++
apply cong_transitivity with C D.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply cong_transitivity with A B.
trivial.
apply cong_transitivity with C D.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B C D
+++++
Cong.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply cong_transitivity with A B.
trivial.
apply cong_transitivity with C D.
Cong.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B C D
+++++
apply cong_symmetry, l10_10 with U V.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply cong_transitivity with A B.
trivial.
apply cong_transitivity with C D.
Cong.
apply cong_symmetry, l10_10 with U V.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect A C U V
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply cong_transitivity with A B.
trivial.
apply cong_transitivity with C D.
Cong.
apply cong_symmetry, l10_10 with U V.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect B D U V
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply cong_transitivity with A B.
trivial.
apply cong_transitivity with C D.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C D C Z
+++++
Cong.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar U V A Z
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar U V A Z
+++++
apply coplanar_perm_2.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar U A V Z
+++++
apply coplanar_trans_1 with C.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col C U A)
+++++
Cop.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col C U A)
+++++
intro.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.

*****
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (eq_dec_points A C).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).

*****
H1 : eq A C
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst C.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
subst C.

*****
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
H0 : Col A U A
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Col A U V).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
subst C.
assert (Col A U V).

*****
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
H0 : Col A U A
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A U V
+++++
apply l10_8, HC.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
subst C.
assert (Col A U V).

*****
H1 : Col A U V
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
H0 : Col A U A
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
subst C.
assert (Col A U V).
idtac.

*****
H1 : Col A U V
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
H0 : Col A U A
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCol.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
subst C.
assert (Col A U V).
idtac.
apply HNCol.

*****
H1 : Col A U V
HZ2 : OnCircle Z A D
HCop : Coplanar A A U Z
H0 : Col A U A
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B A D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet A P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A A U V
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V B
+++++
ColR.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Habs : ReflectL_at U A C U V).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ReflectL_at U A C U V
+++++
apply image_image_in.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
apply image_image_in.

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
apply image_image_in.

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ReflectL A C U V
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
apply image_image_in.
Col.

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ReflectL A C U V
+++++
apply is_image_is_image_spec.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
apply image_image_in.
Col.
apply is_image_is_image_spec.

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq U V)
+++++
auto.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
apply image_image_in.
Col.
apply is_image_is_image_spec.

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect A C U V
+++++
auto.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
apply image_image_in.

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V U
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
apply image_image_in.

*****
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A U C
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).

*****
Habs : ReflectL_at U A C U V
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct Habs as [_ [|]].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].

*****
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.

*****
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNPer.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.
apply HNPer.

*****
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A U V
+++++
destruct (eq_dec_points A U).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.
apply HNPer.
destruct (eq_dec_points A U).

*****
H3 : eq A U
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A U V
+++++
subst.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.
apply HNPer.
destruct (eq_dec_points A U).
subst.

*****
HCop : Coplanar U C U Z
H0 : Col C U U
H1 : not (eq U C)
H2 : Perp U V C U
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z U B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D U B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect U C U V
C : Tpoint
H : not (eq U P)
HNCol : not (Col U V B)
HBet : Bet U P B
HNPer : not (Per U U V)
HUV : not (eq U V)
HCol : Col U V P
B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per U U V
+++++
Perp.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.
apply HNPer.
destruct (eq_dec_points A U).

*****
H3 : not (eq A U)
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A U V
+++++
apply perp_per_2, perp_left_comm, perp_col with C.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.
apply HNPer.
destruct (eq_dec_points A U).
apply perp_per_2, perp_left_comm, perp_col with C.

*****
H3 : not (eq A U)
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A U)
+++++
Perp.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.
apply HNPer.
destruct (eq_dec_points A U).
apply perp_per_2, perp_left_comm, perp_col with C.

*****
H3 : not (eq A U)
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Perp A C U V
+++++
Perp.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.
apply HNPer.
destruct (eq_dec_points A U).
apply perp_per_2, perp_left_comm, perp_col with C.

*****
H3 : not (eq A U)
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C U
+++++
Perp.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].
auto.
apply HNPer.
destruct (eq_dec_points A U).
apply perp_per_2, perp_left_comm, perp_col with C.
Perp.

*****
H3 : not (eq A U)
H2 : Perp U V C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C U
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.
Cop.
intro.
destruct (eq_dec_points A C).
assert (Habs : ReflectL_at U A C U V).
destruct Habs as [_ [|]].

*****
H2 : eq C A
H1 : not (eq A C)
H0 : Col C U A
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
auto.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C U A V
+++++
Cop.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.
trivial.
apply cong_cop_image__col with A C.
trivial.
apply coplanar_perm_2.
apply coplanar_trans_1 with C.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar C U A Z
+++++
Cop.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet HNPer.
destruct (col_dec U V B) as [|HNCol].
destruct (eq_dec_points A P).
destruct (l10_6_existence U V A) as [C HC].
destruct (l10_6_existence U V B) as [D HD].
assert (HBet' : Bet C P D).
assert (HCong : Cong B P D P).
idtac.
assert (HDIn : InCircle D A B).
assert (HBIn : InCircle B C D).
destruct (Hcc A B C D D B) as [Z0 []].
Circle.
destruct (circle_circle_cop A B C D Z0 U) as [Z [HZ1 [HZ2 HCop]]].
trivial.
clear dependent Z0.
exists Z.
split.

*****
HCop : Coplanar A C U Z
HZ2 : OnCircle Z C D
HZ1 : OnCircle Z A B
Z : Tpoint
HBIn : InCircle B C D
HDIn : InCircle D A B
HCong : Cong B P D P
HBet' : Bet C P D
HD : Reflect B D U V
D : Tpoint
HC : Reflect A C U V
C : Tpoint
H : not (eq A P)
HNCol : not (Col U V B)
HNPer : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z A B
+++++
trivial.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).

*****
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V)) (_ : Bet A P B), ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
intros A B U V P HCol HUV HBet.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.

*****
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (per_dec A U V).
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).

*****
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
idtac.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.

*****
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
destruct (Haux A B V U P) as [Z []].
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].

*****
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col V U P
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].

*****
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq V U)
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].

*****
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P B
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].

*****
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Per A V U)
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].
Col.

*****
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Per A V U)
+++++
intro.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].
Col.
intro.

*****
H0 : Per A V U
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HUV, l8_7 with A.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].
Col.
intro.
apply HUV, l8_7 with A.

*****
H0 : Per A V U
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A U V
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].
Col.
intro.
apply HUV, l8_7 with A.

*****
H0 : Per A V U
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per A V U
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].

*****
H1 : OnCircle Z A B
H0 : Col V U Z
Z : Tpoint
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].
Col.

*****
H1 : OnCircle Z A B
H0 : Col V U Z
Z : Tpoint
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
exists Z.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].
Col.
exists Z.

*****
H1 : OnCircle Z A B
H0 : Col V U Z
Z : Tpoint
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Col U V Z) (OnCircle Z A B)
+++++
split.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].
Col.
exists Z.
split.

*****
H1 : OnCircle Z A B
H0 : Col V U Z
Z : Tpoint
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V Z
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
idtac.
destruct (Haux A B V U P) as [Z []].
Col.
exists Z.
split.

*****
H1 : OnCircle Z A B
H0 : Col V U Z
Z : Tpoint
H : Per A U V
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z A B
+++++
Col.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).

*****
H : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
+++++
apply Haux with P.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
apply Haux with P.

*****
H : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col U V P
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
apply Haux with P.

*****
H : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq U V)
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
apply Haux with P.

*****
H : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A P B
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).
intros A B U V P HCol HUV HBet.
destruct (per_dec A U V).
apply Haux with P.

*****
H : not (Per A U V)
HBet : Bet A P B
HUV : not (eq U V)
HCol : Col U V P
A,B,U,V,P : Tpoint
Haux : forall (A B U V P : Tpoint) (_ : Col U V P) (_ : not (eq U V))\n (_ : Bet A P B) (_ : not (Per A U V)),\nex (fun Z : Tpoint => and (Col U V Z) (OnCircle Z A B))
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : InCircle P A B) (_ : OnCircle Q A B) (_ : InCircle Q C D),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Per A U V)
+++++
assumption.
-----
Lemma circle_circle_bis__one_point_line_circle : circle_circle_bis -> one_point_line_circle.
Proof.
unfold circle_circle_bis.
unfold one_point_line_circle.
intro Hcc.
assert (Haux : forall A B U V P, Col U V P -> U <> V -> Bet A P B -> ~ Per A U V -> exists Z : Tpoint, Col U V Z /\\ OnCircle Z A B).

*****

*****

+++++
Qed.
-----
Lemma circle_circle__circle_circle_two :\n circle_circle <-> circle_circle_two.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff circle_circle circle_circle_two
+++++
Proof.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff circle_circle circle_circle_two
+++++
unfold circle_circle.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))) circle_circle_two
+++++
unfold circle_circle_two.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
iff (forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))) (forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2))))))))
+++++
split.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))) (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))
+++++
intros Hcc A B C D P Q.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.

*****
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))
+++++
intros.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))
+++++
destruct (eq_dec_points A C).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).

*****
H3 : eq A C
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))
+++++
subst C.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 A D) (and (OnCircle Z2 A B) (and (OnCircle Z2 A D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))
+++++
exists P.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (OnCircle P A B) (and (OnCircle P A D) (and (OnCircle Z2 A B) (and (OnCircle Z2 A D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq P Z2))))))
+++++
exists P.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle P A B) (and (OnCircle P A D) (and (OnCircle P A B) (and (OnCircle P A D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq P P)))))
+++++
assert (Cong A B A D).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A D
+++++
apply le_anti_symmetry.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
apply le_anti_symmetry.

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A D
+++++
apply (l5_6 A B A Q).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
apply le_anti_symmetry.
apply (l5_6 A B A Q).

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A Q
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
apply le_anti_symmetry.
apply (l5_6 A B A Q).

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A B
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
apply le_anti_symmetry.
apply (l5_6 A B A Q).

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Q A D
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
apply le_anti_symmetry.

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A D A B
+++++
apply (l5_6 A P A B).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
apply le_anti_symmetry.
apply (l5_6 A P A B).

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A P A B
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
apply le_anti_symmetry.
apply (l5_6 A P A B).

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A P A D
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
apply le_anti_symmetry.
apply (l5_6 A P A B).

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A B
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).

*****
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle P A B) (and (OnCircle P A D) (and (OnCircle P A B) (and (OnCircle P A D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq P P)))))
+++++
assert (Cong A P A B).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).

*****
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A P A B
+++++
apply cong_transitivity with A D.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
apply cong_transitivity with A D.

*****
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A P A D
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
apply cong_transitivity with A D.

*****
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D A B
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).

*****
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle P A B) (and (OnCircle P A D) (and (OnCircle P A B) (and (OnCircle P A D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq P P)))))
+++++
idtac.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.

*****
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle P A B) (and (OnCircle P A D) (and (OnCircle P A B) (and (OnCircle P A D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq P P)))))
+++++
repeat split.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.
repeat split.

*****
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.
repeat split.

*****
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P A D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.
repeat split.

*****
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.
repeat split.

*****
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P A D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.
repeat split.

*****
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq P P)
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.
repeat split.
trivial.

*****
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq P P)
+++++
intro Habs.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.
repeat split.
trivial.
intro Habs.

*****
Habs : InCircleS P A B
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : OutCircleS Q A B, not (eq P P)
+++++
destruct Habs.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
subst C.
exists P.
exists P.
assert (Cong A B A D).
assert (Cong A P A B).
idtac.
repeat split.
trivial.
intro Habs.
destruct Habs.

*****
H6 : not (Cong A P A B)
H5 : Le A P A B
H4 : Cong A P A B
H3 : Cong A B A D
H2 : OutCircle Q A B
H1 : InCircle P A B
H : OnCircle P A D
H0 : OnCircle Q A D
A,B,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : OutCircleS Q A B, not (eq P P)
+++++
contradiction.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).

*****
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))
+++++
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].

*****
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].

*****
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Q C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].

*****
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].

*****
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].

*****
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.

*****
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))
+++++
exists Z1.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.

*****
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2))))))
+++++
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].

*****
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2))))))
+++++
exists Z2.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.

*****
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))
+++++
assert (Cong Z1 C Z2 C).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).

*****
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong Z1 C Z2 C
+++++
apply (is_image_col_cong A C Z1 Z2 C).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
apply (is_image_col_cong A C Z1 Z2 C).

*****
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Col.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
apply (is_image_col_cong A C Z1 Z2 C).

*****
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect Z1 Z2 A C
+++++
Col.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
apply (is_image_col_cong A C Z1 Z2 C).

*****
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C C
+++++
Col.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).

*****
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))
+++++
idtac.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.

*****
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))
+++++
assert (Cong Z1 A Z2 A).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).

*****
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong Z1 A Z2 A
+++++
apply (is_image_col_cong A C Z1 Z2 A).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
apply (is_image_col_cong A C Z1 Z2 A).

*****
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
Col.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
apply (is_image_col_cong A C Z1 Z2 A).

*****
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Reflect Z1 Z2 A C
+++++
Col.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
apply (is_image_col_cong A C Z1 Z2 A).

*****
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col A C A
+++++
Col.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))
+++++
idtac.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))
+++++
repeat split.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z1 A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z1 C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z2 A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z2 A B
+++++
unfold OnCircle in *.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
unfold OnCircle in *.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : Cong C Z1 C D
HZ1A : Cong A Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : Cong C Q C D
H : Cong C P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : Cong C P C D) (_ : Cong C Q C D)\n (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Cong A Z A B) (Cong C Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z2 A B
+++++
eCong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z2 C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z2 C D
+++++
unfold OnCircle in *.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
unfold OnCircle in *.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : Cong C Z1 C D
HZ1A : Cong A Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : Cong C Q C D
H : Cong C P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : Cong C P C D) (_ : Cong C Q C D)\n (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (Cong A Z A B) (Cong C Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Z2 C D
+++++
eCong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.

*****
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)
+++++
intros.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.

*****
H7 : OutCircleS Q A B
H6 : InCircleS P A B
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Z1 Z2)
+++++
intro.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.

*****
H8 : eq Z1 Z2
H7 : OutCircleS Q A B
H6 : InCircleS P A B
H5 : Cong Z1 A Z2 A
H4 : Cong Z1 C Z2 C
HZ2 : Reflect Z1 Z2 A C
Z2 : Tpoint
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst Z2.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.

*****
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
H4 : Cong Z1 C Z1 C
H5 : Cong Z1 A Z1 A
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
clean.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.

*****
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (lt__nle A B A Q).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A B A Q
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Q A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Q A B
+++++
apply l5_6 with A Q A Z1.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Q A Z1
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.
Cong.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Q A Z1
+++++
apply triangle_inequality with C.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.
Cong.
apply triangle_inequality with C.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C Z1
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.
Cong.
apply triangle_inequality with C.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Q C Z1
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.
Cong.
apply triangle_inequality with C.
trivial.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Q C Z1
+++++
apply cong_transitivity with C D.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.
Cong.
apply triangle_inequality with C.
trivial.
apply cong_transitivity with C D.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Q C D
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.
Cong.
apply triangle_inequality with C.
trivial.
apply cong_transitivity with C D.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C D C Z1
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Q A Q
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A B A Q).
trivial.
apply l5_6 with A Q A Z1.

*****
HBet : Bet A C Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z1 A B
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (lt__nle A P A B).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A P A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A P
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A P
+++++
apply l5_6 with A Z1 A P.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Z1 A P
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.
Cong.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Z1 A P
+++++
apply triangle_reverse_inequality with C.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.
Cong.
apply triangle_reverse_inequality with C.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C A Z1
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.
Cong.
apply triangle_reverse_inequality with C.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P C Z1
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.
Cong.
apply triangle_reverse_inequality with C.
trivial.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P C Z1
+++++
apply cong_transitivity with C D.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.
Cong.
apply triangle_reverse_inequality with C.
trivial.
apply cong_transitivity with C D.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P C D
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.
Cong.
apply triangle_reverse_inequality with C.
trivial.
apply cong_transitivity with C D.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C D C Z1
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z1 A B
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
apply (lt__nle A P A B).
trivial.
apply l5_6 with A Z1 A P.

*****
HOut : Out C A Z1
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A P A P
+++++
Cong.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].

*****
HNCol : not (Col A C Z1)
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HCol := l10_8 A C Z1 HZ2).
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcc A B C D P Q.
intros.
destruct (eq_dec_points A C).
destruct (Hcc A B C D P Q) as [Z1 [HZ1A HZ1B]].
trivial.
exists Z1.
destruct (l10_6_existence A C Z1) as [Z2 HZ2].
exists Z2.
assert (Cong Z1 C Z2 C).
idtac.
assert (Cong Z1 A Z2 A).
idtac.
repeat split.
trivial.
intros.
intro.
subst Z2.
clean.
destruct (or_bet_out A C Z1) as [HBet|[HOut|HNCol]].
assert (HCol := l10_8 A C Z1 HZ2).

*****
HCol : Col Z1 A C
HNCol : not (Col A C Z1)
H7 : OutCircleS Q A B
H6 : InCircleS P A B
HZ2 : Reflect Z1 Z1 A C
HZ1B : OnCircle Z1 C D
HZ1A : OnCircle Z1 A B
Z1 : Tpoint
H3 : not (eq A C)
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcc : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
Col.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z1 : Tpoint => ex (fun Z2 : Tpoint => and (OnCircle Z1 A B) (and (OnCircle Z1 C D) (and (OnCircle Z2 A B) (and (OnCircle Z2 C D) (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B), not (eq Z1 Z2)))))))) (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
intros Hcct A B C D P Q.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.

*****
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
intros.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.
intros.

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (Hcct A B C D P Q) as [Z1 [Z2 [HZ1On [HZ1On' _]]]].
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.
intros.
destruct (Hcct A B C D P Q) as [Z1 [Z2 [HZ1On [HZ1On' _]]]].

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.
intros.
destruct (Hcct A B C D P Q) as [Z1 [Z2 [HZ1On [HZ1On' _]]]].

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Q C D
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.
intros.
destruct (Hcct A B C D P Q) as [Z1 [Z2 [HZ1On [HZ1On' _]]]].

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle P A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.
intros.
destruct (Hcct A B C D P Q) as [Z1 [Z2 [HZ1On [HZ1On' _]]]].

*****
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q A B
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.
intros.
destruct (Hcct A B C D P Q) as [Z1 [Z2 [HZ1On [HZ1On' _]]]].

*****
HZ1On' : OnCircle Z1 C D
HZ1On : OnCircle Z1 A B
Z1,Z2 : Tpoint
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
trivial.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.
intros.
destruct (Hcct A B C D P Q) as [Z1 [Z2 [HZ1On [HZ1On' _]]]].
trivial.

*****
HZ1On' : OnCircle Z1 C D
HZ1On : OnCircle Z1 A B
Z1,Z2 : Tpoint
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
exists Z1.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.
intros Hcct A B C D P Q.
intros.
destruct (Hcct A B C D P Q) as [Z1 [Z2 [HZ1On [HZ1On' _]]]].
trivial.
exists Z1.

*****
HZ1On' : OnCircle Z1 C D
HZ1On : OnCircle Z1 A B
Z1,Z2 : Tpoint
H2 : OutCircle Q A B
H1 : InCircle P A B
H0 : OnCircle Q C D
H : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Hcct : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircle P A B) (_ : OutCircle Q A B),\nex\n (fun Z1 : Tpoint =>\n ex\n (fun Z2 : Tpoint =>\n and (OnCircle Z1 A B)\n (and (OnCircle Z1 C D)\n (and (OnCircle Z2 A B)\n (and (OnCircle Z2 C D)\n (forall (_ : InCircleS P A B) (_ : OutCircleS Q A B),\n not (eq Z1 Z2)))))))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z1 A B) (OnCircle Z1 C D)
+++++
auto.
-----
Lemma circle_circle__circle_circle_two : circle_circle <-> circle_circle_two.
Proof.
unfold circle_circle.
unfold circle_circle_two.
split.

*****

*****

+++++
Qed.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1,\n  SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' ->\n  Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D ->\n  Out B A E1 -> Cong B E1 E F ->\n  Bet C1 E1 C2.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F A' B' E' F' C1 C2 E1 : Tpoint) (_ : SumS A B C D E' F') (_ : SumS C D E F A' B') (_ : Le E F E' F') (_ : Le A B A' B') (_ : Out A B C1) (_ : Cong A C1 C D) (_ : Bet B A C2) (_ : Cong A C2 C D) (_ : Out B A E1) (_ : Cong B E1 E F), Bet C1 E1 C2
+++++
Proof.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E F A' B' E' F' C1 C2 E1 : Tpoint) (_ : SumS A B C D E' F') (_ : SumS C D E F A' B') (_ : Le E F E' F') (_ : Le A B A' B') (_ : Out A B C1) (_ : Cong A C1 C D) (_ : Bet B A C2) (_ : Cong A C2 C D) (_ : Out B A E1) (_ : Cong B E1 E F), Bet C1 E1 C2
+++++
intros A B C D E F A' B' E' F'.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.

*****
A,B,C,D,E,F,A',B',E',F' : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (C1 C2 E1 : Tpoint) (_ : SumS A B C D E' F') (_ : SumS C D E F A' B') (_ : Le E F E' F') (_ : Le A B A' B') (_ : Out A B C1) (_ : Cong A C1 C D) (_ : Bet B A C2) (_ : Cong A C2 C D) (_ : Out B A E1) (_ : Cong B E1 E F), Bet C1 E1 C2
+++++
intros.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.

*****
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C1 E1 C2
+++++
assert (Bet C1 A C2).
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).

*****
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C1 A C2
+++++
assert_diffs.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
assert_diffs.

*****
H16 : not (eq A C2)
H15 : not (eq C D)
H17 : not (eq C1 A)
H14 : not (eq A' B')
H13 : not (eq E' F')
H12 : not (eq E F)
H9 : not (eq B C2)
H11 : not (eq E1 B)
H10 : not (eq A B)
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C1 A C2
+++++
apply l6_2 with B.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
assert_diffs.
apply l6_2 with B.

*****
H16 : not (eq A C2)
H15 : not (eq C D)
H17 : not (eq C1 A)
H14 : not (eq A' B')
H13 : not (eq E' F')
H12 : not (eq E F)
H9 : not (eq B C2)
H11 : not (eq E1 B)
H10 : not (eq A B)
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B A)
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
assert_diffs.
apply l6_2 with B.

*****
H16 : not (eq A C2)
H15 : not (eq C D)
H17 : not (eq C1 A)
H14 : not (eq A' B')
H13 : not (eq E' F')
H12 : not (eq E F)
H9 : not (eq B C2)
H11 : not (eq E1 B)
H10 : not (eq A B)
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C1 A)
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
assert_diffs.
apply l6_2 with B.

*****
H16 : not (eq A C2)
H15 : not (eq C D)
H17 : not (eq C1 A)
H14 : not (eq A' B')
H13 : not (eq E' F')
H12 : not (eq E F)
H9 : not (eq B C2)
H11 : not (eq E1 B)
H10 : not (eq A B)
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C2 A)
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
assert_diffs.
apply l6_2 with B.

*****
H16 : not (eq A C2)
H15 : not (eq C D)
H17 : not (eq C1 A)
H14 : not (eq A' B')
H13 : not (eq E' F')
H12 : not (eq E F)
H9 : not (eq B C2)
H11 : not (eq E1 B)
H10 : not (eq A B)
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B A C2
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
assert_diffs.
apply l6_2 with B.

*****
H16 : not (eq A C2)
H15 : not (eq C D)
H17 : not (eq C1 A)
H14 : not (eq A' B')
H13 : not (eq E' F')
H12 : not (eq E F)
H9 : not (eq B C2)
H11 : not (eq E1 B)
H10 : not (eq A B)
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B C1
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).

*****
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C1 E1 C2
+++++
idtac.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.

*****
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C1 E1 C2
+++++
apply not_out_bet.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.

*****
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Col C1 E1 C2
+++++
ColR.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.

*****
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Out E1 C1 C2)
+++++
intro HOut.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.

*****
HOut : Out E1 C1 C2
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].

*****
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Bet A C1 E1).
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).

*****
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C1 E1
+++++
eBetween.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Bet A E1 B).
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A E1 B
+++++
apply out2__bet.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A E1 B
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A E1 B
+++++
apply l6_7 with C1.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.
apply l6_7 with C1.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A E1 C1
+++++
apply l6_6.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.
apply l6_7 with C1.
apply l6_6.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C1 E1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.
apply l6_7 with C1.
apply l6_6.
trivial.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C1 E1
+++++
assert_diffs.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.
apply l6_7 with C1.
apply l6_6.
trivial.
assert_diffs.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C1 E1
+++++
apply bet_out.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.
apply l6_7 with C1.
apply l6_6.
trivial.
assert_diffs.
apply bet_out.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C1 A)
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.
apply l6_7 with C1.
apply l6_6.
trivial.
assert_diffs.
apply bet_out.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C1 E1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.
apply l6_7 with C1.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A C1 B
+++++
apply l6_6.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.
trivial.
apply l6_7 with C1.
apply l6_6.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A B C1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply out2__bet.

*****
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out B A E1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (le__nlt A B A' B').
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A' B'
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A' B' A B
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A' B' A B
+++++
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D A E1
+++++
Sums.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D A E1
+++++
Le.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C D A E1
+++++
split.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D A E1
+++++
exists C1.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
exists C1.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A C1 E1) (Cong C D A C1)
+++++
split.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
exists C1.
split.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C1 E1
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
exists C1.
split.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C D A C1
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong C D A E1)
+++++
intro HCong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
intro HCong.

*****
HCong : Cong C D A E1
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HC1E1, between_cong with A.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
intro HCong.
apply HC1E1, between_cong with A.

*****
HCong : Cong C D A E1
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C1 E1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
intro HCong.
apply HC1E1, between_cong with A.

*****
HCong : Cong C D A E1
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C1 A E1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
intro HCong.
apply HC1E1, between_cong with A.
trivial.

*****
HCong : Cong C D A E1
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C1 A E1
+++++
apply cong_transitivity with C D.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
intro HCong.
apply HC1E1, between_cong with A.
trivial.
apply cong_transitivity with C D.

*****
HCong : Cong C D A E1
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C1 C D
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.
Le.
split.
intro HCong.
apply HC1E1, between_cong with A.
trivial.
apply cong_transitivity with C D.

*****
HCong : Cong C D A E1
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C D A E1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le E F E1 B
+++++
Sums.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.
Sums.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le E F E1 B
+++++
Le.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS C D E F A' B'
+++++
Sums.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C1 E1).
idtac.
assert (Bet A E1 B).
apply (le__nlt A B A' B').
trivial.
apply le_lt12_sums2__lt with C D E F A E1 E1 B.

*****
H11 : Bet A E1 B
H10 : Bet A C1 E1
HBet : Bet E1 C1 C2
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS A E1 E1 B A B
+++++
Sums.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].

*****
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Bet A C2 E1).
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).

*****
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C2 E1
+++++
eBetween.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).

*****
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.

*****
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Bet B C2 E1).
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).

*****
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B C2 E1
+++++
assert_diffs.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B C2 E1
+++++
apply l6_2 with A.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.
apply l6_2 with A.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C2)
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.
apply l6_2 with A.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq B C2)
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.
apply l6_2 with A.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq E1 C2)
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.
apply l6_2 with A.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A C2 E1
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.
apply l6_2 with A.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C2 A B
+++++
auto.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.
apply l6_2 with A.
auto.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C2 A B
+++++
apply bet_out.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.
apply l6_2 with A.
auto.
apply bet_out.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C2)
+++++
Between.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
assert_diffs.
apply l6_2 with A.
auto.
apply bet_out.

*****
H21 : not (eq A C2)
H19 : not (eq C D)
H18 : not (eq C1 C2)
H20 : not (eq C1 A)
H17 : not (eq A' B')
H16 : not (eq E' F')
H15 : not (eq E F)
H12 : not (eq B C2)
H14 : not (eq E1 B)
H13 : not (eq A B)
H11 : not (eq A E1)
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C2 A B
+++++
Between.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
idtac.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (le__nlt E F E' F').
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le E F E' F'
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt E' F' E F
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt E' F' E F
+++++
apply (cong2_lt__lt B C2 B E1).
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt B C2 B E1
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt B C2 B E1
+++++
split.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
split.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B C2 B E1
+++++
exists C2.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
split.
exists C2.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet B C2 E1) (Cong B C2 B C2)
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
split.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong B C2 B E1)
+++++
idtac.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
split.
idtac.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong B C2 B E1)
+++++
intro HCong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
split.
idtac.
intro HCong.

*****
HCong : Cong B C2 B E1
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HC2E1, between_cong with B.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
split.
idtac.
intro HCong.
apply HC2E1, between_cong with B.

*****
HCong : Cong B C2 B E1
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B C2 E1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
split.
idtac.
intro HCong.
apply HC2E1, between_cong with B.

*****
HCong : Cong B C2 B E1
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B C2 B E1
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B C2 E' F'
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B C2 E' F'
+++++
apply (sums2__cong56 A B C D).
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
apply (sums2__cong56 A B C D).

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS A B C D B C2
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
apply (sums2__cong56 A B C D).
trivial.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS A B C D B C2
+++++
exists B, A, C2.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
apply (sums2__cong56 A B C D).
trivial.
exists B, A, C2.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet B A C2) (and (Cong B A A B) (and (Cong A C2 C D) (Cong B C2 B C2)))
+++++
repeat split.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
apply (sums2__cong56 A B C D).
trivial.
exists B, A, C2.
repeat split.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet B A C2
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
apply (sums2__cong56 A B C D).
trivial.
exists B, A, C2.
repeat split.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B A A B
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
apply (sums2__cong56 A B C D).
trivial.
exists B, A, C2.
repeat split.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C2 C D
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
apply (sums2__cong56 A B C D).
trivial.
exists B, A, C2.
repeat split.

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B C2 B C2
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).
Cong.
apply (sums2__cong56 A B C D).

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS A B C D E' F'
+++++
trivial.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).
idtac.
apply not_out_bet.
intro HOut.
destruct HOut as [HC1E1 [HC2E1 [HBet|HBet]]].
assert (Bet A C2 E1).
idtac.
assert (Bet B C2 E1).
idtac.
apply (le__nlt E F E' F').
trivial.
apply (cong2_lt__lt B C2 B E1).

*****
H11 : Bet B C2 E1
H10 : Bet A C2 E1
HBet : Bet E1 C2 C1
HC2E1 : not (eq C2 E1)
HC1E1 : not (eq C1 E1)
H9 : Bet C1 A C2
H8 : Cong B E1 E F
H7 : Out B A E1
H6 : Cong A C2 C D
H5 : Bet B A C2
H4 : Cong A C1 C D
H3 : Out A B C1
H2 : Le A B A' B'
H1 : Le E F E' F'
H0 : SumS C D E F A' B'
H : SumS A B C D E' F'
A,B,C,D,E,F,A',B',E',F',C1,C2,E1 : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B E1 E F
+++++
Cong.
-----
Lemma euclid_22_aux : forall A B C D E F A' B' E' F' C1 C2 E1, SumS A B C D E' F' -> SumS C D E F A' B' -> Le E F E' F' -> Le A B A' B' -> Out A B C1 -> Cong A C1 C D -> Bet B A C2 -> Cong A C2 C D -> Out B A E1 -> Cong B E1 E F -> Bet C1 E1 C2.
Proof.
intros A B C D E F A' B' E' F'.
intros.
assert (Bet C1 A C2).

*****

*****

+++++
Qed.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_bis, euclid_s_prop_1_22
+++++
Proof.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_bis, euclid_s_prop_1_22
+++++
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.

*****
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun P : Tpoint => ex (fun Q : Tpoint => ex (fun R : Tpoint => and (Cong P Q A B) (and (Cong P R C D) (Cong Q R E F)))))
+++++
exists A, B.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.

*****
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].

*****
H : eq A B
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
-
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-

*****
H : eq A B
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
destruct (segment_construction_0 C D A) as [P HCong].
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].

*****
HCong : Cong A P C D
P : Tpoint
H : eq A B
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
exists P; repeat split; Cong.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.

*****
HCong : Cong A P C D
P : Tpoint
H : eq A B
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B P E F
+++++
subst B.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.

*****
HCong : Cong A P C D
P : Tpoint
HLe3 : Le A A A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum1 : SumS A A C D E' F'
HSum2 : SumS A A E F C' D'
A,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A P E F
+++++
apply cong_transitivity with C D; trivial.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.

*****
HCong : Cong A P C D
P : Tpoint
HLe3 : Le A A A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum1 : SumS A A C D E' F'
HSum2 : SumS A A E F C' D'
A,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C D E F
+++++
apply le_anti_symmetry.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.

*****
HCong : Cong A P C D
P : Tpoint
HLe3 : Le A A A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum1 : SumS A A C D E' F'
HSum2 : SumS A A E F C' D'
A,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D E F
+++++
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.

*****
HCong : Cong A P C D
P : Tpoint
HLe3 : Le A A A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum1 : SumS A A C D E' F'
HSum2 : SumS A A E F C' D'
A,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le E F C D
+++++
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.

*****

*****

+++++
-
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-

*****
H0 : eq C D
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
exists A; treat_equalities; repeat split; Cong.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.

*****
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C C C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C C E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C C E' F'
A,B,C,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B A E F
+++++
apply le_anti_symmetry.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.

*****
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C C C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C C E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C C E' F'
A,B,C,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le B A E F
+++++
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.

*****
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C C C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C C E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C C E' F'
A,B,C,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le E F B A
+++++
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.

*****

*****

+++++
-
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-

*****
H1 : eq E F
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
exists B; treat_equalities; repeat split; Cong.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.

*****
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HSum2 : SumS A B E E C' D'
HSum3 : SumS C D E E A' B'
HLe1 : Le E E E' F'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B C D
+++++
apply le_anti_symmetry.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.

*****
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HSum2 : SumS A B E E C' D'
HSum3 : SumS C D E E A' B'
HLe1 : Le E E E' F'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B C D
+++++
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.

*****
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HSum2 : SumS A B E E C' D'
HSum3 : SumS C D E E A' B'
HLe1 : Le E E E' F'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D A B
+++++
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.

*****

*****

+++++
-
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-

*****
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.

*****
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.

*****
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].

*****
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].

*****
HE2' : Cong B E2 E F
HE2 : Bet A B E2
E2 : Tpoint
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).

*****
H2 : Bet C1 E1 C2
HE2' : Cong B E2 E F
HE2 : Bet A B E2
E2 : Tpoint
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
assert (Bet E1 C1 E2) by (apply (euclid_22_aux B A E F C D B' A' C' D'); Sums; Le).
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).
assert (Bet E1 C1 E2) by (apply (euclid_22_aux B A E F C D B' A' C' D'); Sums; Le).

*****
H3 : Bet E1 C1 E2
H2 : Bet C1 E1 C2
HE2' : Cong B E2 E F
HE2 : Bet A B E2
E2 : Tpoint
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
destruct (Hcc A C1 B E1 E1 C1) as [Z [HZ1 HZ2]]; Circle.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).
assert (Bet E1 C1 E2) by (apply (euclid_22_aux B A E F C D B' A' C' D'); Sums; Le).
destruct (Hcc A C1 B E1 E1 C1) as [Z [HZ1 HZ2]]; Circle.

*****
H3 : Bet E1 C1 E2
H2 : Bet C1 E1 C2
HE2' : Cong B E2 E F
HE2 : Bet A B E2
E2 : Tpoint
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle E1 A C1
+++++
apply bet_inc2__inc with C1 C2; Circle; apply onc__inc, cong_transitivity with C D; Cong.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).
assert (Bet E1 C1 E2) by (apply (euclid_22_aux B A E F C D B' A' C' D'); Sums; Le).
destruct (Hcc A C1 B E1 E1 C1) as [Z [HZ1 HZ2]]; Circle.
apply bet_inc2__inc with C1 C2; Circle; apply onc__inc, cong_transitivity with C D; Cong.

*****
H3 : Bet E1 C1 E2
H2 : Bet C1 E1 C2
HE2' : Cong B E2 E F
HE2 : Bet A B E2
E2 : Tpoint
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircle C1 B E1
+++++
apply bet_inc2__inc with E1 E2; Circle; apply onc__inc, cong_transitivity with E F; Cong.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).
assert (Bet E1 C1 E2) by (apply (euclid_22_aux B A E F C D B' A' C' D'); Sums; Le).
destruct (Hcc A C1 B E1 E1 C1) as [Z [HZ1 HZ2]]; Circle.
apply bet_inc2__inc with C1 C2; Circle; apply onc__inc, cong_transitivity with C D; Cong.
apply bet_inc2__inc with E1 E2; Circle; apply onc__inc, cong_transitivity with E F; Cong.

*****
HZ2 : OnCircle Z B E1
HZ1 : OnCircle Z A C1
Z : Tpoint
H3 : Bet E1 C1 E2
H2 : Bet C1 E1 C2
HE2' : Cong B E2 E F
HE2 : Bet A B E2
E2 : Tpoint
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => and (Cong A B A B) (and (Cong A R C D) (Cong B R E F)))
+++++
exists Z; repeat split; Cong.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).
assert (Bet E1 C1 E2) by (apply (euclid_22_aux B A E F C D B' A' C' D'); Sums; Le).
destruct (Hcc A C1 B E1 E1 C1) as [Z [HZ1 HZ2]]; Circle.
apply bet_inc2__inc with C1 C2; Circle; apply onc__inc, cong_transitivity with C D; Cong.
apply bet_inc2__inc with E1 E2; Circle; apply onc__inc, cong_transitivity with E F; Cong.
exists Z; repeat split; Cong.

*****
HZ2 : OnCircle Z B E1
HZ1 : OnCircle Z A C1
Z : Tpoint
H3 : Bet E1 C1 E2
H2 : Bet C1 E1 C2
HE2' : Cong B E2 E F
HE2 : Bet A B E2
E2 : Tpoint
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Z C D
+++++
apply cong_transitivity with A C1; Cong.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).
assert (Bet E1 C1 E2) by (apply (euclid_22_aux B A E F C D B' A' C' D'); Sums; Le).
destruct (Hcc A C1 B E1 E1 C1) as [Z [HZ1 HZ2]]; Circle.
apply bet_inc2__inc with C1 C2; Circle; apply onc__inc, cong_transitivity with C D; Cong.
apply bet_inc2__inc with E1 E2; Circle; apply onc__inc, cong_transitivity with E F; Cong.
exists Z; repeat split; Cong.
apply cong_transitivity with A C1; Cong.

*****
HZ2 : OnCircle Z B E1
HZ1 : OnCircle Z A C1
Z : Tpoint
H3 : Bet E1 C1 E2
H2 : Bet C1 E1 C2
HE2' : Cong B E2 E F
HE2 : Bet A B E2
E2 : Tpoint
HC2' : Cong A C2 C D
HC2 : Bet B A C2
C2 : Tpoint
HE1' : Cong B E1 E F
HE1 : Out B A E1
E1 : Tpoint
HC1' : Cong A C1 C D
HC1 : Out A B C1
C1 : Tpoint
H1 : not (eq E F)
H0 : not (eq C D)
H : not (eq A B)
HLe3 : Le A B A' B'
HLe2 : Le C D C' D'
HLe1 : Le E F E' F'
HSum3 : SumS C D E F A' B'
HSum2 : SumS A B E F C' D'
HSum1 : SumS A B C D E' F'
A,B,C,D,E,F,A',B',C',D',E',F' : Tpoint
Hcc : circle_circle_bis
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B Z E F
+++++
apply cong_transitivity with B E1; Cong.
-----
Lemma circle_circle_bis__euclid_22 : circle_circle_bis -> euclid_s_prop_1_22.
Proof.
intros Hcc A B C D E F A' B' C' D' E' F' HSum1 HSum2 HSum3 HLe1 HLe2 HLe3.
exists A, B.
destruct (eq_dec_points A B); [|destruct (eq_dec_points C D)]; [| |destruct (eq_dec_points E F)].
-
destruct (segment_construction_0 C D A) as [P HCong].
exists P; repeat split; Cong.
subst B.
apply cong_transitivity with C D; trivial.
apply le_anti_symmetry.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A A E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A A C D); Sums.
-
exists A; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C C E F); Sums.
apply (l5_6 E F E' F'); Cong; apply (sums2__cong56 A B C C); Sums.
-
exists B; treat_equalities; repeat split; Cong.
apply le_anti_symmetry.
apply (l5_6 A B A' B'); Cong; apply (sums2__cong56 C D E E); Sums.
apply (l5_6 C D C' D'); Cong; apply (sums2__cong56 A B E E); Sums.
-
destruct (segment_construction_3 A B C D) as [C1 [HC1 HC1']]; auto.
destruct (segment_construction_3 B A E F) as [E1 [HE1 HE1']]; auto.
destruct (segment_construction B A C D) as [C2 [HC2 HC2']].
destruct (segment_construction A B E F) as [E2 [HE2 HE2']].
assert (Bet C1 E1 C2) by (apply (euclid_22_aux A B C D E F A' B' E' F'); trivial).
assert (Bet E1 C1 E2) by (apply (euclid_22_aux B A E F C D B' A' C' D'); Sums; Le).
destruct (Hcc A C1 B E1 E1 C1) as [Z [HZ1 HZ2]]; Circle.
apply bet_inc2__inc with C1 C2; Circle; apply onc__inc, cong_transitivity with C D; Cong.
apply bet_inc2__inc with E1 E2; Circle; apply onc__inc, cong_transitivity with E F; Cong.
exists Z; repeat split; Cong.
apply cong_transitivity with A C1; Cong.
apply cong_transitivity with B E1; Cong.

*****

*****

+++++
Qed.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E : Tpoint) (_ : SumS A B B C D E), Le A C D E
+++++
Proof.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D E : Tpoint) (_ : SumS A B B C D E), Le A C D E
+++++
intros A B C D E HSum.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.

*****
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C D E
+++++
destruct (segment_construction A B B C) as [D' [HBet HCong]].
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C D E
+++++
apply (l5_6 A C A D').
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C A D'
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C A D'
+++++
apply triangle_inequality with B.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply triangle_inequality with B.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B D'
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply triangle_inequality with B.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B C B D'
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A C A C
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D' D E
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D' D E
+++++
apply (sums2__cong56 A B B C).
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply (sums2__cong56 A B B C).

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS A B B C A D'
+++++
trivial.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply (sums2__cong56 A B B C).
trivial.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS A B B C A D'
+++++
exists A, B, D'.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply (sums2__cong56 A B B C).
trivial.
exists A, B, D'.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (Bet A B D') (and (Cong A B A B) (and (Cong B D' B C) (Cong A D' A D')))
+++++
repeat split.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply (sums2__cong56 A B B C).
trivial.
exists A, B, D'.
repeat split.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A B D'
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply (sums2__cong56 A B B C).
trivial.
exists A, B, D'.
repeat split.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A B A B
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply (sums2__cong56 A B B C).
trivial.
exists A, B, D'.
repeat split.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong B D' B C
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply (sums2__cong56 A B B C).
trivial.
exists A, B, D'.
repeat split.

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A D' A D'
+++++
Cong.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').
Cong.
apply (sums2__cong56 A B B C).

*****
HCong : Cong B D' B C
HBet : Bet A B D'
D' : Tpoint
HSum : SumS A B B C D E
A,B,C,D,E : Tpoint
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS A B B C D E
+++++
trivial.
-----
Lemma triangle_inequality1 : forall A B C D E, SumS A B B C D E -> Le A C D E.
Proof.
intros A B C D E HSum.
destruct (segment_construction A B B C) as [D' [HBet HCong]].
apply (l5_6 A C A D').

*****

*****

+++++
Qed.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : euclid_s_prop_1_22, circle_circle
+++++
Proof.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : euclid_s_prop_1_22, circle_circle
+++++
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.

*****
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\ Cong X Z A B /\ Cong Y Z C D).
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).

*****
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => ex (fun Z : Tpoint => and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
+++++
destruct (ex_sums A B C D) as [L1 [R1]].
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].

*****
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => ex (fun Z : Tpoint => and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
+++++
destruct (ex_sums A C C D) as [L2 [R2]].
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].

*****
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => ex (fun Z : Tpoint => and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
+++++
destruct (ex_sums A C A B) as [L3 [R3]].
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].

*****
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => ex (fun Y : Tpoint => ex (fun Z : Tpoint => and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
+++++
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.

*****
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D L3 R3
+++++
-
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-

*****
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D L3 R3
+++++
destruct (ex_sums C A A P) as [R [S]].
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].

*****
H2 : SumS C A A P R S
R,S : Tpoint
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D L3 R3
+++++
apply le_transitivity with R S.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.

*****
H2 : SumS C A A P R S
R,S : Tpoint
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le C D R S
+++++
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.

*****
H2 : SumS C A A P R S
R,S : Tpoint
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le R S L3 R3
+++++
apply le2_sums2__le with C A A P A C A B; Le.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.

*****

*****

+++++
-
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.
-

*****
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B L2 R2
+++++
apply le_transitivity with A Q; Le.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.
-
apply le_transitivity with A Q; Le.

*****
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Q L2 R2
+++++
apply (triangle_inequality1 A C Q).
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.
-
apply le_transitivity with A Q; Le.
apply (triangle_inequality1 A C Q).

*****
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumS A C C Q L2 R2
+++++
apply (cong3_sums__sums A C C D L2 R2); Cong.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.
-
apply le_transitivity with A Q; Le.
apply (triangle_inequality1 A C Q).
apply (cong3_sums__sums A C C D L2 R2); Cong.

*****

*****

+++++
-
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.
-
apply le_transitivity with A Q; Le.
apply (triangle_inequality1 A C Q).
apply (cong3_sums__sums A C C D L2 R2); Cong.
-

*****
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C L1 R1
+++++
destruct (ex_sums A P P C) as [R [S]].
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.
-
apply le_transitivity with A Q; Le.
apply (triangle_inequality1 A C Q).
apply (cong3_sums__sums A C C D L2 R2); Cong.
-
destruct (ex_sums A P P C) as [R [S]].

*****
H2 : SumS A P P C R S
R,S : Tpoint
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C L1 R1
+++++
apply le_transitivity with R S.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.
-
apply le_transitivity with A Q; Le.
apply (triangle_inequality1 A C Q).
apply (cong3_sums__sums A C C D L2 R2); Cong.
-
destruct (ex_sums A P P C) as [R [S]].
apply le_transitivity with R S.

*****
H2 : SumS A P P C R S
R,S : Tpoint
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A C R S
+++++
apply triangle_inequality1 with P; trivial.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (ex_sums A B C D) as [L1 [R1]].
destruct (ex_sums A C C D) as [L2 [R2]].
destruct (ex_sums A C A B) as [L3 [R3]].
apply p22 with L1 R1 L2 R2 L3 R3; trivial.
-
destruct (ex_sums C A A P) as [R [S]].
apply le_transitivity with R S.
apply (l5_6 C P R S); Cong; apply triangle_inequality1 with A; trivial.
apply le2_sums2__le with C A A P A C A B; Le.
-
apply le_transitivity with A Q; Le.
apply (triangle_inequality1 A C Q).
apply (cong3_sums__sums A C C D L2 R2); Cong.
-
destruct (ex_sums A P P C) as [R [S]].
apply le_transitivity with R S.
apply triangle_inequality1 with P; trivial.

*****
H2 : SumS A P P C R S
R,S : Tpoint
H1 : SumS A C A B L3 R3
L3,R3 : Tpoint
H0 : SumS A C C D L2 R2
L2,R2 : Tpoint
H : SumS A B C D L1 R1
L1,R1 : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le R S L1 R1
+++++
apply le2_sums2__le with A P P C A B C D; Le.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).

*****
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (eq_dec_points A C).
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).

*****
H : eq A C
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
subst C.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
subst C.

*****
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A A) (and (Cong X Z A B) (Cong Y Z A D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P A D
HQOn : OnCircle Q A D
A,B,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z A D))
+++++
exists B; split; Circle.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
subst C.
exists B; split; Circle.

*****
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A A) (and (Cong X Z A B) (Cong Y Z A D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P A D
HQOn : OnCircle Q A D
A,B,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle B A D
+++++
apply le_anti_symmetry.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
subst C.
exists B; split; Circle.
apply le_anti_symmetry.

*****
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A A) (and (Cong X Z A B) (Cong Y Z A D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P A D
HQOn : OnCircle Q A D
A,B,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A B A D
+++++
apply le_transitivity with A Q; Le.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
subst C.
exists B; split; Circle.
apply le_anti_symmetry.
apply le_transitivity with A Q; Le.

*****
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A A) (and (Cong X Z A B) (Cong Y Z A D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HPOn : OnCircle P A D
HQOn : OnCircle Q A D
A,B,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A D A B
+++++
apply le_transitivity with A P; Le.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).

*****
H : not (eq A C)
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (eq_dec_points A B).
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).

*****
H0 : eq A B
H : not (eq A C)
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
subst B.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
subst B.

*****
H : not (eq A C)
HPIn : InCircle P A A
HQOut : OutCircle Q A A
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A C) (and (Cong X Z A A) (Cong Y Z C D)))))
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A A) (OnCircle Z C D))
+++++
exists P; split; trivial.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
subst B.
exists P; split; trivial.

*****
H : not (eq A C)
HPIn : InCircle P A A
HQOut : OutCircle Q A A
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A C) (and (Cong X Z A A) (Cong Y Z C D)))))
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P A A
+++++
apply inc_eq in HPIn; subst; Circle.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).

*****
H0 : not (eq A B)
H : not (eq A C)
HXYZ : ex\n (fun X : Tpoint =>\n ex\n (fun Y : Tpoint =>\n ex\n (fun Z : Tpoint =>\n and (Cong X Y A C) (and (Cong X Z A B) (Cong Y Z C D)))))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].

*****
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert_diffs.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.

*****
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\ Cong X Z A Z0).
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).

*****
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z0 : Tpoint => and (CongA Y X Z C A Z0) (Cong X Z A Z0))
+++++
destruct (angle_construction_3 Y X Z C A) as [Z']; auto.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct (angle_construction_3 Y X Z C A) as [Z']; auto.

*****
H3 : CongA Y X Z C A Z'
Z' : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z0 : Tpoint => and (CongA Y X Z C A Z0) (Cong X Z A Z0))
+++++
assert_diffs.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct (angle_construction_3 Y X Z C A) as [Z']; auto.
assert_diffs.

*****
H4 : not (eq Z' A)
H3 : CongA Y X Z C A Z'
Z' : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z0 : Tpoint => and (CongA Y X Z C A Z0) (Cong X Z A Z0))
+++++
destruct (segment_construction_3 A Z' X Z) as [Z0 []]; auto.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct (angle_construction_3 Y X Z C A) as [Z']; auto.
assert_diffs.
destruct (segment_construction_3 A Z' X Z) as [Z0 []]; auto.

*****
H6 : Cong A Z0 X Z
H5 : Out A Z' Z0
Z0 : Tpoint
H4 : not (eq Z' A)
H3 : CongA Y X Z C A Z'
Z' : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z0 : Tpoint => and (CongA Y X Z C A Z0) (Cong X Z A Z0))
+++++
exists Z0; split; Cong.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct (angle_construction_3 Y X Z C A) as [Z']; auto.
assert_diffs.
destruct (segment_construction_3 A Z' X Z) as [Z0 []]; auto.
exists Z0; split; Cong.

*****
H6 : Cong A Z0 X Z
H5 : Out A Z' Z0
Z0 : Tpoint
H4 : not (eq Z' A)
H3 : CongA Y X Z C A Z'
Z' : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA Y X Z C A Z0
+++++
apply out_conga with Y Z C Z'; [|apply out_trivial..|]; auto.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).

*****
HZ0 : ex (fun Z0 : Tpoint => and (CongA Y X Z C A Z0) (Cong X Z A Z0))
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct HZ0 as [Z0 []].
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct HZ0 as [Z0 []].

*****
H4 : Cong X Z A Z0
H3 : CongA Y X Z C A Z0
Z0 : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
exists Z0.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct HZ0 as [Z0 []].
exists Z0.

*****
H4 : Cong X Z A Z0
H3 : CongA Y X Z C A Z0
Z0 : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z0 A B) (OnCircle Z0 C D)
+++++
destruct (l11_49 Y X Z C A Z0); trivial.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct HZ0 as [Z0 []].
exists Z0.
destruct (l11_49 Y X Z C A Z0); trivial.

*****
H6 : forall _ : not (eq Y Z), and (CongA X Y Z A C Z0) (CongA X Z Y A Z0 C)
H5 : Cong Y Z C Z0
H4 : Cong X Z A Z0
H3 : CongA Y X Z C A Z0
Z0 : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Z0 A B) (OnCircle Z0 C D)
+++++
split.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct HZ0 as [Z0 []].
exists Z0.
destruct (l11_49 Y X Z C A Z0); trivial.
split.

*****
H6 : forall _ : not (eq Y Z), and (CongA X Y Z A C Z0) (CongA X Z Y A Z0 C)
H5 : Cong Y Z C Z0
H4 : Cong X Z A Z0
H3 : CongA Y X Z C A Z0
Z0 : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z0 A B
+++++
apply cong_transitivity with X Z; Cong.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct HZ0 as [Z0 []].
exists Z0.
destruct (l11_49 Y X Z C A Z0); trivial.
split.
apply cong_transitivity with X Z; Cong.

*****
H6 : forall _ : not (eq Y Z), and (CongA X Y Z A C Z0) (CongA X Z Y A Z0 C)
H5 : Cong Y Z C Z0
H4 : Cong X Z A Z0
H3 : CongA Y X Z C A Z0
Z0 : Tpoint
H2 : not (eq X Y)
H1 : not (eq X Z)
H0 : not (eq A B)
H : not (eq A C)
HCD : Cong Y Z C D
HAB : Cong X Z A B
HAC : Cong X Y A C
X,Y,Z : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
p22 : euclid_s_prop_1_22
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z0 C D
+++++
apply cong_transitivity with Y Z; Cong.
-----
Lemma euclid_22__circle_circle : euclid_s_prop_1_22 -> circle_circle.
Proof.
intros p22 A B C D P Q HPOn HQOn HPIn HQOut.
assert (HXYZ : exists X Y Z : Tpoint, Cong X Y A C /\\ Cong X Z A B /\\ Cong Y Z C D).
destruct (eq_dec_points A C).
destruct (eq_dec_points A B).
destruct HXYZ as [X [Y [Z [HAC [HAB HCD]]]]].
assert_diffs.
assert (HZ0 : exists Z0, CongA Y X Z C A Z0 /\\ Cong X Z A Z0).
destruct HZ0 as [Z0 []].
exists Z0.
destruct (l11_49 Y X Z C A Z0); trivial.
split.
apply cong_transitivity with X Z; Cong.
apply cong_transitivity with Y Z; Cong.

*****

*****

+++++
Qed.
-----
Theorem equivalent_variants_of_circle_circle :\n  all_equiv\n    (circle_circle::\n     circle_circle_two::\n     circle_circle_bis::\n     circle_circle_axiom::\n     euclid_s_prop_1_22::\n     nil).
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
Proof.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
assert (V := circle_circle_bis__circle_circle_axiom).
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).

*****
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
assert (W := circle_circle__circle_circle_bis).
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).

*****
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
assert (X := circle_circle__circle_circle_two).
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).

*****
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
assert (Y := circle_circle_bis__euclid_22).
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).

*****
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
assert (Z := euclid_22__circle_circle).
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
apply all_equiv__equiv.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv' (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
unfold all_equiv'.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.
unfold all_equiv'.

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
list_rect (fun _ : list Prop => Prop) True (fun (a : Prop) (l : list Prop) (_ : Prop) => and (forall _ : last l a, a) (all_equiv'_aux (cons a l))) (cons circle_circle (cons circle_circle_two (cons circle_circle_bis (cons circle_circle_axiom (cons euclid_s_prop_1_22 nil)))))
+++++
simpl.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.
unfold all_equiv'.
simpl.

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (forall _ : euclid_s_prop_1_22, circle_circle) (and (forall _ : circle_circle, circle_circle_two) (and (forall _ : circle_circle_two, circle_circle_bis) (and (forall _ : circle_circle_bis, circle_circle_axiom) (and (forall _ : circle_circle_axiom, euclid_s_prop_1_22) True))))
+++++
repeat split.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : euclid_s_prop_1_22, circle_circle
+++++
tauto.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle, circle_circle_two
+++++
tauto.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_two, circle_circle_bis
+++++
tauto.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_bis, circle_circle_axiom
+++++
tauto.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****
Z : forall _ : euclid_s_prop_1_22, circle_circle
Y : forall _ : circle_circle_bis, euclid_s_prop_1_22
X : iff circle_circle circle_circle_two
W : forall _ : circle_circle, circle_circle_bis
V : iff circle_circle_bis circle_circle_axiom
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : circle_circle_axiom, euclid_s_prop_1_22
+++++
tauto.
-----
Theorem equivalent_variants_of_circle_circle : all_equiv (circle_circle:: circle_circle_two:: circle_circle_bis:: circle_circle_axiom:: euclid_s_prop_1_22:: nil).
Proof.
assert (V := circle_circle_bis__circle_circle_axiom).
assert (W := circle_circle__circle_circle_bis).
assert (X := circle_circle__circle_circle_two).
assert (Y := circle_circle_bis__euclid_22).
assert (Z := euclid_22__circle_circle).
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****

*****

+++++
Qed.
-----
Theorem equivalent_variants_of_line_circle :\n  all_equiv\n    (segment_circle::\n     one_point_line_circle::\n     two_points_line_circle::\n     nil).
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons segment_circle (cons one_point_line_circle (cons two_points_line_circle nil)))
+++++
Proof.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv (cons segment_circle (cons one_point_line_circle (cons two_points_line_circle nil)))
+++++
apply all_equiv__equiv.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
all_equiv' (cons segment_circle (cons one_point_line_circle (cons two_points_line_circle nil)))
+++++
unfold all_equiv'.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
list_rect (fun _ : list Prop => Prop) True (fun (a : Prop) (l : list Prop) (_ : Prop) => and (forall _ : last l a, a) (all_equiv'_aux (cons a l))) (cons segment_circle (cons one_point_line_circle (cons two_points_line_circle nil)))
+++++
simpl.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (forall _ : two_points_line_circle, segment_circle) (and (forall _ : segment_circle, one_point_line_circle) (and (forall _ : one_point_line_circle, two_points_line_circle) True))
+++++
repeat split.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : two_points_line_circle, segment_circle
+++++
rewrite segment_circle__one_point_line_circle.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.
rewrite segment_circle__one_point_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : two_points_line_circle, one_point_line_circle
+++++
rewrite one_point_line_circle__two_points_line_circle.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.
rewrite segment_circle__one_point_line_circle.
rewrite one_point_line_circle__two_points_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : two_points_line_circle, two_points_line_circle
+++++
trivial.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : segment_circle, one_point_line_circle
+++++
rewrite segment_circle__one_point_line_circle.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.
rewrite segment_circle__one_point_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : one_point_line_circle, one_point_line_circle
+++++
trivial.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : one_point_line_circle, two_points_line_circle
+++++
rewrite one_point_line_circle__two_points_line_circle.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.
rewrite one_point_line_circle__two_points_line_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : two_points_line_circle, two_points_line_circle
+++++
trivial.
-----
Theorem equivalent_variants_of_line_circle : all_equiv (segment_circle:: one_point_line_circle:: two_points_line_circle:: nil).
Proof.
apply all_equiv__equiv.
unfold all_equiv'.
simpl.
repeat split.

*****

*****

+++++
Qed.
-----
End Elementary_Continuity_Props.
-----
